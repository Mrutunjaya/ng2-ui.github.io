webpackJsonp([0],{

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar core_1 = __webpack_require__(1);\nvar platform_browser_dynamic_1 = __webpack_require__(19);\nvar app_module_1 = __webpack_require__(23);\n// depending on the env mode, enable prod mode or add debugging modules\nif (false) {\n    core_1.enableProdMode();\n}\nfunction main() {\n    return platform_browser_dynamic_1.platformBrowserDynamic().bootstrapModule(app_module_1.AppModule);\n}\nexports.main = main;\nif (document.readyState === 'complete') {\n    main();\n}\nelse {\n    document.addEventListener('DOMContentLoaded', main);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi50cz85NTg0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxpQ0FBK0IsQ0FBZSxDQUFDO0FBQy9DLHFEQUF1QyxFQUFtQyxDQUFDO0FBQzNFLHVDQUEwQixFQUFjLENBQUM7QUFFekMsdUVBQXVFO0FBQ3ZFLEVBQUUsQ0FBQyxDQUFDLEtBQTJCLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLHFCQUFjLEVBQUUsQ0FBQztBQUNuQixDQUFDO0FBRUQ7SUFDRSxNQUFNLENBQUMsaURBQXNCLEVBQUUsQ0FBQyxlQUFlLENBQUMsc0JBQVMsQ0FBQyxDQUFDO0FBQzdELENBQUM7QUFGZSxZQUFJLE9BRW5CO0FBRUQsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQVUsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQ3ZDLElBQUksRUFBRSxDQUFDO0FBQ1QsQ0FBQztBQUFDLElBQUksQ0FBQyxDQUFDO0lBQ04sUUFBUSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3RELENBQUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVuYWJsZVByb2RNb2RlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci1keW5hbWljJztcbmltcG9ydCB7IEFwcE1vZHVsZSB9IGZyb20gJy4vYXBwLm1vZHVsZSc7XG5cbi8vIGRlcGVuZGluZyBvbiB0aGUgZW52IG1vZGUsIGVuYWJsZSBwcm9kIG1vZGUgb3IgYWRkIGRlYnVnZ2luZyBtb2R1bGVzXG5pZiAocHJvY2Vzcy5lbnYuRU5WID09PSAnYnVpbGQnKSB7XG4gIGVuYWJsZVByb2RNb2RlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWluKCk6IGFueSB7XG4gIHJldHVybiBwbGF0Zm9ybUJyb3dzZXJEeW5hbWljKCkuYm9vdHN0cmFwTW9kdWxlKEFwcE1vZHVsZSk7XG59XG5cbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gIG1haW4oKTtcbn0gZWxzZSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBtYWluKTtcbn1cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL21haW4udHNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 23:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar platform_browser_1 = __webpack_require__(21);\nvar forms_1 = __webpack_require__(24);\nvar http_1 = __webpack_require__(28);\nvar common_1 = __webpack_require__(22);\nvar app_component_1 = __webpack_require__(29);\nvar drawer_component_1 = __webpack_require__(358);\nvar repo_info_component_1 = __webpack_require__(359);\nvar http_cache_1 = __webpack_require__(360);\nvar ng2_storage_1 = __webpack_require__(361);\nvar app_routes_1 = __webpack_require__(362);\nvar getting_started_component_1 = __webpack_require__(378);\nvar accordion_component_1 = __webpack_require__(364);\nvar datetime_picker_component_1 = __webpack_require__(365);\nvar google_map_component_1 = __webpack_require__(366);\nvar infinite_list_component_1 = __webpack_require__(367);\nvar menu_component_1 = __webpack_require__(376);\nvar overlay_component_1 = __webpack_require__(368);\nvar parallax_scroll_component_1 = __webpack_require__(369);\nvar popup_component_1 = __webpack_require__(370);\nvar scrollable_component_1 = __webpack_require__(371);\nvar sticky_component_1 = __webpack_require__(372);\nvar tab_component_1 = __webpack_require__(373);\nvar tooltip_component_1 = __webpack_require__(374);\nvar auto_complete_component_1 = __webpack_require__(375);\nvar sortable_component_1 = __webpack_require__(377);\nvar ng2_ui_1 = __webpack_require__(58);\nvar AppModule = (function () {\n    function AppModule() {\n    }\n    AppModule = __decorate([\n        core_1.NgModule({\n            imports: [\n                platform_browser_1.BrowserModule,\n                forms_1.FormsModule,\n                http_1.HttpModule,\n                ng2_ui_1.Ng2UIModule,\n                app_routes_1.APP_ROUTER_PROVIDERS\n            ],\n            declarations: [\n                app_component_1.AppComponent,\n                drawer_component_1.DrawerComponent,\n                repo_info_component_1.RepoInfoComponent,\n                getting_started_component_1.GettingStartedComponent,\n                accordion_component_1.AccordionComponent,\n                auto_complete_component_1.AutoCompleteComponent,\n                datetime_picker_component_1.DatetimePickerComponent,\n                google_map_component_1.GoogleMapComponent,\n                infinite_list_component_1.InfiniteListComponent,\n                menu_component_1.MenuComponent,\n                overlay_component_1.OverlayComponent,\n                parallax_scroll_component_1.ParallaxScrollComponent,\n                popup_component_1.PopupComponent,\n                scrollable_component_1.ScrollableComponent,\n                sticky_component_1.StickyComponent,\n                tab_component_1.TabComponent,\n                tooltip_component_1.TooltipComponent,\n                sortable_component_1.SortableComponent\n            ],\n            providers: [\n                http_cache_1.HttpCache,\n                ng2_storage_1.Ng2Storage,\n                { provide: common_1.LocationStrategy, useClass: common_1.HashLocationStrategy }\n            ],\n            bootstrap: [app_component_1.AppComponent]\n        }), \n        __metadata('design:paramtypes', [])\n    ], AppModule);\n    return AppModule;\n}());\nexports.AppModule = AppModule;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvYXBwLm1vZHVsZS50cz9lZGMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBK0IsQ0FBZSxDQUFDO0FBQy9DLDZDQUErQixFQUEyQixDQUFDO0FBQzNELGtDQUErQixFQUFnQixDQUFDO0FBQ2hELGlDQUEyQixFQUFlLENBQUM7QUFDM0MsbUNBQXVELEVBQWlCLENBQUM7QUFFekUsMENBQStCLEVBQWlCLENBQUM7QUFDakQsNkNBQWdDLEdBQW9CLENBQUM7QUFDckQsZ0RBQWtDLEdBQXVCLENBQUM7QUFDMUQsdUNBQTBCLEdBQWMsQ0FBQztBQUN6Qyx3Q0FBMkIsR0FBZSxDQUFDO0FBQzNDLHVDQUFxQyxHQUFjLENBQUM7QUFDcEQsc0RBQXNDLEdBQTZCLENBQUM7QUFDcEUsZ0RBQWlDLEdBQXlDLENBQUM7QUFDM0Usc0RBQXNDLEdBQStDLENBQUM7QUFDdEYsaURBQWlDLEdBQTBDLENBQUM7QUFDNUUsb0RBQW9DLEdBQTZDLENBQUM7QUFDbEYsMkNBQTRCLEdBQW9DLENBQUM7QUFDakUsOENBQStCLEdBQXVDLENBQUM7QUFDdkUsc0RBQXNDLEdBQStDLENBQUM7QUFDdEYsNENBQTZCLEdBQXFDLENBQUM7QUFDbkUsaURBQWtDLEdBQTBDLENBQUM7QUFDN0UsNkNBQThCLEdBQXNDLENBQUM7QUFDckUsMENBQTJCLEdBQW1DLENBQUM7QUFDL0QsOENBQStCLEdBQXVDLENBQUM7QUFDdkUsb0RBQW9DLEdBQTZDLENBQUM7QUFDbEYsK0NBQWdDLEdBQXdDLENBQUM7QUFDekUsbUNBQTBCLEVBQVEsQ0FBQztBQXNDbkM7SUFBQTtJQUF5QixDQUFDO0lBbkMxQjtRQUFDLGVBQVEsQ0FBQztZQUNSLE9BQU8sRUFBRTtnQkFDUCxnQ0FBYTtnQkFDYixtQkFBVztnQkFDWCxpQkFBVTtnQkFDVixvQkFBVztnQkFDWCxpQ0FBb0I7YUFDckI7WUFDRCxZQUFZLEVBQUU7Z0JBQ1osNEJBQVk7Z0JBQ1osa0NBQWU7Z0JBQ2YsdUNBQWlCO2dCQUNqQixtREFBdUI7Z0JBQ3ZCLHdDQUFrQjtnQkFDbEIsK0NBQXFCO2dCQUNyQixtREFBdUI7Z0JBQ3ZCLHlDQUFrQjtnQkFDbEIsK0NBQXFCO2dCQUNyQiw4QkFBYTtnQkFDYixvQ0FBZ0I7Z0JBQ2hCLG1EQUF1QjtnQkFDdkIsZ0NBQWM7Z0JBQ2QsMENBQW1CO2dCQUNuQixrQ0FBZTtnQkFDZiw0QkFBWTtnQkFDWixvQ0FBZ0I7Z0JBQ2hCLHNDQUFpQjthQUNsQjtZQUNELFNBQVMsRUFBRTtnQkFDVCxzQkFBUztnQkFDVCx3QkFBVTtnQkFDVixFQUFDLE9BQU8sRUFBRSx5QkFBZ0IsRUFBRSxRQUFRLEVBQUUsNkJBQW9CLEVBQUM7YUFDNUQ7WUFDRCxTQUFTLEVBQUUsQ0FBRSw0QkFBWSxDQUFFO1NBQzVCLENBQUM7O2lCQUFBO0lBQ3VCLGdCQUFDO0FBQUQsQ0FBQztBQUFiLGlCQUFTLFlBQUkiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZ01vZHVsZSB9ICAgICAgIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9ICBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gICAgZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBIdHRwTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL2h0dHBcIjtcbmltcG9ydCB7IExvY2F0aW9uU3RyYXRlZ3ksIEhhc2hMb2NhdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gICBmcm9tICcuL2FwcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRHJhd2VyQ29tcG9uZW50IH0gZnJvbSBcIi4vZHJhd2VyLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgUmVwb0luZm9Db21wb25lbnQgfSBmcm9tIFwiLi9yZXBvLWluZm8uY29tcG9uZW50XCI7XG5pbXBvcnQgeyBIdHRwQ2FjaGUgfSBmcm9tIFwiLi9odHRwLWNhY2hlXCI7XG5pbXBvcnQgeyBOZzJTdG9yYWdlIH0gZnJvbSBcIi4vbmcyLXN0b3JhZ2VcIjtcbmltcG9ydCB7IEFQUF9ST1VURVJfUFJPVklERVJTIH0gZnJvbSAnLi9hcHAucm91dGVzJztcbmltcG9ydCB7R2V0dGluZ1N0YXJ0ZWRDb21wb25lbnR9IGZyb20gXCIuL2dldHRpbmctc3RhcnRlZC5jb21wb25lbnRcIjtcbmltcG9ydCB7QWNjb3JkaW9uQ29tcG9uZW50fSBmcm9tIFwiLi9uZzItdWktY29tcG9uZW50cy9hY2NvcmRpb24uY29tcG9uZW50XCI7XG5pbXBvcnQge0RhdGV0aW1lUGlja2VyQ29tcG9uZW50fSBmcm9tIFwiLi9uZzItdWktY29tcG9uZW50cy9kYXRldGltZS1waWNrZXIuY29tcG9uZW50XCI7XG5pbXBvcnQge0dvb2dsZU1hcENvbXBvbmVudH0gZnJvbSBcIi4vbmcyLXVpLWNvbXBvbmVudHMvZ29vZ2xlLW1hcC5jb21wb25lbnRcIjtcbmltcG9ydCB7SW5maW5pdGVMaXN0Q29tcG9uZW50fSBmcm9tIFwiLi9uZzItdWktY29tcG9uZW50cy9pbmZpbml0ZS1saXN0LmNvbXBvbmVudFwiO1xuaW1wb3J0IHtNZW51Q29tcG9uZW50fSBmcm9tIFwiLi9uZzItdWktY29tcG9uZW50cy9tZW51LmNvbXBvbmVudFwiO1xuaW1wb3J0IHtPdmVybGF5Q29tcG9uZW50fSBmcm9tIFwiLi9uZzItdWktY29tcG9uZW50cy9vdmVybGF5LmNvbXBvbmVudFwiO1xuaW1wb3J0IHtQYXJhbGxheFNjcm9sbENvbXBvbmVudH0gZnJvbSBcIi4vbmcyLXVpLWNvbXBvbmVudHMvcGFyYWxsYXgtc2Nyb2xsLmNvbXBvbmVudFwiO1xuaW1wb3J0IHtQb3B1cENvbXBvbmVudH0gZnJvbSBcIi4vbmcyLXVpLWNvbXBvbmVudHMvcG9wdXAuY29tcG9uZW50XCI7XG5pbXBvcnQge1Njcm9sbGFibGVDb21wb25lbnR9IGZyb20gXCIuL25nMi11aS1jb21wb25lbnRzL3Njcm9sbGFibGUuY29tcG9uZW50XCI7XG5pbXBvcnQge1N0aWNreUNvbXBvbmVudH0gZnJvbSBcIi4vbmcyLXVpLWNvbXBvbmVudHMvc3RpY2t5LmNvbXBvbmVudFwiO1xuaW1wb3J0IHtUYWJDb21wb25lbnR9IGZyb20gXCIuL25nMi11aS1jb21wb25lbnRzL3RhYi5jb21wb25lbnRcIjtcbmltcG9ydCB7VG9vbHRpcENvbXBvbmVudH0gZnJvbSBcIi4vbmcyLXVpLWNvbXBvbmVudHMvdG9vbHRpcC5jb21wb25lbnRcIjtcbmltcG9ydCB7QXV0b0NvbXBsZXRlQ29tcG9uZW50fSBmcm9tIFwiLi9uZzItdWktY29tcG9uZW50cy9hdXRvLWNvbXBsZXRlLmNvbXBvbmVudFwiO1xuaW1wb3J0IHtTb3J0YWJsZUNvbXBvbmVudH0gZnJvbSBcIi4vbmcyLXVpLWNvbXBvbmVudHMvc29ydGFibGUuY29tcG9uZW50XCI7XG5pbXBvcnQge05nMlVJTW9kdWxlfSBmcm9tICduZzItdWknO1xuXG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBCcm93c2VyTW9kdWxlLFxuICAgIEZvcm1zTW9kdWxlLFxuICAgIEh0dHBNb2R1bGUsXG4gICAgTmcyVUlNb2R1bGUsXG4gICAgQVBQX1JPVVRFUl9QUk9WSURFUlNcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbXG4gICAgQXBwQ29tcG9uZW50LFxuICAgIERyYXdlckNvbXBvbmVudCxcbiAgICBSZXBvSW5mb0NvbXBvbmVudCxcbiAgICBHZXR0aW5nU3RhcnRlZENvbXBvbmVudCxcbiAgICBBY2NvcmRpb25Db21wb25lbnQsXG4gICAgQXV0b0NvbXBsZXRlQ29tcG9uZW50LFxuICAgIERhdGV0aW1lUGlja2VyQ29tcG9uZW50LFxuICAgIEdvb2dsZU1hcENvbXBvbmVudCxcbiAgICBJbmZpbml0ZUxpc3RDb21wb25lbnQsXG4gICAgTWVudUNvbXBvbmVudCxcbiAgICBPdmVybGF5Q29tcG9uZW50LFxuICAgIFBhcmFsbGF4U2Nyb2xsQ29tcG9uZW50LFxuICAgIFBvcHVwQ29tcG9uZW50LFxuICAgIFNjcm9sbGFibGVDb21wb25lbnQsXG4gICAgU3RpY2t5Q29tcG9uZW50LFxuICAgIFRhYkNvbXBvbmVudCxcbiAgICBUb29sdGlwQ29tcG9uZW50LFxuICAgIFNvcnRhYmxlQ29tcG9uZW50XG4gIF0sXG4gIHByb3ZpZGVyczogW1xuICAgIEh0dHBDYWNoZSxcbiAgICBOZzJTdG9yYWdlLFxuICAgIHtwcm92aWRlOiBMb2NhdGlvblN0cmF0ZWd5LCB1c2VDbGFzczogSGFzaExvY2F0aW9uU3RyYXRlZ3l9XG4gIF0sXG4gIGJvb3RzdHJhcDogWyBBcHBDb21wb25lbnQgXVxufSlcbmV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL2FwcC5tb2R1bGUudHNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 24:
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * @license Angular v2.0.0\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(1), __webpack_require__(25), __webpack_require__(2), __webpack_require__(3), __webpack_require__(26)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/operator/toPromise', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/observable/fromPromise'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.forms = global.ng.forms || {}),global.ng.core,global.Rx.Observable.prototype,global.Rx,global.Rx,global.Rx.Observable));\n}(this, function (exports,_angular_core,rxjs_operator_toPromise,rxjs_Subject,rxjs_Observable,rxjs_observable_fromPromise) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var globalScope;\n    if (typeof window === 'undefined') {\n        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n            globalScope = self;\n        }\n        else {\n            globalScope = global;\n        }\n    }\n    else {\n        globalScope = window;\n    }\n    // Need to declare a new variable for global here since TypeScript\n    // exports the original value of the symbol.\n    var global$1 = globalScope;\n    // TODO: remove calls to assert in production environment\n    // Note: Can't just export this and import in in other files\n    // as `assert` is a reserved keyword in Dart\n    global$1.assert = function assert(condition) {\n        // TODO: to be fixed properly via #2830, noop for now\n    };\n    function isPresent(obj) {\n        return obj !== undefined && obj !== null;\n    }\n    function isBlank(obj) {\n        return obj === undefined || obj === null;\n    }\n    function isString(obj) {\n        return typeof obj === 'string';\n    }\n    function isFunction(obj) {\n        return typeof obj === 'function';\n    }\n    function isStringMap(obj) {\n        return typeof obj === 'object' && obj !== null;\n    }\n    function isPromise(obj) {\n        // allow any Promise/A+ compliant thenable.\n        // It's up to the caller to ensure that obj.then conforms to the spec\n        return isPresent(obj) && isFunction(obj.then);\n    }\n    function isArray(obj) {\n        return Array.isArray(obj);\n    }\n    var StringWrapper = (function () {\n        function StringWrapper() {\n        }\n        StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };\n        StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };\n        StringWrapper.split = function (s, regExp) { return s.split(regExp); };\n        StringWrapper.equals = function (s, s2) { return s === s2; };\n        StringWrapper.stripLeft = function (s, charVal) {\n            if (s && s.length) {\n                var pos = 0;\n                for (var i = 0; i < s.length; i++) {\n                    if (s[i] != charVal)\n                        break;\n                    pos++;\n                }\n                s = s.substring(pos);\n            }\n            return s;\n        };\n        StringWrapper.stripRight = function (s, charVal) {\n            if (s && s.length) {\n                var pos = s.length;\n                for (var i = s.length - 1; i >= 0; i--) {\n                    if (s[i] != charVal)\n                        break;\n                    pos--;\n                }\n                s = s.substring(0, pos);\n            }\n            return s;\n        };\n        StringWrapper.replace = function (s, from, replace) {\n            return s.replace(from, replace);\n        };\n        StringWrapper.replaceAll = function (s, from, replace) {\n            return s.replace(from, replace);\n        };\n        StringWrapper.slice = function (s, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return s.slice(from, to === null ? undefined : to);\n        };\n        StringWrapper.replaceAllMapped = function (s, from, cb) {\n            return s.replace(from, function () {\n                var matches = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    matches[_i - 0] = arguments[_i];\n                }\n                // Remove offset & string from the result array\n                matches.splice(-2, 2);\n                // The callback receives match, p1, ..., pn\n                return cb(matches);\n            });\n        };\n        StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };\n        StringWrapper.compare = function (a, b) {\n            if (a < b) {\n                return -1;\n            }\n            else if (a > b) {\n                return 1;\n            }\n            else {\n                return 0;\n            }\n        };\n        return StringWrapper;\n    }());\n    var NumberWrapper = (function () {\n        function NumberWrapper() {\n        }\n        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };\n        NumberWrapper.equal = function (a, b) { return a === b; };\n        NumberWrapper.parseIntAutoRadix = function (text) {\n            var result = parseInt(text);\n            if (isNaN(result)) {\n                throw new Error('Invalid integer literal when parsing ' + text);\n            }\n            return result;\n        };\n        NumberWrapper.parseInt = function (text, radix) {\n            if (radix == 10) {\n                if (/^(\\-|\\+)?[0-9]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else if (radix == 16) {\n                if (/^(\\-|\\+)?[0-9ABCDEFabcdef]+$/.test(text)) {\n                    return parseInt(text, radix);\n                }\n            }\n            else {\n                var result = parseInt(text, radix);\n                if (!isNaN(result)) {\n                    return result;\n                }\n            }\n            throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);\n        };\n        Object.defineProperty(NumberWrapper, \"NaN\", {\n            get: function () { return NaN; },\n            enumerable: true,\n            configurable: true\n        });\n        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n        NumberWrapper.isNaN = function (value) { return isNaN(value); };\n        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };\n        return NumberWrapper;\n    }());\n    // JS has NaN !== NaN\n    function looseIdentical(a, b) {\n        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n    }\n    function normalizeBool(obj) {\n        return isBlank(obj) ? false : obj;\n    }\n    function isJsObject(o) {\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\n    }\n    function isPrimitive(obj) {\n        return !isJsObject(obj);\n    }\n    function hasConstructor(value, type) {\n        return value.constructor === type;\n    }\n\n    /**\n     * Base class for control directives.\n     *\n     * Only used internally in the forms module.\n     *\n     * @stable\n     */\n    var AbstractControlDirective = (function () {\n        function AbstractControlDirective() {\n        }\n        Object.defineProperty(AbstractControlDirective.prototype, \"control\", {\n            get: function () { throw new Error('unimplemented'); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"value\", {\n            get: function () { return isPresent(this.control) ? this.control.value : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"valid\", {\n            get: function () { return isPresent(this.control) ? this.control.valid : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"invalid\", {\n            get: function () { return isPresent(this.control) ? this.control.invalid : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"pending\", {\n            get: function () { return isPresent(this.control) ? this.control.pending : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"errors\", {\n            get: function () {\n                return isPresent(this.control) ? this.control.errors : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"pristine\", {\n            get: function () { return isPresent(this.control) ? this.control.pristine : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"dirty\", {\n            get: function () { return isPresent(this.control) ? this.control.dirty : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"touched\", {\n            get: function () { return isPresent(this.control) ? this.control.touched : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"untouched\", {\n            get: function () { return isPresent(this.control) ? this.control.untouched : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"disabled\", {\n            get: function () { return isPresent(this.control) ? this.control.disabled : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"enabled\", {\n            get: function () { return isPresent(this.control) ? this.control.enabled : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"statusChanges\", {\n            get: function () {\n                return isPresent(this.control) ? this.control.statusChanges : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"valueChanges\", {\n            get: function () {\n                return isPresent(this.control) ? this.control.valueChanges : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"path\", {\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        AbstractControlDirective.prototype.reset = function (value) {\n            if (value === void 0) { value = undefined; }\n            if (isPresent(this.control))\n                this.control.reset(value);\n        };\n        return AbstractControlDirective;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * A directive that contains multiple {@link NgControl}s.\n     *\n     * Only used by the forms module.\n     *\n     * @stable\n     */\n    var ControlContainer = (function (_super) {\n        __extends$1(ControlContainer, _super);\n        function ControlContainer() {\n            _super.apply(this, arguments);\n        }\n        Object.defineProperty(ControlContainer.prototype, \"formDirective\", {\n            /**\n             * Get the form to which this container belongs.\n             */\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ControlContainer.prototype, \"path\", {\n            /**\n             * Get the path to this container.\n             */\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        return ControlContainer;\n    }(AbstractControlDirective));\n\n    var Map$1 = global$1.Map;\n    var Set = global$1.Set;\n    // Safari and Internet Explorer do not support the iterable parameter to the\n    // Map constructor.  We work around that by manually adding the items.\n    var createMapFromPairs = (function () {\n        try {\n            if (new Map$1([[1, 2]]).size === 1) {\n                return function createMapFromPairs(pairs) { return new Map$1(pairs); };\n            }\n        }\n        catch (e) {\n        }\n        return function createMapAndPopulateFromPairs(pairs) {\n            var map = new Map$1();\n            for (var i = 0; i < pairs.length; i++) {\n                var pair = pairs[i];\n                map.set(pair[0], pair[1]);\n            }\n            return map;\n        };\n    })();\n    var createMapFromMap = (function () {\n        try {\n            if (new Map$1(new Map$1())) {\n                return function createMapFromMap(m) { return new Map$1(m); };\n            }\n        }\n        catch (e) {\n        }\n        return function createMapAndPopulateFromMap(m) {\n            var map = new Map$1();\n            m.forEach(function (v, k) { map.set(k, v); });\n            return map;\n        };\n    })();\n    var _clearValues = (function () {\n        if ((new Map$1()).keys().next) {\n            return function _clearValues(m) {\n                var keyIterator = m.keys();\n                var k;\n                while (!((k = keyIterator.next()).done)) {\n                    m.set(k.value, null);\n                }\n            };\n        }\n        else {\n            return function _clearValuesWithForeEach(m) {\n                m.forEach(function (v, k) { m.set(k, null); });\n            };\n        }\n    })();\n    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from\n    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from\n    var _arrayFromMap = (function () {\n        try {\n            if ((new Map$1()).values().next) {\n                return function createArrayFromMap(m, getValues) {\n                    return getValues ? Array.from(m.values()) : Array.from(m.keys());\n                };\n            }\n        }\n        catch (e) {\n        }\n        return function createArrayFromMapWithForeach(m, getValues) {\n            var res = ListWrapper.createFixedSize(m.size), i = 0;\n            m.forEach(function (v, k) {\n                res[i] = getValues ? v : k;\n                i++;\n            });\n            return res;\n        };\n    })();\n    var MapWrapper = (function () {\n        function MapWrapper() {\n        }\n        MapWrapper.clone = function (m) { return createMapFromMap(m); };\n        MapWrapper.createFromStringMap = function (stringMap) {\n            var result = new Map$1();\n            for (var prop in stringMap) {\n                result.set(prop, stringMap[prop]);\n            }\n            return result;\n        };\n        MapWrapper.toStringMap = function (m) {\n            var r = {};\n            m.forEach(function (v, k) { return r[k] = v; });\n            return r;\n        };\n        MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };\n        MapWrapper.clearValues = function (m) { _clearValues(m); };\n        MapWrapper.iterable = function (m) { return m; };\n        MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };\n        MapWrapper.values = function (m) { return _arrayFromMap(m, true); };\n        return MapWrapper;\n    }());\n    /**\n     * Wraps Javascript Objects\n     */\n    var StringMapWrapper = (function () {\n        function StringMapWrapper() {\n        }\n        StringMapWrapper.create = function () {\n            // Note: We are not using Object.create(null) here due to\n            // performance!\n            // http://jsperf.com/ng2-object-create-null\n            return {};\n        };\n        StringMapWrapper.contains = function (map, key) {\n            return map.hasOwnProperty(key);\n        };\n        StringMapWrapper.get = function (map, key) {\n            return map.hasOwnProperty(key) ? map[key] : undefined;\n        };\n        StringMapWrapper.set = function (map, key, value) { map[key] = value; };\n        StringMapWrapper.keys = function (map) { return Object.keys(map); };\n        StringMapWrapper.values = function (map) {\n            return Object.keys(map).map(function (k) { return map[k]; });\n        };\n        StringMapWrapper.isEmpty = function (map) {\n            for (var prop in map) {\n                return false;\n            }\n            return true;\n        };\n        StringMapWrapper.delete = function (map, key) { delete map[key]; };\n        StringMapWrapper.forEach = function (map, callback) {\n            for (var _i = 0, _a = Object.keys(map); _i < _a.length; _i++) {\n                var k = _a[_i];\n                callback(map[k], k);\n            }\n        };\n        StringMapWrapper.merge = function (m1, m2) {\n            var m = {};\n            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {\n                var k = _a[_i];\n                m[k] = m1[k];\n            }\n            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {\n                var k = _c[_b];\n                m[k] = m2[k];\n            }\n            return m;\n        };\n        StringMapWrapper.equals = function (m1, m2) {\n            var k1 = Object.keys(m1);\n            var k2 = Object.keys(m2);\n            if (k1.length != k2.length) {\n                return false;\n            }\n            for (var i = 0; i < k1.length; i++) {\n                var key = k1[i];\n                if (m1[key] !== m2[key]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        return StringMapWrapper;\n    }());\n    var ListWrapper = (function () {\n        function ListWrapper() {\n        }\n        // JS has no way to express a statically fixed size list, but dart does so we\n        // keep both methods.\n        ListWrapper.createFixedSize = function (size) { return new Array(size); };\n        ListWrapper.createGrowableSize = function (size) { return new Array(size); };\n        ListWrapper.clone = function (array) { return array.slice(0); };\n        ListWrapper.forEachWithIndex = function (array, fn) {\n            for (var i = 0; i < array.length; i++) {\n                fn(array[i], i);\n            }\n        };\n        ListWrapper.first = function (array) {\n            if (!array)\n                return null;\n            return array[0];\n        };\n        ListWrapper.last = function (array) {\n            if (!array || array.length == 0)\n                return null;\n            return array[array.length - 1];\n        };\n        ListWrapper.indexOf = function (array, value, startIndex) {\n            if (startIndex === void 0) { startIndex = 0; }\n            return array.indexOf(value, startIndex);\n        };\n        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };\n        ListWrapper.reversed = function (array) {\n            var a = ListWrapper.clone(array);\n            return a.reverse();\n        };\n        ListWrapper.concat = function (a, b) { return a.concat(b); };\n        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };\n        ListWrapper.removeAt = function (list, index) {\n            var res = list[index];\n            list.splice(index, 1);\n            return res;\n        };\n        ListWrapper.removeAll = function (list, items) {\n            for (var i = 0; i < items.length; ++i) {\n                var index = list.indexOf(items[i]);\n                list.splice(index, 1);\n            }\n        };\n        ListWrapper.remove = function (list, el) {\n            var index = list.indexOf(el);\n            if (index > -1) {\n                list.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        ListWrapper.clear = function (list) { list.length = 0; };\n        ListWrapper.isEmpty = function (list) { return list.length == 0; };\n        ListWrapper.fill = function (list, value, start, end) {\n            if (start === void 0) { start = 0; }\n            if (end === void 0) { end = null; }\n            list.fill(value, start, end === null ? list.length : end);\n        };\n        ListWrapper.equals = function (a, b) {\n            if (a.length != b.length)\n                return false;\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        };\n        ListWrapper.slice = function (l, from, to) {\n            if (from === void 0) { from = 0; }\n            if (to === void 0) { to = null; }\n            return l.slice(from, to === null ? undefined : to);\n        };\n        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };\n        ListWrapper.sort = function (l, compareFn) {\n            if (isPresent(compareFn)) {\n                l.sort(compareFn);\n            }\n            else {\n                l.sort();\n            }\n        };\n        ListWrapper.toString = function (l) { return l.toString(); };\n        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };\n        ListWrapper.maximum = function (list, predicate) {\n            if (list.length == 0) {\n                return null;\n            }\n            var solution = null;\n            var maxValue = -Infinity;\n            for (var index = 0; index < list.length; index++) {\n                var candidate = list[index];\n                if (isBlank(candidate)) {\n                    continue;\n                }\n                var candidateValue = predicate(candidate);\n                if (candidateValue > maxValue) {\n                    solution = candidate;\n                    maxValue = candidateValue;\n                }\n            }\n            return solution;\n        };\n        ListWrapper.flatten = function (list) {\n            var target = [];\n            _flattenArray(list, target);\n            return target;\n        };\n        ListWrapper.addAll = function (list, source) {\n            for (var i = 0; i < source.length; i++) {\n                list.push(source[i]);\n            }\n        };\n        return ListWrapper;\n    }());\n    function _flattenArray(source, target) {\n        if (isPresent(source)) {\n            for (var i = 0; i < source.length; i++) {\n                var item = source[i];\n                if (isArray(item)) {\n                    _flattenArray(item, target);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n        }\n        return target;\n    }\n    // Safari and Internet Explorer do not support the iterable parameter to the\n    // Set constructor.  We work around that by manually adding the items.\n    var createSetFromList = (function () {\n        var test = new Set([1, 2, 3]);\n        if (test.size === 3) {\n            return function createSetFromList(lst) { return new Set(lst); };\n        }\n        else {\n            return function createSetAndPopulateFromList(lst) {\n                var res = new Set(lst);\n                if (res.size !== lst.length) {\n                    for (var i = 0; i < lst.length; i++) {\n                        res.add(lst[i]);\n                    }\n                }\n                return res;\n            };\n        }\n    })();\n\n    /**\n     * Providers for validators to be used for {@link FormControl}s in a form.\n     *\n     * Provide this using `multi: true` to add validators.\n     *\n     * ### Example\n     *\n     * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}\n     * @stable\n     */\n    var NG_VALIDATORS = new _angular_core.OpaqueToken('NgValidators');\n    /**\n     * Providers for asynchronous validators to be used for {@link FormControl}s\n     * in a form.\n     *\n     * Provide this using `multi: true` to add validators.\n     *\n     * See {@link NG_VALIDATORS} for more details.\n     *\n     * @stable\n     */\n    var NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken('NgAsyncValidators');\n    /**\n     * Provides a set of validators used by form controls.\n     *\n     * A validator is a function that processes a {@link FormControl} or collection of\n     * controls and returns a map of errors. A null map means that validation has passed.\n     *\n     * ### Example\n     *\n     * ```typescript\n     * var loginControl = new FormControl(\"\", Validators.required)\n     * ```\n     *\n     * @stable\n     */\n    var Validators = (function () {\n        function Validators() {\n        }\n        /**\n         * Validator that requires controls to have a non-empty value.\n         */\n        Validators.required = function (control) {\n            return isBlank(control.value) || (isString(control.value) && control.value == '') ?\n                { 'required': true } :\n                null;\n        };\n        /**\n         * Validator that requires controls to have a value of a minimum length.\n         */\n        Validators.minLength = function (minLength) {\n            return function (control) {\n                if (isPresent(Validators.required(control)))\n                    return null;\n                var v = control.value;\n                return v.length < minLength ?\n                    { 'minlength': { 'requiredLength': minLength, 'actualLength': v.length } } :\n                    null;\n            };\n        };\n        /**\n         * Validator that requires controls to have a value of a maximum length.\n         */\n        Validators.maxLength = function (maxLength) {\n            return function (control) {\n                if (isPresent(Validators.required(control)))\n                    return null;\n                var v = control.value;\n                return v.length > maxLength ?\n                    { 'maxlength': { 'requiredLength': maxLength, 'actualLength': v.length } } :\n                    null;\n            };\n        };\n        /**\n         * Validator that requires a control to match a regex to its value.\n         */\n        Validators.pattern = function (pattern) {\n            return function (control) {\n                if (isPresent(Validators.required(control)))\n                    return null;\n                var regex = new RegExp(\"^\" + pattern + \"$\");\n                var v = control.value;\n                return regex.test(v) ? null :\n                    { 'pattern': { 'requiredPattern': \"^\" + pattern + \"$\", 'actualValue': v } };\n            };\n        };\n        /**\n         * No-op validator.\n         */\n        Validators.nullValidator = function (c) { return null; };\n        /**\n         * Compose multiple validators into a single function that returns the union\n         * of the individual error maps.\n         */\n        Validators.compose = function (validators) {\n            if (isBlank(validators))\n                return null;\n            var presentValidators = validators.filter(isPresent);\n            if (presentValidators.length == 0)\n                return null;\n            return function (control) {\n                return _mergeErrors(_executeValidators(control, presentValidators));\n            };\n        };\n        Validators.composeAsync = function (validators) {\n            if (isBlank(validators))\n                return null;\n            var presentValidators = validators.filter(isPresent);\n            if (presentValidators.length == 0)\n                return null;\n            return function (control) {\n                var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);\n                return Promise.all(promises).then(_mergeErrors);\n            };\n        };\n        return Validators;\n    }());\n    function _convertToPromise(obj) {\n        return isPromise(obj) ? obj : rxjs_operator_toPromise.toPromise.call(obj);\n    }\n    function _executeValidators(control, validators) {\n        return validators.map(function (v) { return v(control); });\n    }\n    function _executeAsyncValidators(control, validators) {\n        return validators.map(function (v) { return v(control); });\n    }\n    function _mergeErrors(arrayOfErrors) {\n        var res = arrayOfErrors.reduce(function (res, errors) {\n            return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;\n        }, {});\n        return StringMapWrapper.isEmpty(res) ? null : res;\n    }\n\n    /**\n     * Used to provide a {@link ControlValueAccessor} for form controls.\n     *\n     * See {@link DefaultValueAccessor} for how to implement one.\n     * @stable\n     */\n    var NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken('NgValueAccessor');\n\n    var CHECKBOX_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return CheckboxControlValueAccessor; }),\n        multi: true\n    };\n    /**\n     * The accessor for writing a value and listening to changes on a checkbox input element.\n     *\n     *  ### Example\n     *  ```\n     *  <input type=\"checkbox\" name=\"rememberLogin\" ngModel>\n     *  ```\n     *\n     *  @stable\n     */\n    var CheckboxControlValueAccessor = (function () {\n        function CheckboxControlValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        CheckboxControlValueAccessor.prototype.writeValue = function (value) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);\n        };\n        CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };\n        CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        CheckboxControlValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        CheckboxControlValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',\n                        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },\n                        providers: [CHECKBOX_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        CheckboxControlValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return CheckboxControlValueAccessor;\n    }());\n\n    var DEFAULT_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return DefaultValueAccessor; }),\n        multi: true\n    };\n    /**\n     * The default accessor for writing a value and listening to changes that is used by the\n     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.\n     *\n     *  ### Example\n     *  ```\n     *  <input type=\"text\" name=\"searchQuery\" ngModel>\n     *  ```\n     *\n     *  @stable\n     */\n    var DefaultValueAccessor = (function () {\n        function DefaultValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        DefaultValueAccessor.prototype.writeValue = function (value) {\n            var normalizedValue = isBlank(value) ? '' : value;\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);\n        };\n        DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };\n        DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        DefaultValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        DefaultValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',\n                        // TODO: vsavkin replace the above selector with the one below it once\n                        // https://github.com/angular/angular/issues/3011 is implemented\n                        // selector: '[ngControl],[ngModel],[ngFormControl]',\n                        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },\n                        providers: [DEFAULT_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        DefaultValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return DefaultValueAccessor;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function normalizeValidator(validator) {\n        if (validator.validate !== undefined) {\n            return function (c) { return validator.validate(c); };\n        }\n        else {\n            return validator;\n        }\n    }\n    function normalizeAsyncValidator(validator) {\n        if (validator.validate !== undefined) {\n            return function (c) { return validator.validate(c); };\n        }\n        else {\n            return validator;\n        }\n    }\n\n    var NUMBER_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return NumberValueAccessor; }),\n        multi: true\n    };\n    /**\n     * The accessor for writing a number value and listening to changes that is used by the\n     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.\n     *\n     *  ### Example\n     *  ```\n     *  <input type=\"number\" [(ngModel)]=\"age\">\n     *  ```\n     */\n    var NumberValueAccessor = (function () {\n        function NumberValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        NumberValueAccessor.prototype.writeValue = function (value) {\n            // The value needs to be normalized for IE9, otherwise it is set to 'null' when null\n            var normalizedValue = isBlank(value) ? '' : value;\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);\n        };\n        NumberValueAccessor.prototype.registerOnChange = function (fn) {\n            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };\n        };\n        NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        NumberValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        NumberValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',\n                        host: {\n                            '(change)': 'onChange($event.target.value)',\n                            '(input)': 'onChange($event.target.value)',\n                            '(blur)': 'onTouched()'\n                        },\n                        providers: [NUMBER_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        NumberValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return NumberValueAccessor;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    function unimplemented() {\n        throw new Error('unimplemented');\n    }\n    /**\n     * A base class that all control directive extend.\n     * It binds a {@link FormControl} object to a DOM element.\n     *\n     * Used internally by Angular forms.\n     *\n     * @stable\n     */\n    var NgControl = (function (_super) {\n        __extends$2(NgControl, _super);\n        function NgControl() {\n            _super.apply(this, arguments);\n            /** @internal */\n            this._parent = null;\n            this.name = null;\n            this.valueAccessor = null;\n            /** @internal */\n            this._rawValidators = [];\n            /** @internal */\n            this._rawAsyncValidators = [];\n        }\n        Object.defineProperty(NgControl.prototype, \"validator\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgControl.prototype, \"asyncValidator\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return NgControl;\n    }(AbstractControlDirective));\n\n    var RADIO_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return RadioControlValueAccessor; }),\n        multi: true\n    };\n    /**\n     * Internal class used by Angular to uncheck radio buttons with the matching name.\n     */\n    var RadioControlRegistry = (function () {\n        function RadioControlRegistry() {\n            this._accessors = [];\n        }\n        RadioControlRegistry.prototype.add = function (control, accessor) {\n            this._accessors.push([control, accessor]);\n        };\n        RadioControlRegistry.prototype.remove = function (accessor) {\n            var indexToRemove = -1;\n            for (var i = 0; i < this._accessors.length; ++i) {\n                if (this._accessors[i][1] === accessor) {\n                    indexToRemove = i;\n                }\n            }\n            ListWrapper.removeAt(this._accessors, indexToRemove);\n        };\n        RadioControlRegistry.prototype.select = function (accessor) {\n            var _this = this;\n            this._accessors.forEach(function (c) {\n                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {\n                    c[1].fireUncheck(accessor.value);\n                }\n            });\n        };\n        RadioControlRegistry.prototype._isSameGroup = function (controlPair, accessor) {\n            if (!controlPair[0].control)\n                return false;\n            return controlPair[0]._parent === accessor._control._parent &&\n                controlPair[1].name === accessor.name;\n        };\n        RadioControlRegistry.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        RadioControlRegistry.ctorParameters = [];\n        return RadioControlRegistry;\n    }());\n    /**\n     * The accessor for writing a radio control value and listening to changes that is used by the\n     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.\n     *\n     *  ### Example\n     *  ```\n     *  @Component({\n     *    template: `\n     *      <input type=\"radio\" name=\"food\" [(ngModel)]=\"food\" value=\"chicken\">\n     *      <input type=\"radio\" name=\"food\" [(ngModel)]=\"food\" value=\"fish\">\n     *    `\n     *  })\n     *  class FoodCmp {\n     *    food = 'chicken';\n     *  }\n     *  ```\n     */\n    var RadioControlValueAccessor = (function () {\n        function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            this._registry = _registry;\n            this._injector = _injector;\n            this.onChange = function () { };\n            this.onTouched = function () { };\n        }\n        RadioControlValueAccessor.prototype.ngOnInit = function () {\n            this._control = this._injector.get(NgControl);\n            this._checkName();\n            this._registry.add(this._control, this);\n        };\n        RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };\n        RadioControlValueAccessor.prototype.writeValue = function (value) {\n            this._state = value === this.value;\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);\n        };\n        RadioControlValueAccessor.prototype.registerOnChange = function (fn) {\n            var _this = this;\n            this._fn = fn;\n            this.onChange = function () {\n                fn(_this.value);\n                _this._registry.select(_this);\n            };\n        };\n        RadioControlValueAccessor.prototype.fireUncheck = function (value) { this.writeValue(value); };\n        RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        RadioControlValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        RadioControlValueAccessor.prototype._checkName = function () {\n            if (this.name && this.formControlName && this.name !== this.formControlName) {\n                this._throwNameError();\n            }\n            if (!this.name && this.formControlName)\n                this.name = this.formControlName;\n        };\n        RadioControlValueAccessor.prototype._throwNameError = function () {\n            throw new Error(\"\\n      If you define both a name and a formControlName attribute on your radio button, their values\\n      must match. Ex: <input type=\\\"radio\\\" formControlName=\\\"food\\\" name=\\\"food\\\">\\n    \");\n        };\n        RadioControlValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',\n                        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },\n                        providers: [RADIO_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        RadioControlValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n            { type: RadioControlRegistry, },\n            { type: _angular_core.Injector, },\n        ];\n        RadioControlValueAccessor.propDecorators = {\n            'name': [{ type: _angular_core.Input },],\n            'formControlName': [{ type: _angular_core.Input },],\n            'value': [{ type: _angular_core.Input },],\n        };\n        return RadioControlValueAccessor;\n    }());\n\n    var SELECT_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return SelectControlValueAccessor; }),\n        multi: true\n    };\n    function _buildValueString(id, value) {\n        if (isBlank(id))\n            return \"\" + value;\n        if (!isPrimitive(value))\n            value = 'Object';\n        return StringWrapper.slice(id + \": \" + value, 0, 50);\n    }\n    function _extractId(valueString) {\n        return valueString.split(':')[0];\n    }\n    /**\n     * The accessor for writing a value and listening to changes on a select element.\n     *\n     * Note: We have to listen to the 'change' event because 'input' events aren't fired\n     * for selects in Firefox and IE:\n     * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350\n     * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/\n     *\n     * @stable\n     */\n    var SelectControlValueAccessor = (function () {\n        function SelectControlValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            /** @internal */\n            this._optionMap = new Map();\n            /** @internal */\n            this._idCounter = 0;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        SelectControlValueAccessor.prototype.writeValue = function (value) {\n            this.value = value;\n            var valueString = _buildValueString(this._getOptionId(value), value);\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);\n        };\n        SelectControlValueAccessor.prototype.registerOnChange = function (fn) {\n            var _this = this;\n            this.onChange = function (valueString) {\n                _this.value = valueString;\n                fn(_this._getOptionValue(valueString));\n            };\n        };\n        SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        SelectControlValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        /** @internal */\n        SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };\n        /** @internal */\n        SelectControlValueAccessor.prototype._getOptionId = function (value) {\n            for (var _i = 0, _a = MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {\n                var id = _a[_i];\n                if (looseIdentical(this._optionMap.get(id), value))\n                    return id;\n            }\n            return null;\n        };\n        /** @internal */\n        SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {\n            var value = this._optionMap.get(_extractId(valueString));\n            return isPresent(value) ? value : valueString;\n        };\n        SelectControlValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',\n                        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },\n                        providers: [SELECT_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        SelectControlValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return SelectControlValueAccessor;\n    }());\n    /**\n     * Marks `<option>` as dynamic, so Angular can be notified when options change.\n     *\n     * ### Example\n     *\n     * ```\n     * <select name=\"city\" ngModel>\n     *   <option *ngFor=\"let c of cities\" [value]=\"c\"></option>\n     * </select>\n     * ```\n     *\n     * @stable\n     */\n    var NgSelectOption = (function () {\n        function NgSelectOption(_element, _renderer, _select) {\n            this._element = _element;\n            this._renderer = _renderer;\n            this._select = _select;\n            if (isPresent(this._select))\n                this.id = this._select._registerOption();\n        }\n        Object.defineProperty(NgSelectOption.prototype, \"ngValue\", {\n            set: function (value) {\n                if (this._select == null)\n                    return;\n                this._select._optionMap.set(this.id, value);\n                this._setElementValue(_buildValueString(this.id, value));\n                this._select.writeValue(this._select.value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgSelectOption.prototype, \"value\", {\n            set: function (value) {\n                this._setElementValue(value);\n                if (isPresent(this._select))\n                    this._select.writeValue(this._select.value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        NgSelectOption.prototype._setElementValue = function (value) {\n            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);\n        };\n        NgSelectOption.prototype.ngOnDestroy = function () {\n            if (isPresent(this._select)) {\n                this._select._optionMap.delete(this.id);\n                this._select.writeValue(this._select.value);\n            }\n        };\n        NgSelectOption.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: 'option' },] },\n        ];\n        /** @nocollapse */\n        NgSelectOption.ctorParameters = [\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n            { type: SelectControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },\n        ];\n        NgSelectOption.propDecorators = {\n            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],\n            'value': [{ type: _angular_core.Input, args: ['value',] },],\n        };\n        return NgSelectOption;\n    }());\n\n    var SELECT_MULTIPLE_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return SelectMultipleControlValueAccessor; }),\n        multi: true\n    };\n    function _buildValueString$1(id, value) {\n        if (isBlank(id))\n            return \"\" + value;\n        if (isString(value))\n            value = \"'\" + value + \"'\";\n        if (!isPrimitive(value))\n            value = 'Object';\n        return StringWrapper.slice(id + \": \" + value, 0, 50);\n    }\n    function _extractId$1(valueString) {\n        return valueString.split(':')[0];\n    }\n    /**\n     * The accessor for writing a value and listening to changes on a select element.\n     *\n     * @stable\n     */\n    var SelectMultipleControlValueAccessor = (function () {\n        function SelectMultipleControlValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            /** @internal */\n            this._optionMap = new Map();\n            /** @internal */\n            this._idCounter = 0;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {\n            var _this = this;\n            this.value = value;\n            if (value == null)\n                return;\n            var values = value;\n            // convert values to ids\n            var ids = values.map(function (v) { return _this._getOptionId(v); });\n            this._optionMap.forEach(function (opt, o) { opt._setSelected(ids.indexOf(o.toString()) > -1); });\n        };\n        SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {\n            var _this = this;\n            this.onChange = function (_) {\n                var selected = [];\n                if (_.hasOwnProperty('selectedOptions')) {\n                    var options = _.selectedOptions;\n                    for (var i = 0; i < options.length; i++) {\n                        var opt = options.item(i);\n                        var val = _this._getOptionValue(opt.value);\n                        selected.push(val);\n                    }\n                }\n                else {\n                    var options = _.options;\n                    for (var i = 0; i < options.length; i++) {\n                        var opt = options.item(i);\n                        if (opt.selected) {\n                            var val = _this._getOptionValue(opt.value);\n                            selected.push(val);\n                        }\n                    }\n                }\n                fn(selected);\n            };\n        };\n        SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        SelectMultipleControlValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        /** @internal */\n        SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {\n            var id = (this._idCounter++).toString();\n            this._optionMap.set(id, value);\n            return id;\n        };\n        /** @internal */\n        SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {\n            for (var _i = 0, _a = MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {\n                var id = _a[_i];\n                if (looseIdentical(this._optionMap.get(id)._value, value))\n                    return id;\n            }\n            return null;\n        };\n        /** @internal */\n        SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {\n            var opt = this._optionMap.get(_extractId$1(valueString));\n            return isPresent(opt) ? opt._value : valueString;\n        };\n        SelectMultipleControlValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',\n                        host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },\n                        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        SelectMultipleControlValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return SelectMultipleControlValueAccessor;\n    }());\n    /**\n     * Marks `<option>` as dynamic, so Angular can be notified when options change.\n     *\n     * ### Example\n     *\n     * ```\n     * <select multiple name=\"city\" ngModel>\n     *   <option *ngFor=\"let c of cities\" [value]=\"c\"></option>\n     * </select>\n     * ```\n     */\n    var NgSelectMultipleOption = (function () {\n        function NgSelectMultipleOption(_element, _renderer, _select) {\n            this._element = _element;\n            this._renderer = _renderer;\n            this._select = _select;\n            if (isPresent(this._select)) {\n                this.id = this._select._registerOption(this);\n            }\n        }\n        Object.defineProperty(NgSelectMultipleOption.prototype, \"ngValue\", {\n            set: function (value) {\n                if (this._select == null)\n                    return;\n                this._value = value;\n                this._setElementValue(_buildValueString$1(this.id, value));\n                this._select.writeValue(this._select.value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgSelectMultipleOption.prototype, \"value\", {\n            set: function (value) {\n                if (isPresent(this._select)) {\n                    this._value = value;\n                    this._setElementValue(_buildValueString$1(this.id, value));\n                    this._select.writeValue(this._select.value);\n                }\n                else {\n                    this._setElementValue(value);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        NgSelectMultipleOption.prototype._setElementValue = function (value) {\n            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);\n        };\n        /** @internal */\n        NgSelectMultipleOption.prototype._setSelected = function (selected) {\n            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);\n        };\n        NgSelectMultipleOption.prototype.ngOnDestroy = function () {\n            if (isPresent(this._select)) {\n                this._select._optionMap.delete(this.id);\n                this._select.writeValue(this._select.value);\n            }\n        };\n        NgSelectMultipleOption.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: 'option' },] },\n        ];\n        /** @nocollapse */\n        NgSelectMultipleOption.ctorParameters = [\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n            { type: SelectMultipleControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },\n        ];\n        NgSelectMultipleOption.propDecorators = {\n            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],\n            'value': [{ type: _angular_core.Input, args: ['value',] },],\n        };\n        return NgSelectMultipleOption;\n    }());\n\n    function controlPath(name, parent) {\n        var p = ListWrapper.clone(parent.path);\n        p.push(name);\n        return p;\n    }\n    function setUpControl(control, dir) {\n        if (isBlank(control))\n            _throwError(dir, 'Cannot find control with');\n        if (isBlank(dir.valueAccessor))\n            _throwError(dir, 'No value accessor for form control with');\n        control.validator = Validators.compose([control.validator, dir.validator]);\n        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);\n        dir.valueAccessor.writeValue(control.value);\n        // view -> model\n        dir.valueAccessor.registerOnChange(function (newValue) {\n            dir.viewToModelUpdate(newValue);\n            control.markAsDirty();\n            control.setValue(newValue, { emitModelToViewChange: false });\n        });\n        // touched\n        dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });\n        control.registerOnChange(function (newValue, emitModelEvent) {\n            // control -> view\n            dir.valueAccessor.writeValue(newValue);\n            // control -> ngModel\n            if (emitModelEvent)\n                dir.viewToModelUpdate(newValue);\n        });\n        if (dir.valueAccessor.setDisabledState) {\n            control.registerOnDisabledChange(function (isDisabled) { dir.valueAccessor.setDisabledState(isDisabled); });\n        }\n        // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n        dir._rawValidators.forEach(function (validator) {\n            if (validator.registerOnValidatorChange)\n                validator.registerOnValidatorChange(function () { return control.updateValueAndValidity(); });\n        });\n        dir._rawAsyncValidators.forEach(function (validator) {\n            if (validator.registerOnValidatorChange)\n                validator.registerOnValidatorChange(function () { return control.updateValueAndValidity(); });\n        });\n    }\n    function cleanUpControl(control, dir) {\n        dir.valueAccessor.registerOnChange(function () { return _noControlError(dir); });\n        dir.valueAccessor.registerOnTouched(function () { return _noControlError(dir); });\n        dir._rawValidators.forEach(function (validator) { return validator.registerOnValidatorChange(null); });\n        dir._rawAsyncValidators.forEach(function (validator) { return validator.registerOnValidatorChange(null); });\n        if (control)\n            control._clearChangeFns();\n    }\n    function setUpFormContainer(control, dir) {\n        if (isBlank(control))\n            _throwError(dir, 'Cannot find control with');\n        control.validator = Validators.compose([control.validator, dir.validator]);\n        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);\n    }\n    function _noControlError(dir) {\n        return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n    }\n    function _throwError(dir, message) {\n        var messageEnd;\n        if (dir.path.length > 1) {\n            messageEnd = \"path: '\" + dir.path.join(' -> ') + \"'\";\n        }\n        else if (dir.path[0]) {\n            messageEnd = \"name: '\" + dir.path + \"'\";\n        }\n        else {\n            messageEnd = 'unspecified name attribute';\n        }\n        throw new Error(message + \" \" + messageEnd);\n    }\n    function composeValidators(validators) {\n        return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;\n    }\n    function composeAsyncValidators(validators) {\n        return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) :\n            null;\n    }\n    function isPropertyUpdated(changes, viewModel) {\n        if (!StringMapWrapper.contains(changes, 'model'))\n            return false;\n        var change = changes['model'];\n        if (change.isFirstChange())\n            return true;\n        return !looseIdentical(viewModel, change.currentValue);\n    }\n    function isBuiltInAccessor(valueAccessor) {\n        return (hasConstructor(valueAccessor, CheckboxControlValueAccessor) ||\n            hasConstructor(valueAccessor, NumberValueAccessor) ||\n            hasConstructor(valueAccessor, SelectControlValueAccessor) ||\n            hasConstructor(valueAccessor, SelectMultipleControlValueAccessor) ||\n            hasConstructor(valueAccessor, RadioControlValueAccessor));\n    }\n    // TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\n    function selectValueAccessor(dir, valueAccessors) {\n        if (isBlank(valueAccessors))\n            return null;\n        var defaultAccessor;\n        var builtinAccessor;\n        var customAccessor;\n        valueAccessors.forEach(function (v) {\n            if (hasConstructor(v, DefaultValueAccessor)) {\n                defaultAccessor = v;\n            }\n            else if (isBuiltInAccessor(v)) {\n                if (isPresent(builtinAccessor))\n                    _throwError(dir, 'More than one built-in value accessor matches form control with');\n                builtinAccessor = v;\n            }\n            else {\n                if (isPresent(customAccessor))\n                    _throwError(dir, 'More than one custom value accessor matches form control with');\n                customAccessor = v;\n            }\n        });\n        if (isPresent(customAccessor))\n            return customAccessor;\n        if (isPresent(builtinAccessor))\n            return builtinAccessor;\n        if (isPresent(defaultAccessor))\n            return defaultAccessor;\n        _throwError(dir, 'No valid value accessor for form control with');\n        return null;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * This is a base class for code shared between {@link NgModelGroup} and {@link FormGroupName}.\n     *\n     * @stable\n     */\n    var AbstractFormGroupDirective = (function (_super) {\n        __extends(AbstractFormGroupDirective, _super);\n        function AbstractFormGroupDirective() {\n            _super.apply(this, arguments);\n        }\n        AbstractFormGroupDirective.prototype.ngOnInit = function () {\n            this._checkParentType();\n            this.formDirective.addFormGroup(this);\n        };\n        AbstractFormGroupDirective.prototype.ngOnDestroy = function () {\n            if (this.formDirective) {\n                this.formDirective.removeFormGroup(this);\n            }\n        };\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"control\", {\n            /**\n             * Get the {@link FormGroup} backing this binding.\n             */\n            get: function () { return this.formDirective.getFormGroup(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"path\", {\n            /**\n             * Get the path to this control group.\n             */\n            get: function () { return controlPath(this.name, this._parent); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"formDirective\", {\n            /**\n             * Get the {@link Form} to which this group belongs.\n             */\n            get: function () { return this._parent ? this._parent.formDirective : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"validator\", {\n            get: function () { return composeValidators(this._validators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"asyncValidator\", {\n            get: function () { return composeAsyncValidators(this._asyncValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        AbstractFormGroupDirective.prototype._checkParentType = function () { };\n        return AbstractFormGroupDirective;\n    }(ControlContainer));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var AbstractControlStatus = (function () {\n        function AbstractControlStatus(cd) {\n            this._cd = cd;\n        }\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassUntouched\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.untouched : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassTouched\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.touched : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassPristine\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.pristine : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassDirty\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.dirty : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassValid\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.valid : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassInvalid\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.invalid : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return AbstractControlStatus;\n    }());\n    var ngControlStatusHost = {\n        '[class.ng-untouched]': 'ngClassUntouched',\n        '[class.ng-touched]': 'ngClassTouched',\n        '[class.ng-pristine]': 'ngClassPristine',\n        '[class.ng-dirty]': 'ngClassDirty',\n        '[class.ng-valid]': 'ngClassValid',\n        '[class.ng-invalid]': 'ngClassInvalid'\n    };\n    /**\n     * Directive automatically applied to Angular form controls that sets CSS classes\n     * based on control status (valid/invalid/dirty/etc).\n     *\n     * @stable\n     */\n    var NgControlStatus = (function (_super) {\n        __extends$3(NgControlStatus, _super);\n        function NgControlStatus(cd) {\n            _super.call(this, cd);\n        }\n        NgControlStatus.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost },] },\n        ];\n        /** @nocollapse */\n        NgControlStatus.ctorParameters = [\n            { type: NgControl, decorators: [{ type: _angular_core.Self },] },\n        ];\n        return NgControlStatus;\n    }(AbstractControlStatus));\n    /**\n     * Directive automatically applied to Angular form groups that sets CSS classes\n     * based on control status (valid/invalid/dirty/etc).\n     *\n     * @stable\n     */\n    var NgControlStatusGroup = (function (_super) {\n        __extends$3(NgControlStatusGroup, _super);\n        function NgControlStatusGroup(cd) {\n            _super.call(this, cd);\n        }\n        NgControlStatusGroup.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',\n                        host: ngControlStatusHost\n                    },] },\n        ];\n        /** @nocollapse */\n        NgControlStatusGroup.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Self },] },\n        ];\n        return NgControlStatusGroup;\n    }(AbstractControlStatus));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$5 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Use by directives and components to emit custom Events.\n     *\n     * ### Examples\n     *\n     * In the following example, `Zippy` alternatively emits `open` and `close` events when its\n     * title gets clicked:\n     *\n     * ```\n     * @Component({\n     *   selector: 'zippy',\n     *   template: `\n     *   <div class=\"zippy\">\n     *     <div (click)=\"toggle()\">Toggle</div>\n     *     <div [hidden]=\"!visible\">\n     *       <ng-content></ng-content>\n     *     </div>\n     *  </div>`})\n     * export class Zippy {\n     *   visible: boolean = true;\n     *   @Output() open: EventEmitter<any> = new EventEmitter();\n     *   @Output() close: EventEmitter<any> = new EventEmitter();\n     *\n     *   toggle() {\n     *     this.visible = !this.visible;\n     *     if (this.visible) {\n     *       this.open.emit(null);\n     *     } else {\n     *       this.close.emit(null);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * The events payload can be accessed by the parameter `$event` on the components output event\n     * handler:\n     *\n     * ```\n     * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n     * ```\n     *\n     * Uses Rx.Observable but provides an adapter to make it work as specified here:\n     * https://github.com/jhusain/observable-spec\n     *\n     * Once a reference implementation of the spec is available, switch to it.\n     * @stable\n     */\n    var EventEmitter = (function (_super) {\n        __extends$5(EventEmitter, _super);\n        /**\n         * Creates an instance of [EventEmitter], which depending on [isAsync],\n         * delivers events synchronously or asynchronously.\n         */\n        function EventEmitter(isAsync) {\n            if (isAsync === void 0) { isAsync = false; }\n            _super.call(this);\n            this.__isAsync = isAsync;\n        }\n        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };\n        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {\n            var schedulerFn;\n            var errorFn = function (err) { return null; };\n            var completeFn = function () { return null; };\n            if (generatorOrNext && typeof generatorOrNext === 'object') {\n                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {\n                    setTimeout(function () { return generatorOrNext.next(value); });\n                } : function (value /** TODO #9100 */) { generatorOrNext.next(value); };\n                if (generatorOrNext.error) {\n                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :\n                        function (err) { generatorOrNext.error(err); };\n                }\n                if (generatorOrNext.complete) {\n                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :\n                        function () { generatorOrNext.complete(); };\n                }\n            }\n            else {\n                schedulerFn = this.__isAsync ? function (value /** TODO #9100 */) {\n                    setTimeout(function () { return generatorOrNext(value); });\n                } : function (value /** TODO #9100 */) { generatorOrNext(value); };\n                if (error) {\n                    errorFn =\n                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };\n                }\n                if (complete) {\n                    completeFn =\n                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };\n                }\n            }\n            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);\n        };\n        return EventEmitter;\n    }(rxjs_Subject.Subject));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$6 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.\n     */\n    var VALID = 'VALID';\n    /**\n     * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.\n     */\n    var INVALID = 'INVALID';\n    /**\n     * Indicates that a FormControl is pending, i.e. that async validation is occurring and\n     * errors are not yet available for the input value.\n     */\n    var PENDING = 'PENDING';\n    /**\n     * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor\n     * calculations of validity or value.\n     */\n    var DISABLED = 'DISABLED';\n    function _find(control, path, delimiter) {\n        if (isBlank(path))\n            return null;\n        if (!(path instanceof Array)) {\n            path = path.split(delimiter);\n        }\n        if (path instanceof Array && ListWrapper.isEmpty(path))\n            return null;\n        return path.reduce(function (v, name) {\n            if (v instanceof FormGroup) {\n                return isPresent(v.controls[name]) ? v.controls[name] : null;\n            }\n            else if (v instanceof FormArray) {\n                var index = name;\n                return isPresent(v.at(index)) ? v.at(index) : null;\n            }\n            else {\n                return null;\n            }\n        }, control);\n    }\n    function toObservable(r) {\n        return isPromise(r) ? rxjs_observable_fromPromise.fromPromise(r) : r;\n    }\n    function coerceToValidator(validator) {\n        return Array.isArray(validator) ? composeValidators(validator) : validator;\n    }\n    function coerceToAsyncValidator(asyncValidator) {\n        return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;\n    }\n    /**\n     * @whatItDoes This is the base class for {@link FormControl}, {@link FormGroup}, and\n     * {@link FormArray}.\n     *\n     * It provides some of the shared behavior that all controls and groups of controls have, like\n     * running validators, calculating status, and resetting state. It also defines the properties\n     * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n     * instantiated directly.\n     *\n     * @stable\n     */\n    var AbstractControl = (function () {\n        function AbstractControl(validator, asyncValidator) {\n            this.validator = validator;\n            this.asyncValidator = asyncValidator;\n            /** @internal */\n            this._onCollectionChange = function () { };\n            this._pristine = true;\n            this._touched = false;\n        }\n        Object.defineProperty(AbstractControl.prototype, \"value\", {\n            /**\n             * The value of the control.\n             */\n            get: function () { return this._value; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"status\", {\n            /**\n             * The validation status of the control. There are four possible\n             * validation statuses:\n             *\n             * * **VALID**:  control has passed all validation checks\n             * * **INVALID**: control has failed at least one validation check\n             * * **PENDING**: control is in the midst of conducting a validation check\n             * * **DISABLED**: control is exempt from validation checks\n             *\n             * These statuses are mutually exclusive, so a control cannot be\n             * both valid AND invalid or invalid AND disabled.\n             */\n            get: function () { return this._status; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"valid\", {\n            /**\n             * A control is `valid` when its `status === VALID`.\n             *\n             * In order to have this status, the control must have passed all its\n             * validation checks.\n             */\n            get: function () { return this._status === VALID; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"invalid\", {\n            /**\n             * A control is `invalid` when its `status === INVALID`.\n             *\n             * In order to have this status, the control must have failed\n             * at least one of its validation checks.\n             */\n            get: function () { return this._status === INVALID; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"pending\", {\n            /**\n             * A control is `pending` when its `status === PENDING`.\n             *\n             * In order to have this status, the control must be in the\n             * middle of conducting a validation check.\n             */\n            get: function () { return this._status == PENDING; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"disabled\", {\n            /**\n             * A control is `disabled` when its `status === DISABLED`.\n             *\n             * Disabled controls are exempt from validation checks and\n             * are not included in the aggregate value of their ancestor\n             * controls.\n             */\n            get: function () { return this._status === DISABLED; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"enabled\", {\n            /**\n             * A control is `enabled` as long as its `status !== DISABLED`.\n             *\n             * In other words, it has a status of `VALID`, `INVALID`, or\n             * `PENDING`.\n             */\n            get: function () { return this._status !== DISABLED; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"errors\", {\n            /**\n             * Returns any errors generated by failing validation. If there\n             * are no errors, it will return null.\n             */\n            get: function () { return this._errors; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"pristine\", {\n            /**\n             * A control is `pristine` if the user has not yet changed\n             * the value in the UI.\n             *\n             * Note that programmatic changes to a control's value will\n             * *not* mark it dirty.\n             */\n            get: function () { return this._pristine; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"dirty\", {\n            /**\n             * A control is `dirty` if the user has changed the value\n             * in the UI.\n             *\n             * Note that programmatic changes to a control's value will\n             * *not* mark it dirty.\n             */\n            get: function () { return !this.pristine; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"touched\", {\n            /**\n            * A control is marked `touched` once the user has triggered\n            * a `blur` event on it.\n            */\n            get: function () { return this._touched; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"untouched\", {\n            /**\n             * A control is `untouched` if the user has not yet triggered\n             * a `blur` event on it.\n             */\n            get: function () { return !this._touched; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"valueChanges\", {\n            /**\n             * Emits an event every time the value of the control changes, in\n             * the UI or programmatically.\n             */\n            get: function () { return this._valueChanges; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"statusChanges\", {\n            /**\n             * Emits an event every time the validation status of the control\n             * is re-calculated.\n             */\n            get: function () { return this._statusChanges; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Sets the synchronous validators that are active on this control.  Calling\n         * this will overwrite any existing sync validators.\n         */\n        AbstractControl.prototype.setValidators = function (newValidator) {\n            this.validator = coerceToValidator(newValidator);\n        };\n        /**\n         * Sets the async validators that are active on this control. Calling this\n         * will overwrite any existing async validators.\n         */\n        AbstractControl.prototype.setAsyncValidators = function (newValidator) {\n            this.asyncValidator = coerceToAsyncValidator(newValidator);\n        };\n        /**\n         * Empties out the sync validator list.\n         */\n        AbstractControl.prototype.clearValidators = function () { this.validator = null; };\n        /**\n         * Empties out the async validator list.\n         */\n        AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };\n        /**\n         * Marks the control as `touched`.\n         *\n         * This will also mark all direct ancestors as `touched` to maintain\n         * the model.\n         */\n        AbstractControl.prototype.markAsTouched = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            onlySelf = normalizeBool(onlySelf);\n            this._touched = true;\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent.markAsTouched({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Marks the control as `untouched`.\n         *\n         * If the control has any children, it will also mark all children as `untouched`\n         * to maintain the model, and re-calculate the `touched` status of all parent\n         * controls.\n         */\n        AbstractControl.prototype.markAsUntouched = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._touched = false;\n            this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent._updateTouched({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Marks the control as `dirty`.\n         *\n         * This will also mark all direct ancestors as `dirty` to maintain\n         * the model.\n         */\n        AbstractControl.prototype.markAsDirty = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            onlySelf = normalizeBool(onlySelf);\n            this._pristine = false;\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent.markAsDirty({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Marks the control as `pristine`.\n         *\n         * If the control has any children, it will also mark all children as `pristine`\n         * to maintain the model, and re-calculate the `pristine` status of all parent\n         * controls.\n         */\n        AbstractControl.prototype.markAsPristine = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._pristine = true;\n            this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent._updatePristine({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Marks the control as `pending`.\n         */\n        AbstractControl.prototype.markAsPending = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            onlySelf = normalizeBool(onlySelf);\n            this._status = PENDING;\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent.markAsPending({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Disables the control. This means the control will be exempt from validation checks and\n         * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n         *\n         * If the control has children, all children will be disabled to maintain the model.\n         */\n        AbstractControl.prototype.disable = function (_a) {\n            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;\n            emitEvent = isPresent(emitEvent) ? emitEvent : true;\n            this._status = DISABLED;\n            this._errors = null;\n            this._forEachChild(function (control) { control.disable({ onlySelf: true }); });\n            this._updateValue();\n            if (emitEvent) {\n                this._valueChanges.emit(this._value);\n                this._statusChanges.emit(this._status);\n            }\n            this._updateAncestors(onlySelf);\n            this._onDisabledChange(true);\n        };\n        /**\n         * Enables the control. This means the control will be included in validation checks and\n         * the aggregate value of its parent. Its status is re-calculated based on its value and\n         * its validators.\n         *\n         * If the control has children, all children will be enabled.\n         */\n        AbstractControl.prototype.enable = function (_a) {\n            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;\n            this._status = VALID;\n            this._forEachChild(function (control) { control.enable({ onlySelf: true }); });\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });\n            this._updateAncestors(onlySelf);\n            this._onDisabledChange(false);\n        };\n        AbstractControl.prototype._updateAncestors = function (onlySelf) {\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent.updateValueAndValidity();\n                this._parent._updatePristine();\n                this._parent._updateTouched();\n            }\n        };\n        AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };\n        /**\n         * Re-calculates the value and validation status of the control.\n         *\n         * By default, it will also update the value and validity of its ancestors.\n         */\n        AbstractControl.prototype.updateValueAndValidity = function (_a) {\n            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;\n            onlySelf = normalizeBool(onlySelf);\n            emitEvent = isPresent(emitEvent) ? emitEvent : true;\n            this._setInitialStatus();\n            this._updateValue();\n            if (this.enabled) {\n                this._errors = this._runValidator();\n                this._status = this._calculateStatus();\n                if (this._status === VALID || this._status === PENDING) {\n                    this._runAsyncValidator(emitEvent);\n                }\n            }\n            if (emitEvent) {\n                this._valueChanges.emit(this._value);\n                this._statusChanges.emit(this._status);\n            }\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });\n            }\n        };\n        /** @internal */\n        AbstractControl.prototype._updateTreeValidity = function (_a) {\n            var emitEvent = (_a === void 0 ? { emitEvent: true } : _a).emitEvent;\n            this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity({ emitEvent: emitEvent }); });\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });\n        };\n        AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };\n        AbstractControl.prototype._runValidator = function () {\n            return isPresent(this.validator) ? this.validator(this) : null;\n        };\n        AbstractControl.prototype._runAsyncValidator = function (emitEvent) {\n            var _this = this;\n            if (isPresent(this.asyncValidator)) {\n                this._status = PENDING;\n                this._cancelExistingSubscription();\n                var obs = toObservable(this.asyncValidator(this));\n                this._asyncValidationSubscription = obs.subscribe({ next: function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); } });\n            }\n        };\n        AbstractControl.prototype._cancelExistingSubscription = function () {\n            if (isPresent(this._asyncValidationSubscription)) {\n                this._asyncValidationSubscription.unsubscribe();\n            }\n        };\n        /**\n         * Sets errors on a form control.\n         *\n         * This is used when validations are run manually by the user, rather than automatically.\n         *\n         * Calling `setErrors` will also update the validity of the parent control.\n         *\n         * ### Example\n         *\n         * ```\n         * const login = new FormControl(\"someLogin\");\n         * login.setErrors({\n         *   \"notUnique\": true\n         * });\n         *\n         * expect(login.valid).toEqual(false);\n         * expect(login.errors).toEqual({\"notUnique\": true});\n         *\n         * login.setValue(\"someOtherLogin\");\n         *\n         * expect(login.valid).toEqual(true);\n         * ```\n         */\n        AbstractControl.prototype.setErrors = function (errors, _a) {\n            var emitEvent = (_a === void 0 ? {} : _a).emitEvent;\n            emitEvent = isPresent(emitEvent) ? emitEvent : true;\n            this._errors = errors;\n            this._updateControlsErrors(emitEvent);\n        };\n        /**\n         * Retrieves a child control given the control's name or path.\n         *\n         * Paths can be passed in as an array or a string delimited by a dot.\n         *\n         * To get a control nested within a `person` sub-group:\n         *\n         * * `this.form.get('person.name');`\n         *\n         * -OR-\n         *\n         * * `this.form.get(['person', 'name']);`\n         */\n        AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };\n        /**\n         * Returns true if the control with the given path has the error specified. Otherwise\n         * returns null or undefined.\n         *\n         * If no path is given, it checks for the error on the present control.\n         */\n        AbstractControl.prototype.getError = function (errorCode, path) {\n            if (path === void 0) { path = null; }\n            var control = isPresent(path) && !ListWrapper.isEmpty(path) ? this.get(path) : this;\n            if (isPresent(control) && isPresent(control._errors)) {\n                return StringMapWrapper.get(control._errors, errorCode);\n            }\n            else {\n                return null;\n            }\n        };\n        /**\n         * Returns true if the control with the given path has the error specified. Otherwise\n         * returns false.\n         *\n         * If no path is given, it checks for the error on the present control.\n         */\n        AbstractControl.prototype.hasError = function (errorCode, path) {\n            if (path === void 0) { path = null; }\n            return isPresent(this.getError(errorCode, path));\n        };\n        Object.defineProperty(AbstractControl.prototype, \"root\", {\n            /**\n             * Retrieves the top-level ancestor of this control.\n             */\n            get: function () {\n                var x = this;\n                while (isPresent(x._parent)) {\n                    x = x._parent;\n                }\n                return x;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        AbstractControl.prototype._updateControlsErrors = function (emitEvent) {\n            this._status = this._calculateStatus();\n            if (emitEvent) {\n                this._statusChanges.emit(this._status);\n            }\n            if (isPresent(this._parent)) {\n                this._parent._updateControlsErrors(emitEvent);\n            }\n        };\n        /** @internal */\n        AbstractControl.prototype._initObservables = function () {\n            this._valueChanges = new EventEmitter();\n            this._statusChanges = new EventEmitter();\n        };\n        AbstractControl.prototype._calculateStatus = function () {\n            if (this._allControlsDisabled())\n                return DISABLED;\n            if (isPresent(this._errors))\n                return INVALID;\n            if (this._anyControlsHaveStatus(PENDING))\n                return PENDING;\n            if (this._anyControlsHaveStatus(INVALID))\n                return INVALID;\n            return VALID;\n        };\n        /** @internal */\n        AbstractControl.prototype._anyControlsHaveStatus = function (status) {\n            return this._anyControls(function (control) { return control.status == status; });\n        };\n        /** @internal */\n        AbstractControl.prototype._anyControlsDirty = function () {\n            return this._anyControls(function (control) { return control.dirty; });\n        };\n        /** @internal */\n        AbstractControl.prototype._anyControlsTouched = function () {\n            return this._anyControls(function (control) { return control.touched; });\n        };\n        /** @internal */\n        AbstractControl.prototype._updatePristine = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._pristine = !this._anyControlsDirty();\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent._updatePristine({ onlySelf: onlySelf });\n            }\n        };\n        /** @internal */\n        AbstractControl.prototype._updateTouched = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._touched = this._anyControlsTouched();\n            if (isPresent(this._parent) && !onlySelf) {\n                this._parent._updateTouched({ onlySelf: onlySelf });\n            }\n        };\n        /** @internal */\n        AbstractControl.prototype._onDisabledChange = function (isDisabled) { };\n        /** @internal */\n        AbstractControl.prototype._isBoxedValue = function (formState) {\n            return isStringMap(formState) && Object.keys(formState).length === 2 && 'value' in formState &&\n                'disabled' in formState;\n        };\n        /** @internal */\n        AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };\n        return AbstractControl;\n    }());\n    /**\n     * @whatItDoes Tracks the value and validation status of an individual form control.\n     *\n     * It is one of the three fundamental building blocks of Angular forms, along with\n     * {@link FormGroup} and {@link FormArray}.\n     *\n     * @howToUse\n     *\n     * When instantiating a {@link FormControl}, you can pass in an initial value as the\n     * first argument. Example:\n     *\n     * ```ts\n     * const ctrl = new FormControl('some value');\n     * console.log(ctrl.value);     // 'some value'\n     *```\n     *\n     * You can also initialize the control with a form state object on instantiation,\n     * which includes both the value and whether or not the control is disabled.\n     *\n     * ```ts\n     * const ctrl = new FormControl({value: 'n/a', disabled: true});\n     * console.log(ctrl.value);     // 'n/a'\n     * console.log(ctrl.status);   // 'DISABLED'\n     * ```\n     *\n     * To include a sync validator (or an array of sync validators) with the control,\n     * pass it in as the second argument. Async validators are also supported, but\n     * have to be passed in separately as the third arg.\n     *\n     * ```ts\n     * const ctrl = new FormControl('', Validators.required);\n     * console.log(ctrl.value);     // ''\n     * console.log(ctrl.status);   // 'INVALID'\n     * ```\n     *\n     * See its superclass, {@link AbstractControl}, for more properties and methods.\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * @stable\n     */\n    var FormControl = (function (_super) {\n        __extends$6(FormControl, _super);\n        function FormControl(formState, validator, asyncValidator) {\n            if (formState === void 0) { formState = null; }\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));\n            /** @internal */\n            this._onChange = [];\n            this._applyFormState(formState);\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\n            this._initObservables();\n        }\n        /**\n         * Set the value of the form control to `value`.\n         *\n         * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`\n         * and not its parent component. This defaults to false.\n         *\n         * If `emitEvent` is `true`, this\n         * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults\n         * to true (as it falls through to `updateValueAndValidity`).\n         *\n         * If `emitModelToViewChange` is `true`, the view will be notified about the new value\n         * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not\n         * specified.\n         *\n         * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the\n         * model.  This is the default behavior if `emitViewToModelChange` is not specified.\n         */\n        FormControl.prototype.setValue = function (value, _a) {\n            var _this = this;\n            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange, emitViewToModelChange = _b.emitViewToModelChange;\n            emitModelToViewChange = isPresent(emitModelToViewChange) ? emitModelToViewChange : true;\n            emitViewToModelChange = isPresent(emitViewToModelChange) ? emitViewToModelChange : true;\n            this._value = value;\n            if (this._onChange.length && emitModelToViewChange) {\n                this._onChange.forEach(function (changeFn) { return changeFn(_this._value, emitViewToModelChange); });\n            }\n            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });\n        };\n        /**\n         * Patches the value of a control.\n         *\n         * This function is functionally the same as {@link FormControl.setValue} at this level.\n         * It exists for symmetry with {@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,\n         * where it does behave differently.\n         */\n        FormControl.prototype.patchValue = function (value, options) {\n            if (options === void 0) { options = {}; }\n            this.setValue(value, options);\n        };\n        /**\n         * Resets the form control. This means by default:\n         *\n         * * it is marked as `pristine`\n         * * it is marked as `untouched`\n         * * value is set to null\n         *\n         * You can also reset to a specific form state by passing through a standalone\n         * value or a form state object that contains both a value and a disabled state\n         * (these are the only two properties that cannot be calculated).\n         *\n         * Ex:\n         *\n         * ```ts\n         * this.control.reset('Nancy');\n         *\n         * console.log(this.control.value);  // 'Nancy'\n         * ```\n         *\n         * OR\n         *\n         * ```\n         * this.control.reset({value: 'Nancy', disabled: true});\n         *\n         * console.log(this.control.value);  // 'Nancy'\n         * console.log(this.control.status);  // 'DISABLED'\n         * ```\n         */\n        FormControl.prototype.reset = function (formState, _a) {\n            if (formState === void 0) { formState = null; }\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._applyFormState(formState);\n            this.markAsPristine({ onlySelf: onlySelf });\n            this.markAsUntouched({ onlySelf: onlySelf });\n            this.setValue(this._value, { onlySelf: onlySelf });\n        };\n        /**\n         * @internal\n         */\n        FormControl.prototype._updateValue = function () { };\n        /**\n         * @internal\n         */\n        FormControl.prototype._anyControls = function (condition) { return false; };\n        /**\n         * @internal\n         */\n        FormControl.prototype._allControlsDisabled = function () { return this.disabled; };\n        /**\n         * Register a listener for change events.\n         */\n        FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };\n        /**\n         * @internal\n         */\n        FormControl.prototype._clearChangeFns = function () {\n            this._onChange = [];\n            this._onDisabledChange = null;\n            this._onCollectionChange = function () { };\n        };\n        /**\n         * Register a listener for disabled events.\n         */\n        FormControl.prototype.registerOnDisabledChange = function (fn) { this._onDisabledChange = fn; };\n        /**\n         * @internal\n         */\n        FormControl.prototype._forEachChild = function (cb) { };\n        FormControl.prototype._applyFormState = function (formState) {\n            if (this._isBoxedValue(formState)) {\n                this._value = formState.value;\n                formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :\n                    this.enable({ onlySelf: true, emitEvent: false });\n            }\n            else {\n                this._value = formState;\n            }\n        };\n        return FormControl;\n    }(AbstractControl));\n    /**\n     * @whatItDoes Tracks the value and validity state of a group of {@link FormControl}\n     * instances.\n     *\n     * A `FormGroup` aggregates the values of each child {@link FormControl} into one object,\n     * with each control name as the key.  It calculates its status by reducing the statuses\n     * of its children. For example, if one of the controls in a group is invalid, the entire\n     * group becomes invalid.\n     *\n     * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n     * along with {@link FormControl} and {@link FormArray}.\n     *\n     * @howToUse\n     *\n     * When instantiating a {@link FormGroup}, pass in a collection of child controls as the first\n     * argument. The key for each child will be the name under which it is registered.\n     *\n     * ### Example\n     *\n     * ```\n     * const form = new FormGroup({\n     *   first: new FormControl('Nancy', Validators.minLength(2)),\n     *   last: new FormControl('Drew'),\n     * });\n     *\n     * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n     * console.log(form.status);  // 'VALID'\n     * ```\n     *\n     * You can also include group-level validators as the second arg, or group-level async\n     * validators as the third arg. These come in handy when you want to perform validation\n     * that considers the value of more than one child control.\n     *\n     * ### Example\n     *\n     * ```\n     * const form = new FormGroup({\n     *   password: new FormControl('', Validators.minLength(2)),\n     *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n     * }, passwordMatchValidator);\n     *\n     *\n     * function passwordMatchValidator(g: FormGroup) {\n     *    return g.get('password').value === g.get('passwordConfirm').value\n     *       ? null : {'mismatch': true};\n     * }\n     * ```\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * @stable\n     */\n    var FormGroup = (function (_super) {\n        __extends$6(FormGroup, _super);\n        function FormGroup(controls, validator, asyncValidator) {\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            _super.call(this, validator, asyncValidator);\n            this.controls = controls;\n            this._initObservables();\n            this._setUpControls();\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\n        }\n        /**\n         * Registers a control with the group's list of controls.\n         *\n         * This method does not update value or validity of the control, so for\n         * most cases you'll want to use {@link FormGroup.addControl} instead.\n         */\n        FormGroup.prototype.registerControl = function (name, control) {\n            if (this.controls[name])\n                return this.controls[name];\n            this.controls[name] = control;\n            control.setParent(this);\n            control._registerOnCollectionChange(this._onCollectionChange);\n            return control;\n        };\n        /**\n         * Add a control to this group.\n         */\n        FormGroup.prototype.addControl = function (name, control) {\n            this.registerControl(name, control);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Remove a control from this group.\n         */\n        FormGroup.prototype.removeControl = function (name) {\n            if (this.controls[name])\n                this.controls[name]._registerOnCollectionChange(function () { });\n            StringMapWrapper.delete(this.controls, name);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Replace an existing control.\n         */\n        FormGroup.prototype.setControl = function (name, control) {\n            if (this.controls[name])\n                this.controls[name]._registerOnCollectionChange(function () { });\n            StringMapWrapper.delete(this.controls, name);\n            if (control)\n                this.registerControl(name, control);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Check whether there is an enabled control with the given name in the group.\n         *\n         * It will return false for disabled controls. If you'd like to check for\n         * existence in the group only, use {@link AbstractControl.get} instead.\n         */\n        FormGroup.prototype.contains = function (controlName) {\n            return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n        };\n        /**\n         *  Sets the value of the {@link FormGroup}. It accepts an object that matches\n         *  the structure of the group, with control names as keys.\n         *\n         * This method performs strict checks, so it will throw an error if you try\n         * to set the value of a control that doesn't exist or if you exclude the\n         * value of a control.\n         *\n         *  ### Example\n         *\n         *  ```\n         *  const form = new FormGroup({\n         *     first: new FormControl(),\n         *     last: new FormControl()\n         *  });\n         *  console.log(form.value);   // {first: null, last: null}\n         *\n         *  form.setValue({first: 'Nancy', last: 'Drew'});\n         *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n         *\n         *  ```\n         */\n        FormGroup.prototype.setValue = function (value, _a) {\n            var _this = this;\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._checkAllValuesPresent(value);\n            StringMapWrapper.forEach(value, function (newValue, name) {\n                _this._throwIfControlMissing(name);\n                _this.controls[name].setValue(newValue, { onlySelf: true });\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n        };\n        /**\n         *  Patches the value of the {@link FormGroup}. It accepts an object with control\n         *  names as keys, and will do its best to match the values to the correct controls\n         *  in the group.\n         *\n         *  It accepts both super-sets and sub-sets of the group without throwing an error.\n         *\n         *  ### Example\n         *\n         *  ```\n         *  const form = new FormGroup({\n         *     first: new FormControl(),\n         *     last: new FormControl()\n         *  });\n         *  console.log(form.value);   // {first: null, last: null}\n         *\n         *  form.patchValue({first: 'Nancy'});\n         *  console.log(form.value);   // {first: 'Nancy', last: null}\n         *\n         *  ```\n         */\n        FormGroup.prototype.patchValue = function (value, _a) {\n            var _this = this;\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            StringMapWrapper.forEach(value, function (newValue, name) {\n                if (_this.controls[name]) {\n                    _this.controls[name].patchValue(newValue, { onlySelf: true });\n                }\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n        };\n        /**\n         * Resets the {@link FormGroup}. This means by default:\n         *\n         * * The group and all descendants are marked `pristine`\n         * * The group and all descendants are marked `untouched`\n         * * The value of all descendants will be null or null maps\n         *\n         * You can also reset to a specific form state by passing in a map of states\n         * that matches the structure of your form, with control names as keys. The state\n         * can be a standalone value or a form state object with both a value and a disabled\n         * status.\n         *\n         * ### Example\n         *\n         * ```ts\n         * this.form.reset({first: 'name', last; 'last name'});\n         *\n         * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n         * ```\n         *\n         * - OR -\n         *\n         * ```\n         * this.form.reset({\n         *   first: {value: 'name', disabled: true},\n         *   last: 'last'\n         * });\n         *\n         * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n         * console.log(this.form.get('first').status);  // 'DISABLED'\n         * ```\n         */\n        FormGroup.prototype.reset = function (value, _a) {\n            if (value === void 0) { value = {}; }\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._forEachChild(function (control, name) {\n                control.reset(value[name], { onlySelf: true });\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n            this._updatePristine({ onlySelf: onlySelf });\n            this._updateTouched({ onlySelf: onlySelf });\n        };\n        /**\n         * The aggregate value of the {@link FormGroup}, including any disabled controls.\n         *\n         * If you'd like to include all values regardless of disabled status, use this method.\n         * Otherwise, the `value` property is the best way to get the value of the group.\n         */\n        FormGroup.prototype.getRawValue = function () {\n            return this._reduceChildren({}, function (acc, control, name) {\n                acc[name] = control.value;\n                return acc;\n            });\n        };\n        /** @internal */\n        FormGroup.prototype._throwIfControlMissing = function (name) {\n            if (!Object.keys(this.controls).length) {\n                throw new Error(\"\\n        There are no form controls registered with this group yet.  If you're using ngModel,\\n        you may want to check next tick (e.g. use setTimeout).\\n      \");\n            }\n            if (!this.controls[name]) {\n                throw new Error(\"Cannot find form control with name: \" + name + \".\");\n            }\n        };\n        /** @internal */\n        FormGroup.prototype._forEachChild = function (cb) {\n            StringMapWrapper.forEach(this.controls, cb);\n        };\n        /** @internal */\n        FormGroup.prototype._setUpControls = function () {\n            var _this = this;\n            this._forEachChild(function (control) {\n                control.setParent(_this);\n                control._registerOnCollectionChange(_this._onCollectionChange);\n            });\n        };\n        /** @internal */\n        FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };\n        /** @internal */\n        FormGroup.prototype._anyControls = function (condition) {\n            var _this = this;\n            var res = false;\n            this._forEachChild(function (control, name) {\n                res = res || (_this.contains(name) && condition(control));\n            });\n            return res;\n        };\n        /** @internal */\n        FormGroup.prototype._reduceValue = function () {\n            var _this = this;\n            return this._reduceChildren({}, function (acc, control, name) {\n                if (control.enabled || _this.disabled) {\n                    acc[name] = control.value;\n                }\n                return acc;\n            });\n        };\n        /** @internal */\n        FormGroup.prototype._reduceChildren = function (initValue, fn) {\n            var res = initValue;\n            this._forEachChild(function (control, name) { res = fn(res, control, name); });\n            return res;\n        };\n        /** @internal */\n        FormGroup.prototype._allControlsDisabled = function () {\n            for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {\n                var controlName = _a[_i];\n                if (this.controls[controlName].enabled) {\n                    return false;\n                }\n            }\n            return Object.keys(this.controls).length > 0 || this.disabled;\n        };\n        /** @internal */\n        FormGroup.prototype._checkAllValuesPresent = function (value) {\n            this._forEachChild(function (control, name) {\n                if (value[name] === undefined) {\n                    throw new Error(\"Must supply a value for form control with name: '\" + name + \"'.\");\n                }\n            });\n        };\n        return FormGroup;\n    }(AbstractControl));\n    /**\n     * @whatItDoes Tracks the value and validity state of an array of {@link FormControl}\n     * instances.\n     *\n     * A `FormArray` aggregates the values of each child {@link FormControl} into an array.\n     * It calculates its status by reducing the statuses of its children. For example, if one of\n     * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n     *\n     * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n     * along with {@link FormControl} and {@link FormGroup}.\n     *\n     * @howToUse\n     *\n     * When instantiating a {@link FormArray}, pass in an array of child controls as the first\n     * argument.\n     *\n     * ### Example\n     *\n     * ```\n     * const arr = new FormArray([\n     *   new FormControl('Nancy', Validators.minLength(2)),\n     *   new FormControl('Drew'),\n     * ]);\n     *\n     * console.log(arr.value);   // ['Nancy', 'Drew']\n     * console.log(arr.status);  // 'VALID'\n     * ```\n     *\n     * You can also include array-level validators as the second arg, or array-level async\n     * validators as the third arg. These come in handy when you want to perform validation\n     * that considers the value of more than one child control.\n     *\n     * ### Adding or removing controls\n     *\n     * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods\n     * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n     * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n     * the `FormArray` directly, as that will result in strange and unexpected behavior such\n     * as broken change detection.\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * @stable\n     */\n    var FormArray = (function (_super) {\n        __extends$6(FormArray, _super);\n        function FormArray(controls, validator, asyncValidator) {\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            _super.call(this, validator, asyncValidator);\n            this.controls = controls;\n            this._initObservables();\n            this._setUpControls();\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\n        }\n        /**\n         * Get the {@link AbstractControl} at the given `index` in the array.\n         */\n        FormArray.prototype.at = function (index) { return this.controls[index]; };\n        /**\n         * Insert a new {@link AbstractControl} at the end of the array.\n         */\n        FormArray.prototype.push = function (control) {\n            this.controls.push(control);\n            this._registerControl(control);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Insert a new {@link AbstractControl} at the given `index` in the array.\n         */\n        FormArray.prototype.insert = function (index, control) {\n            ListWrapper.insert(this.controls, index, control);\n            this._registerControl(control);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Remove the control at the given `index` in the array.\n         */\n        FormArray.prototype.removeAt = function (index) {\n            if (this.controls[index])\n                this.controls[index]._registerOnCollectionChange(function () { });\n            ListWrapper.removeAt(this.controls, index);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Replace an existing control.\n         */\n        FormArray.prototype.setControl = function (index, control) {\n            if (this.controls[index])\n                this.controls[index]._registerOnCollectionChange(function () { });\n            ListWrapper.removeAt(this.controls, index);\n            if (control) {\n                ListWrapper.insert(this.controls, index, control);\n                this._registerControl(control);\n            }\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        Object.defineProperty(FormArray.prototype, \"length\", {\n            /**\n             * Length of the control array.\n             */\n            get: function () { return this.controls.length; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         *  Sets the value of the {@link FormArray}. It accepts an array that matches\n         *  the structure of the control.\n         *\n         * This method performs strict checks, so it will throw an error if you try\n         * to set the value of a control that doesn't exist or if you exclude the\n         * value of a control.\n         *\n         *  ### Example\n         *\n         *  ```\n         *  const arr = new FormArray([\n         *     new FormControl(),\n         *     new FormControl()\n         *  ]);\n         *  console.log(arr.value);   // [null, null]\n         *\n         *  arr.setValue(['Nancy', 'Drew']);\n         *  console.log(arr.value);   // ['Nancy', 'Drew']\n         *  ```\n         */\n        FormArray.prototype.setValue = function (value, _a) {\n            var _this = this;\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._checkAllValuesPresent(value);\n            value.forEach(function (newValue, index) {\n                _this._throwIfControlMissing(index);\n                _this.at(index).setValue(newValue, { onlySelf: true });\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n        };\n        /**\n         *  Patches the value of the {@link FormArray}. It accepts an array that matches the\n         *  structure of the control, and will do its best to match the values to the correct\n         *  controls in the group.\n         *\n         *  It accepts both super-sets and sub-sets of the array without throwing an error.\n         *\n         *  ### Example\n         *\n         *  ```\n         *  const arr = new FormArray([\n         *     new FormControl(),\n         *     new FormControl()\n         *  ]);\n         *  console.log(arr.value);   // [null, null]\n         *\n         *  arr.patchValue(['Nancy']);\n         *  console.log(arr.value);   // ['Nancy', null]\n         *  ```\n         */\n        FormArray.prototype.patchValue = function (value, _a) {\n            var _this = this;\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            value.forEach(function (newValue, index) {\n                if (_this.at(index)) {\n                    _this.at(index).patchValue(newValue, { onlySelf: true });\n                }\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n        };\n        /**\n         * Resets the {@link FormArray}. This means by default:\n         *\n         * * The array and all descendants are marked `pristine`\n         * * The array and all descendants are marked `untouched`\n         * * The value of all descendants will be null or null maps\n         *\n         * You can also reset to a specific form state by passing in an array of states\n         * that matches the structure of the control. The state can be a standalone value\n         * or a form state object with both a value and a disabled status.\n         *\n         * ### Example\n         *\n         * ```ts\n         * this.arr.reset(['name', 'last name']);\n         *\n         * console.log(this.arr.value);  // ['name', 'last name']\n         * ```\n         *\n         * - OR -\n         *\n         * ```\n         * this.arr.reset([\n         *   {value: 'name', disabled: true},\n         *   'last'\n         * ]);\n         *\n         * console.log(this.arr.value);  // ['name', 'last name']\n         * console.log(this.arr.get(0).status);  // 'DISABLED'\n         * ```\n         */\n        FormArray.prototype.reset = function (value, _a) {\n            if (value === void 0) { value = []; }\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._forEachChild(function (control, index) {\n                control.reset(value[index], { onlySelf: true });\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n            this._updatePristine({ onlySelf: onlySelf });\n            this._updateTouched({ onlySelf: onlySelf });\n        };\n        /**\n         * The aggregate value of the array, including any disabled controls.\n         *\n         * If you'd like to include all values regardless of disabled status, use this method.\n         * Otherwise, the `value` property is the best way to get the value of the array.\n         */\n        FormArray.prototype.getRawValue = function () { return this.controls.map(function (control) { return control.value; }); };\n        /** @internal */\n        FormArray.prototype._throwIfControlMissing = function (index) {\n            if (!this.controls.length) {\n                throw new Error(\"\\n        There are no form controls registered with this array yet.  If you're using ngModel,\\n        you may want to check next tick (e.g. use setTimeout).\\n      \");\n            }\n            if (!this.at(index)) {\n                throw new Error(\"Cannot find form control at index \" + index);\n            }\n        };\n        /** @internal */\n        FormArray.prototype._forEachChild = function (cb) {\n            this.controls.forEach(function (control, index) { cb(control, index); });\n        };\n        /** @internal */\n        FormArray.prototype._updateValue = function () {\n            var _this = this;\n            this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })\n                .map(function (control) { return control.value; });\n        };\n        /** @internal */\n        FormArray.prototype._anyControls = function (condition) {\n            return this.controls.some(function (control) { return control.enabled && condition(control); });\n        };\n        /** @internal */\n        FormArray.prototype._setUpControls = function () {\n            var _this = this;\n            this._forEachChild(function (control) { return _this._registerControl(control); });\n        };\n        /** @internal */\n        FormArray.prototype._checkAllValuesPresent = function (value) {\n            this._forEachChild(function (control, i) {\n                if (value[i] === undefined) {\n                    throw new Error(\"Must supply a value for form control at index: \" + i + \".\");\n                }\n            });\n        };\n        /** @internal */\n        FormArray.prototype._allControlsDisabled = function () {\n            for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {\n                var control = _a[_i];\n                if (control.enabled)\n                    return false;\n            }\n            return this.controls.length > 0 || this.disabled;\n        };\n        FormArray.prototype._registerControl = function (control) {\n            control.setParent(this);\n            control._registerOnCollectionChange(this._onCollectionChange);\n        };\n        return FormArray;\n    }(AbstractControl));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formDirectiveProvider = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return NgForm; })\n    };\n    var resolvedPromise = Promise.resolve(null);\n    /**\n     * @whatItDoes Creates a top-level {@link FormGroup} instance and binds it to a form\n     * to track aggregate form value and validation status.\n     *\n     * @howToUse\n     *\n     * As soon as you import the `FormsModule`, this directive becomes active by default on\n     * all `<form>` tags.  You don't need to add a special selector.\n     *\n     * You can export the directive into a local template variable using `ngForm` as the key\n     * (ex: `#myForm=\"ngForm\"`). This is optional, but useful.  Many properties from the underlying\n     * {@link FormGroup} instance are duplicated on the directive itself, so a reference to it\n     * will give you access to the aggregate value and validity status of the form, as well as\n     * user interaction properties like `dirty` and `touched`.\n     *\n     * To register child controls with the form, you'll want to use {@link NgModel} with a\n     * `name` attribute.  You can also use {@link NgModelGroup} if you'd like to create\n     * sub-groups within the form.\n     *\n     * You can listen to the directive's `ngSubmit` event to be notified when the user has\n     * triggered a form submission.\n     *\n     * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `FormsModule`\n     *\n     *  @stable\n     */\n    var NgForm = (function (_super) {\n        __extends$4(NgForm, _super);\n        function NgForm(validators, asyncValidators) {\n            _super.call(this);\n            this._submitted = false;\n            this.ngSubmit = new EventEmitter();\n            this.form =\n                new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));\n        }\n        Object.defineProperty(NgForm.prototype, \"submitted\", {\n            get: function () { return this._submitted; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForm.prototype, \"formDirective\", {\n            get: function () { return this; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForm.prototype, \"control\", {\n            get: function () { return this.form; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForm.prototype, \"path\", {\n            get: function () { return []; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForm.prototype, \"controls\", {\n            get: function () { return this.form.controls; },\n            enumerable: true,\n            configurable: true\n        });\n        NgForm.prototype.addControl = function (dir) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var container = _this._findContainer(dir.path);\n                dir._control = container.registerControl(dir.name, dir.control);\n                setUpControl(dir.control, dir);\n                dir.control.updateValueAndValidity({ emitEvent: false });\n            });\n        };\n        NgForm.prototype.getControl = function (dir) { return this.form.get(dir.path); };\n        NgForm.prototype.removeControl = function (dir) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var container = _this._findContainer(dir.path);\n                if (isPresent(container)) {\n                    container.removeControl(dir.name);\n                }\n            });\n        };\n        NgForm.prototype.addFormGroup = function (dir) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var container = _this._findContainer(dir.path);\n                var group = new FormGroup({});\n                setUpFormContainer(group, dir);\n                container.registerControl(dir.name, group);\n                group.updateValueAndValidity({ emitEvent: false });\n            });\n        };\n        NgForm.prototype.removeFormGroup = function (dir) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var container = _this._findContainer(dir.path);\n                if (isPresent(container)) {\n                    container.removeControl(dir.name);\n                }\n            });\n        };\n        NgForm.prototype.getFormGroup = function (dir) { return this.form.get(dir.path); };\n        NgForm.prototype.updateModel = function (dir, value) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var ctrl = _this.form.get(dir.path);\n                ctrl.setValue(value);\n            });\n        };\n        NgForm.prototype.setValue = function (value) { this.control.setValue(value); };\n        NgForm.prototype.onSubmit = function () {\n            this._submitted = true;\n            this.ngSubmit.emit(null);\n            return false;\n        };\n        NgForm.prototype.onReset = function () { this.resetForm(); };\n        NgForm.prototype.resetForm = function (value) {\n            if (value === void 0) { value = undefined; }\n            this.form.reset(value);\n            this._submitted = false;\n        };\n        /** @internal */\n        NgForm.prototype._findContainer = function (path) {\n            path.pop();\n            return ListWrapper.isEmpty(path) ? this.form : this.form.get(path);\n        };\n        NgForm.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',\n                        providers: [formDirectiveProvider],\n                        host: { '(submit)': 'onSubmit()', '(reset)': 'onReset()' },\n                        outputs: ['ngSubmit'],\n                        exportAs: 'ngForm'\n                    },] },\n        ];\n        /** @nocollapse */\n        NgForm.ctorParameters = [\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        return NgForm;\n    }(ControlContainer));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var Examples = {\n        formControlName: \"\\n    <div [formGroup]=\\\"myGroup\\\">\\n      <input formControlName=\\\"firstName\\\">\\n    </div>\\n\\n    In your class:\\n\\n    this.myGroup = new FormGroup({\\n       firstName: new FormControl()\\n    });\",\n        formGroupName: \"\\n    <div [formGroup]=\\\"myGroup\\\">\\n       <div formGroupName=\\\"person\\\">\\n          <input formControlName=\\\"firstName\\\">\\n       </div>\\n    </div>\\n\\n    In your class:\\n\\n    this.myGroup = new FormGroup({\\n       person: new FormGroup({ firstName: new FormControl() })\\n    });\",\n        formArrayName: \"\\n    <div [formGroup]=\\\"myGroup\\\">\\n      <div formArrayName=\\\"cities\\\">\\n        <div *ngFor=\\\"let city of cityArray.controls; let i=index\\\">\\n          <input [formControlName]=\\\"i\\\">\\n        </div>\\n      </div>\\n    </div>\\n\\n    In your class:\\n\\n    this.cityArray = new FormArray([new FormControl('SF')]);\\n    this.myGroup = new FormGroup({\\n      cities: this.cityArray\\n    });\",\n        ngModelGroup: \"\\n    <form>\\n       <div ngModelGroup=\\\"person\\\">\\n          <input [(ngModel)]=\\\"person.name\\\" name=\\\"firstName\\\">\\n       </div>\\n    </form>\",\n        ngModelWithFormGroup: \"\\n    <div [formGroup]=\\\"myGroup\\\">\\n       <input formControlName=\\\"firstName\\\">\\n       <input [(ngModel)]=\\\"showMoreControls\\\" [ngModelOptions]=\\\"{standalone: true}\\\">\\n    </div>\\n  \"\n    };\n\n    var TemplateDrivenErrors = (function () {\n        function TemplateDrivenErrors() {\n        }\n        TemplateDrivenErrors.modelParentException = function () {\n            throw new Error(\"\\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\\n      formGroup's partner directive \\\"formControlName\\\" instead.  Example:\\n\\n      \" + Examples.formControlName + \"\\n\\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\\n\\n      Example:\\n\\n      \" + Examples.ngModelWithFormGroup);\n        };\n        TemplateDrivenErrors.formGroupNameException = function () {\n            throw new Error(\"\\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\\n\\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\\n\\n      \" + Examples.formGroupName + \"\\n\\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\\n\\n      \" + Examples.ngModelGroup);\n        };\n        TemplateDrivenErrors.missingNameException = function () {\n            throw new Error(\"If ngModel is used within a form tag, either the name attribute must be set or the form\\n      control must be defined as 'standalone' in ngModelOptions.\\n\\n      Example 1: <input [(ngModel)]=\\\"person.firstName\\\" name=\\\"first\\\">\\n      Example 2: <input [(ngModel)]=\\\"person.firstName\\\" [ngModelOptions]=\\\"{standalone: true}\\\">\");\n        };\n        TemplateDrivenErrors.modelGroupParentException = function () {\n            throw new Error(\"\\n      ngModelGroup cannot be used with a parent formGroup directive.\\n\\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\\n\\n      \" + Examples.formGroupName + \"\\n\\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\\n\\n      \" + Examples.ngModelGroup);\n        };\n        return TemplateDrivenErrors;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$8 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var modelGroupProvider = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return NgModelGroup; })\n    };\n    /**\n     * @whatItDoes Creates and binds a {@link FormGroup} instance to a DOM element.\n     *\n     * @howToUse\n     *\n     * This directive can only be used as a child of {@link NgForm} (or in other words,\n     * within `<form>` tags).\n     *\n     * Use this directive if you'd like to create a sub-group within a form. This can\n     * come in handy if you want to validate a sub-group of your form separately from\n     * the rest of your form, or if some values in your domain model make more sense to\n     * consume together in a nested object.\n     *\n     * Pass in the name you'd like this sub-group to have and it will become the key\n     * for the sub-group in the form's full value. You can also export the directive into\n     * a local template variable using `ngModelGroup` (ex: `#myGroup=\"ngModelGroup\"`).\n     *\n     * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `FormsModule`\n     *\n     * @stable\n     */\n    var NgModelGroup = (function (_super) {\n        __extends$8(NgModelGroup, _super);\n        function NgModelGroup(parent, validators, asyncValidators) {\n            _super.call(this);\n            this._parent = parent;\n            this._validators = validators;\n            this._asyncValidators = asyncValidators;\n        }\n        /** @internal */\n        NgModelGroup.prototype._checkParentType = function () {\n            if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {\n                TemplateDrivenErrors.modelGroupParentException();\n            }\n        };\n        NgModelGroup.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },\n        ];\n        /** @nocollapse */\n        NgModelGroup.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        NgModelGroup.propDecorators = {\n            'name': [{ type: _angular_core.Input, args: ['ngModelGroup',] },],\n        };\n        return NgModelGroup;\n    }(AbstractFormGroupDirective));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$7 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formControlBinding = {\n        provide: NgControl,\n        useExisting: _angular_core.forwardRef(function () { return NgModel; })\n    };\n    var resolvedPromise$1 = Promise.resolve(null);\n    /**\n     * @whatItDoes Creates a {@link FormControl} instance from a domain model and binds it\n     * to a form control element.\n     *\n     * The {@link FormControl} instance will track the value, user interaction, and\n     * validation status of the control and keep the view synced with the model. If used\n     * within a parent form, the directive will also register itself with the form as a child\n     * control.\n     *\n     * @howToUse\n     *\n     * This directive can be used by itself or as part of a larger form. All you need is the\n     * `ngModel` selector to activate it.\n     *\n     * It accepts a domain model as an optional {@link @Input}. If you have a one-way binding\n     * to `ngModel` with `[]` syntax, changing the value of the domain model in the component\n     * class will set the value in the view. If you have a two-way binding with `[()]` syntax\n     * (also known as 'banana-box syntax'), the value in the UI will always be synced back to\n     * the domain model in your class as well.\n     *\n     * If you wish to inspect the properties of the associated {@link FormControl} (like\n     * validity state), you can also export the directive into a local template variable using\n     * `ngModel` as the key (ex: `#myVar=\"ngModel\"`). You can then access the control using the\n     * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)\n     * will fall through to the control anyway, so you can access them directly. You can see a\n     * full list of properties directly available in {@link AbstractControlDirective}.\n     *\n     * The following is an example of a simple standalone control using `ngModel`:\n     *\n     * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}\n     *\n     * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute\n     * so that the control can be registered with the parent form under that name.\n     *\n     * It's worth noting that in the context of a parent form, you often can skip one-way or\n     * two-way binding because the parent form will sync the value for you. You can access\n     * its properties by exporting it into a local template variable using `ngForm` (ex:\n     * `#f=\"ngForm\"`). Then you can pass it where it needs to go on submit.\n     *\n     * If you do need to populate initial values into your form, using a one-way binding for\n     * `ngModel` tends to be sufficient as long as you use the exported form's value rather\n     * than the domain model's value on submit.\n     *\n     * Take a look at an example of using `ngModel` within a form:\n     *\n     * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n     *\n     * **npm package**: `@angular/forms`\n     *\n     * **NgModule**: `FormsModule`\n     *\n     *  @stable\n     */\n    var NgModel = (function (_super) {\n        __extends$7(NgModel, _super);\n        function NgModel(parent, validators, asyncValidators, valueAccessors) {\n            _super.call(this);\n            /** @internal */\n            this._control = new FormControl();\n            /** @internal */\n            this._registered = false;\n            this.update = new EventEmitter();\n            this._parent = parent;\n            this._rawValidators = validators || [];\n            this._rawAsyncValidators = asyncValidators || [];\n            this.valueAccessor = selectValueAccessor(this, valueAccessors);\n        }\n        NgModel.prototype.ngOnChanges = function (changes) {\n            this._checkForErrors();\n            if (!this._registered)\n                this._setUpControl();\n            if ('isDisabled' in changes) {\n                this._updateDisabled(changes);\n            }\n            if (isPropertyUpdated(changes, this.viewModel)) {\n                this._updateValue(this.model);\n                this.viewModel = this.model;\n            }\n        };\n        NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };\n        Object.defineProperty(NgModel.prototype, \"control\", {\n            get: function () { return this._control; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModel.prototype, \"path\", {\n            get: function () {\n                return this._parent ? controlPath(this.name, this._parent) : [this.name];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModel.prototype, \"formDirective\", {\n            get: function () { return this._parent ? this._parent.formDirective : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModel.prototype, \"validator\", {\n            get: function () { return composeValidators(this._rawValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModel.prototype, \"asyncValidator\", {\n            get: function () {\n                return composeAsyncValidators(this._rawAsyncValidators);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgModel.prototype.viewToModelUpdate = function (newValue) {\n            this.viewModel = newValue;\n            this.update.emit(newValue);\n        };\n        NgModel.prototype._setUpControl = function () {\n            this._isStandalone() ? this._setUpStandalone() :\n                this.formDirective.addControl(this);\n            this._registered = true;\n        };\n        NgModel.prototype._isStandalone = function () {\n            return !this._parent || (this.options && this.options.standalone);\n        };\n        NgModel.prototype._setUpStandalone = function () {\n            setUpControl(this._control, this);\n            this._control.updateValueAndValidity({ emitEvent: false });\n        };\n        NgModel.prototype._checkForErrors = function () {\n            if (!this._isStandalone()) {\n                this._checkParentType();\n            }\n            this._checkName();\n        };\n        NgModel.prototype._checkParentType = function () {\n            if (!(this._parent instanceof NgModelGroup) &&\n                this._parent instanceof AbstractFormGroupDirective) {\n                TemplateDrivenErrors.formGroupNameException();\n            }\n            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {\n                TemplateDrivenErrors.modelParentException();\n            }\n        };\n        NgModel.prototype._checkName = function () {\n            if (this.options && this.options.name)\n                this.name = this.options.name;\n            if (!this._isStandalone() && !this.name) {\n                TemplateDrivenErrors.missingNameException();\n            }\n        };\n        NgModel.prototype._updateValue = function (value) {\n            var _this = this;\n            resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });\n        };\n        NgModel.prototype._updateDisabled = function (changes) {\n            var _this = this;\n            var disabledValue = changes['isDisabled'].currentValue;\n            var isDisabled = disabledValue != null && disabledValue != false;\n            resolvedPromise$1.then(function () {\n                if (isDisabled && !_this.control.disabled) {\n                    _this.control.disable();\n                }\n                else if (!isDisabled && _this.control.disabled) {\n                    _this.control.enable();\n                }\n            });\n        };\n        NgModel.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[ngModel]:not([formControlName]):not([formControl])',\n                        providers: [formControlBinding],\n                        exportAs: 'ngModel'\n                    },] },\n        ];\n        /** @nocollapse */\n        NgModel.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },\n        ];\n        NgModel.propDecorators = {\n            'name': [{ type: _angular_core.Input },],\n            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],\n            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],\n            'options': [{ type: _angular_core.Input, args: ['ngModelOptions',] },],\n            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],\n        };\n        return NgModel;\n    }(NgControl));\n\n    var ReactiveErrors = (function () {\n        function ReactiveErrors() {\n        }\n        ReactiveErrors.controlParentException = function () {\n            throw new Error(\"formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\\n       directive and pass it an existing FormGroup instance (you can create one in your class).\\n\\n      Example:\\n\\n      \" + Examples.formControlName);\n        };\n        ReactiveErrors.ngModelGroupException = function () {\n            throw new Error(\"formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\\n       that also have a \\\"form\\\" prefix: formGroupName, formArrayName, or formGroup.\\n\\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\\n\\n        \" + Examples.formGroupName + \"\\n\\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\\n\\n        \" + Examples.ngModelGroup);\n        };\n        ReactiveErrors.missingFormException = function () {\n            throw new Error(\"formGroup expects a FormGroup instance. Please pass one in.\\n\\n       Example:\\n\\n       \" + Examples.formControlName);\n        };\n        ReactiveErrors.groupParentException = function () {\n            throw new Error(\"formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\\n      directive and pass it an existing FormGroup instance (you can create one in your class).\\n\\n      Example:\\n\\n      \" + Examples.formGroupName);\n        };\n        ReactiveErrors.arrayParentException = function () {\n            throw new Error(\"formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\\n       directive and pass it an existing FormGroup instance (you can create one in your class).\\n\\n        Example:\\n\\n        \" + Examples.formArrayName);\n        };\n        ReactiveErrors.disabledAttrWarning = function () {\n            console.warn(\"\\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\\n      you. We recommend using this approach to avoid 'changed after checked' errors.\\n       \\n      Example: \\n      form = new FormGroup({\\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\\n        last: new FormControl('Drew', Validators.required)\\n      });\\n    \");\n        };\n        return ReactiveErrors;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$9 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formControlBinding$1 = {\n        provide: NgControl,\n        useExisting: _angular_core.forwardRef(function () { return FormControlDirective; })\n    };\n    /**\n     * @whatItDoes Syncs a standalone {@link FormControl} instance to a form control element.\n     *\n     * In other words, this directive ensures that any values written to the {@link FormControl}\n     * instance programmatically will be written to the DOM element (model -> view). Conversely,\n     * any values written to the DOM element through user input will be reflected in the\n     * {@link FormControl} instance (view -> model).\n     *\n     * @howToUse\n     *\n     * Use this directive if you'd like to create and manage a {@link FormControl} instance directly.\n     * Simply create a {@link FormControl}, save it to your component class, and pass it into the\n     * {@link FormControlDirective}.\n     *\n     * This directive is designed to be used as a standalone control.  Unlike {@link FormControlName},\n     * it does not require that your {@link FormControl} instance be part of any parent\n     * {@link FormGroup}, and it won't be registered to any {@link FormGroupDirective} that\n     * exists above it.\n     *\n     * **Get the value**: the `value` property is always synced and available on the\n     * {@link FormControl} instance. See a full list of available properties in\n     * {@link AbstractControl}.\n     *\n     * **Set the value**: You can pass in an initial value when instantiating the {@link FormControl},\n     * or you can set it programmatically later using {@link AbstractControl.setValue} or\n     * {@link AbstractControl.patchValue}.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the control, you can\n     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to\n     * {@link AbstractControl.statusChanges} to be notified when the validation status is\n     * re-calculated.\n     *\n     * ### Example\n     *\n     * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `ReactiveFormsModule`\n     *\n     *  @stable\n     */\n    var FormControlDirective = (function (_super) {\n        __extends$9(FormControlDirective, _super);\n        function FormControlDirective(validators, asyncValidators, valueAccessors) {\n            _super.call(this);\n            this.update = new EventEmitter();\n            this._rawValidators = validators || [];\n            this._rawAsyncValidators = asyncValidators || [];\n            this.valueAccessor = selectValueAccessor(this, valueAccessors);\n        }\n        Object.defineProperty(FormControlDirective.prototype, \"isDisabled\", {\n            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },\n            enumerable: true,\n            configurable: true\n        });\n        FormControlDirective.prototype.ngOnChanges = function (changes) {\n            if (this._isControlChanged(changes)) {\n                setUpControl(this.form, this);\n                if (this.control.disabled)\n                    this.valueAccessor.setDisabledState(true);\n                this.form.updateValueAndValidity({ emitEvent: false });\n            }\n            if (isPropertyUpdated(changes, this.viewModel)) {\n                this.form.setValue(this.model);\n                this.viewModel = this.model;\n            }\n        };\n        Object.defineProperty(FormControlDirective.prototype, \"path\", {\n            get: function () { return []; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlDirective.prototype, \"validator\", {\n            get: function () { return composeValidators(this._rawValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlDirective.prototype, \"asyncValidator\", {\n            get: function () {\n                return composeAsyncValidators(this._rawAsyncValidators);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlDirective.prototype, \"control\", {\n            get: function () { return this.form; },\n            enumerable: true,\n            configurable: true\n        });\n        FormControlDirective.prototype.viewToModelUpdate = function (newValue) {\n            this.viewModel = newValue;\n            this.update.emit(newValue);\n        };\n        FormControlDirective.prototype._isControlChanged = function (changes) {\n            return StringMapWrapper.contains(changes, 'form');\n        };\n        FormControlDirective.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },\n        ];\n        /** @nocollapse */\n        FormControlDirective.ctorParameters = [\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },\n        ];\n        FormControlDirective.propDecorators = {\n            'form': [{ type: _angular_core.Input, args: ['formControl',] },],\n            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],\n            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],\n            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],\n        };\n        return FormControlDirective;\n    }(NgControl));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$11 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formDirectiveProvider$1 = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return FormGroupDirective; })\n    };\n    /**\n     * @whatItDoes Binds an existing {@link FormGroup} to a DOM element.\n     *\n     * @howToUse\n     *\n     * This directive accepts an existing {@link FormGroup} instance. It will then use this\n     * {@link FormGroup} instance to match any child {@link FormControl}, {@link FormGroup},\n     * and {@link FormArray} instances to child {@link FormControlName}, {@link FormGroupName},\n     * and {@link FormArrayName} directives.\n     *\n     * **Set value**: You can set the form's initial value when instantiating the\n     * {@link FormGroup}, or you can set it programmatically later using the {@link FormGroup}'s\n     * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue} methods.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe\n     * to the {@link FormGroup}'s {@link AbstractControl.valueChanges} event.  You can also listen to\n     * its {@link AbstractControl.statusChanges} event to be notified when the validation status is\n     * re-calculated.\n     *\n     * ### Example\n     *\n     * In this example, we create form controls for first name and last name.\n     *\n     * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n     *\n     * **npm package**: `@angular/forms`\n     *\n     * **NgModule**: {@link ReactiveFormsModule}\n     *\n     *  @stable\n     */\n    var FormGroupDirective = (function (_super) {\n        __extends$11(FormGroupDirective, _super);\n        function FormGroupDirective(_validators, _asyncValidators) {\n            _super.call(this);\n            this._validators = _validators;\n            this._asyncValidators = _asyncValidators;\n            this._submitted = false;\n            this.directives = [];\n            this.form = null;\n            this.ngSubmit = new EventEmitter();\n        }\n        FormGroupDirective.prototype.ngOnChanges = function (changes) {\n            this._checkFormPresent();\n            if (StringMapWrapper.contains(changes, 'form')) {\n                this._updateValidators();\n                this._updateDomValue();\n                this._updateRegistrations();\n            }\n        };\n        Object.defineProperty(FormGroupDirective.prototype, \"submitted\", {\n            get: function () { return this._submitted; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormGroupDirective.prototype, \"formDirective\", {\n            get: function () { return this; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormGroupDirective.prototype, \"control\", {\n            get: function () { return this.form; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormGroupDirective.prototype, \"path\", {\n            get: function () { return []; },\n            enumerable: true,\n            configurable: true\n        });\n        FormGroupDirective.prototype.addControl = function (dir) {\n            var ctrl = this.form.get(dir.path);\n            setUpControl(ctrl, dir);\n            ctrl.updateValueAndValidity({ emitEvent: false });\n            this.directives.push(dir);\n            return ctrl;\n        };\n        FormGroupDirective.prototype.getControl = function (dir) { return this.form.get(dir.path); };\n        FormGroupDirective.prototype.removeControl = function (dir) { ListWrapper.remove(this.directives, dir); };\n        FormGroupDirective.prototype.addFormGroup = function (dir) {\n            var ctrl = this.form.get(dir.path);\n            setUpFormContainer(ctrl, dir);\n            ctrl.updateValueAndValidity({ emitEvent: false });\n        };\n        FormGroupDirective.prototype.removeFormGroup = function (dir) { };\n        FormGroupDirective.prototype.getFormGroup = function (dir) { return this.form.get(dir.path); };\n        FormGroupDirective.prototype.addFormArray = function (dir) {\n            var ctrl = this.form.get(dir.path);\n            setUpFormContainer(ctrl, dir);\n            ctrl.updateValueAndValidity({ emitEvent: false });\n        };\n        FormGroupDirective.prototype.removeFormArray = function (dir) { };\n        FormGroupDirective.prototype.getFormArray = function (dir) { return this.form.get(dir.path); };\n        FormGroupDirective.prototype.updateModel = function (dir, value) {\n            var ctrl = this.form.get(dir.path);\n            ctrl.setValue(value);\n        };\n        FormGroupDirective.prototype.onSubmit = function () {\n            this._submitted = true;\n            this.ngSubmit.emit(null);\n            return false;\n        };\n        FormGroupDirective.prototype.onReset = function () { this.resetForm(); };\n        FormGroupDirective.prototype.resetForm = function (value) {\n            if (value === void 0) { value = undefined; }\n            this.form.reset(value);\n            this._submitted = false;\n        };\n        /** @internal */\n        FormGroupDirective.prototype._updateDomValue = function () {\n            var _this = this;\n            this.directives.forEach(function (dir) {\n                var newCtrl = _this.form.get(dir.path);\n                if (dir._control !== newCtrl) {\n                    cleanUpControl(dir._control, dir);\n                    if (newCtrl)\n                        setUpControl(newCtrl, dir);\n                    dir._control = newCtrl;\n                }\n            });\n            this.form._updateTreeValidity({ emitEvent: false });\n        };\n        FormGroupDirective.prototype._updateRegistrations = function () {\n            var _this = this;\n            this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });\n            if (this._oldForm)\n                this._oldForm._registerOnCollectionChange(function () { });\n            this._oldForm = this.form;\n        };\n        FormGroupDirective.prototype._updateValidators = function () {\n            var sync = composeValidators(this._validators);\n            this.form.validator = Validators.compose([this.form.validator, sync]);\n            var async = composeAsyncValidators(this._asyncValidators);\n            this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);\n        };\n        FormGroupDirective.prototype._checkFormPresent = function () {\n            if (isBlank(this.form)) {\n                ReactiveErrors.missingFormException();\n            }\n        };\n        FormGroupDirective.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[formGroup]',\n                        providers: [formDirectiveProvider$1],\n                        host: { '(submit)': 'onSubmit()', '(reset)': 'onReset()' },\n                        exportAs: 'ngForm'\n                    },] },\n        ];\n        /** @nocollapse */\n        FormGroupDirective.ctorParameters = [\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        FormGroupDirective.propDecorators = {\n            'form': [{ type: _angular_core.Input, args: ['formGroup',] },],\n            'ngSubmit': [{ type: _angular_core.Output },],\n        };\n        return FormGroupDirective;\n    }(ControlContainer));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$12 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formGroupNameProvider = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return FormGroupName; })\n    };\n    /**\n     * @whatItDoes Syncs a nested {@link FormGroup} to a DOM element.\n     *\n     * @howToUse\n     *\n     * This directive can only be used with a parent {@link FormGroupDirective} (selector:\n     * `[formGroup]`).\n     *\n     * It accepts the string name of the nested {@link FormGroup} you want to link, and\n     * will look for a {@link FormGroup} registered with that name in the parent\n     * {@link FormGroup} instance you passed into {@link FormGroupDirective}.\n     *\n     * Nested form groups can come in handy when you want to validate a sub-group of a\n     * form separately from the rest or when you'd like to group the values of certain\n     * controls into their own nested object.\n     *\n     * **Access the group**: You can access the associated {@link FormGroup} using the\n     * {@link AbstractControl.get} method. Ex: `this.form.get('name')`.\n     *\n     * You can also access individual controls within the group using dot syntax.\n     * Ex: `this.form.get('name.first')`\n     *\n     * **Get the value**: the `value` property is always synced and available on the\n     * {@link FormGroup}. See a full list of available properties in {@link AbstractControl}.\n     *\n     * **Set the value**: You can set an initial value for each child control when instantiating\n     * the {@link FormGroup}, or you can set it programmatically later using\n     * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the group, you can\n     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to\n     * {@link AbstractControl.statusChanges} to be notified when the validation status is\n     * re-calculated.\n     *\n     * ### Example\n     *\n     * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `ReactiveFormsModule`\n     *\n     * @stable\n     */\n    var FormGroupName = (function (_super) {\n        __extends$12(FormGroupName, _super);\n        function FormGroupName(parent, validators, asyncValidators) {\n            _super.call(this);\n            this._parent = parent;\n            this._validators = validators;\n            this._asyncValidators = asyncValidators;\n        }\n        /** @internal */\n        FormGroupName.prototype._checkParentType = function () {\n            if (_hasInvalidParent(this._parent)) {\n                ReactiveErrors.groupParentException();\n            }\n        };\n        FormGroupName.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },\n        ];\n        /** @nocollapse */\n        FormGroupName.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        FormGroupName.propDecorators = {\n            'name': [{ type: _angular_core.Input, args: ['formGroupName',] },],\n        };\n        return FormGroupName;\n    }(AbstractFormGroupDirective));\n    var formArrayNameProvider = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return FormArrayName; })\n    };\n    /**\n     * @whatItDoes Syncs a nested {@link FormArray} to a DOM element.\n     *\n     * @howToUse\n     *\n     * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:\n     * `[formGroup]`).\n     *\n     * It accepts the string name of the nested {@link FormArray} you want to link, and\n     * will look for a {@link FormArray} registered with that name in the parent\n     * {@link FormGroup} instance you passed into {@link FormGroupDirective}.\n     *\n     * Nested form arrays can come in handy when you have a group of form controls but\n     * you're not sure how many there will be. Form arrays allow you to create new\n     * form controls dynamically.\n     *\n     * **Access the array**: You can access the associated {@link FormArray} using the\n     * {@link AbstractControl.get} method on the parent {@link FormGroup}.\n     * Ex: `this.form.get('cities')`.\n     *\n     * **Get the value**: the `value` property is always synced and available on the\n     * {@link FormArray}. See a full list of available properties in {@link AbstractControl}.\n     *\n     * **Set the value**: You can set an initial value for each child control when instantiating\n     * the {@link FormArray}, or you can set the value programmatically later using the\n     * {@link FormArray}'s {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}\n     * methods.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the array, you can\n     * subscribe to the {@link FormArray}'s {@link AbstractControl.valueChanges} event.  You can also\n     * listen to its {@link AbstractControl.statusChanges} event to be notified when the validation\n     * status is re-calculated.\n     *\n     * **Add new controls**: You can add new controls to the {@link FormArray} dynamically by\n     * calling its {@link FormArray.push} method.\n     *  Ex: `this.form.get('cities').push(new FormControl());`\n     *\n     * ### Example\n     *\n     * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `ReactiveFormsModule`\n     *\n     * @stable\n     */\n    var FormArrayName = (function (_super) {\n        __extends$12(FormArrayName, _super);\n        function FormArrayName(parent, validators, asyncValidators) {\n            _super.call(this);\n            this._parent = parent;\n            this._validators = validators;\n            this._asyncValidators = asyncValidators;\n        }\n        FormArrayName.prototype.ngOnInit = function () {\n            this._checkParentType();\n            this.formDirective.addFormArray(this);\n        };\n        FormArrayName.prototype.ngOnDestroy = function () {\n            if (this.formDirective) {\n                this.formDirective.removeFormArray(this);\n            }\n        };\n        Object.defineProperty(FormArrayName.prototype, \"control\", {\n            get: function () { return this.formDirective.getFormArray(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormArrayName.prototype, \"formDirective\", {\n            get: function () {\n                return this._parent ? this._parent.formDirective : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormArrayName.prototype, \"path\", {\n            get: function () { return controlPath(this.name, this._parent); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormArrayName.prototype, \"validator\", {\n            get: function () { return composeValidators(this._validators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormArrayName.prototype, \"asyncValidator\", {\n            get: function () { return composeAsyncValidators(this._asyncValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        FormArrayName.prototype._checkParentType = function () {\n            if (_hasInvalidParent(this._parent)) {\n                ReactiveErrors.arrayParentException();\n            }\n        };\n        FormArrayName.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },\n        ];\n        /** @nocollapse */\n        FormArrayName.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        FormArrayName.propDecorators = {\n            'name': [{ type: _angular_core.Input, args: ['formArrayName',] },],\n        };\n        return FormArrayName;\n    }(ControlContainer));\n    function _hasInvalidParent(parent) {\n        return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&\n            !(parent instanceof FormArrayName);\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$10 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var controlNameBinding = {\n        provide: NgControl,\n        useExisting: _angular_core.forwardRef(function () { return FormControlName; })\n    };\n    /**\n     * @whatItDoes  Syncs a {@link FormControl} in an existing {@link FormGroup} to a form control\n     * element by name.\n     *\n     * In other words, this directive ensures that any values written to the {@link FormControl}\n     * instance programmatically will be written to the DOM element (model -> view). Conversely,\n     * any values written to the DOM element through user input will be reflected in the\n     * {@link FormControl} instance (view -> model).\n     *\n     * @howToUse\n     *\n     * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:\n     * `[formGroup]`).\n     *\n     * It accepts the string name of the {@link FormControl} instance you want to\n     * link, and will look for a {@link FormControl} registered with that name in the\n     * closest {@link FormGroup} or {@link FormArray} above it.\n     *\n     * **Access the control**: You can access the {@link FormControl} associated with\n     * this directive by using the {@link AbstractControl.get} method.\n     * Ex: `this.form.get('first');`\n     *\n     * **Get value**: the `value` property is always synced and available on the {@link FormControl}.\n     * See a full list of available properties in {@link AbstractControl}.\n     *\n     *  **Set value**: You can set an initial value for the control when instantiating the\n     *  {@link FormControl}, or you can set it programmatically later using\n     *  {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the control, you can\n     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to\n     * {@link AbstractControl.statusChanges} to be notified when the validation status is\n     * re-calculated.\n     *\n     * ### Example\n     *\n     * In this example, we create form controls for first name and last name.\n     *\n     * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n     *\n     *  * **npm package**: `@angular/forms`\n     *\n     *  * **NgModule**: {@link ReactiveFormsModule}\n     *\n     *  @stable\n     */\n    var FormControlName = (function (_super) {\n        __extends$10(FormControlName, _super);\n        function FormControlName(parent, validators, asyncValidators, valueAccessors) {\n            _super.call(this);\n            this._added = false;\n            this.update = new EventEmitter();\n            this._parent = parent;\n            this._rawValidators = validators || [];\n            this._rawAsyncValidators = asyncValidators || [];\n            this.valueAccessor = selectValueAccessor(this, valueAccessors);\n        }\n        Object.defineProperty(FormControlName.prototype, \"isDisabled\", {\n            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },\n            enumerable: true,\n            configurable: true\n        });\n        FormControlName.prototype.ngOnChanges = function (changes) {\n            if (!this._added)\n                this._setUpControl();\n            if (isPropertyUpdated(changes, this.viewModel)) {\n                this.viewModel = this.model;\n                this.formDirective.updateModel(this, this.model);\n            }\n        };\n        FormControlName.prototype.ngOnDestroy = function () {\n            if (this.formDirective) {\n                this.formDirective.removeControl(this);\n            }\n        };\n        FormControlName.prototype.viewToModelUpdate = function (newValue) {\n            this.viewModel = newValue;\n            this.update.emit(newValue);\n        };\n        Object.defineProperty(FormControlName.prototype, \"path\", {\n            get: function () { return controlPath(this.name, this._parent); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlName.prototype, \"formDirective\", {\n            get: function () { return this._parent ? this._parent.formDirective : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlName.prototype, \"validator\", {\n            get: function () { return composeValidators(this._rawValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlName.prototype, \"asyncValidator\", {\n            get: function () {\n                return composeAsyncValidators(this._rawAsyncValidators);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlName.prototype, \"control\", {\n            get: function () { return this._control; },\n            enumerable: true,\n            configurable: true\n        });\n        FormControlName.prototype._checkParentType = function () {\n            if (!(this._parent instanceof FormGroupName) &&\n                this._parent instanceof AbstractFormGroupDirective) {\n                ReactiveErrors.ngModelGroupException();\n            }\n            else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&\n                !(this._parent instanceof FormArrayName)) {\n                ReactiveErrors.controlParentException();\n            }\n        };\n        FormControlName.prototype._setUpControl = function () {\n            this._checkParentType();\n            this._control = this.formDirective.addControl(this);\n            if (this.control.disabled)\n                this.valueAccessor.setDisabledState(true);\n            this._added = true;\n        };\n        FormControlName.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },\n        ];\n        /** @nocollapse */\n        FormControlName.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },\n        ];\n        FormControlName.propDecorators = {\n            'name': [{ type: _angular_core.Input, args: ['formControlName',] },],\n            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],\n            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],\n            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],\n        };\n        return FormControlName;\n    }(NgControl));\n\n    var REQUIRED_VALIDATOR = {\n        provide: NG_VALIDATORS,\n        useExisting: _angular_core.forwardRef(function () { return RequiredValidator; }),\n        multi: true\n    };\n    /**\n     * A Directive that adds the `required` validator to any controls marked with the\n     * `required` attribute, via the {@link NG_VALIDATORS} binding.\n     *\n     * ### Example\n     *\n     * ```\n     * <input name=\"fullName\" ngModel required>\n     * ```\n     *\n     * @stable\n     */\n    var RequiredValidator = (function () {\n        function RequiredValidator() {\n        }\n        Object.defineProperty(RequiredValidator.prototype, \"required\", {\n            get: function () { return this._required; },\n            set: function (value) {\n                this._required = isPresent(value) && \"\" + value !== 'false';\n                if (this._onChange)\n                    this._onChange();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RequiredValidator.prototype.validate = function (c) {\n            return this.required ? Validators.required(c) : null;\n        };\n        RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };\n        RequiredValidator.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[required][formControlName],[required][formControl],[required][ngModel]',\n                        providers: [REQUIRED_VALIDATOR],\n                        host: { '[attr.required]': 'required? \"\" : null' }\n                    },] },\n        ];\n        /** @nocollapse */\n        RequiredValidator.ctorParameters = [];\n        RequiredValidator.propDecorators = {\n            'required': [{ type: _angular_core.Input },],\n        };\n        return RequiredValidator;\n    }());\n    /**\n     * Provider which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.\n     *\n     * ## Example:\n     *\n     * {@example common/forms/ts/validators/validators.ts region='min'}\n     */\n    var MIN_LENGTH_VALIDATOR = {\n        provide: NG_VALIDATORS,\n        useExisting: _angular_core.forwardRef(function () { return MinLengthValidator; }),\n        multi: true\n    };\n    /**\n     * A directive which installs the {@link MinLengthValidator} for any `formControlName`,\n     * `formControl`, or control with `ngModel` that also has a `minlength` attribute.\n     *\n     * @stable\n     */\n    var MinLengthValidator = (function () {\n        function MinLengthValidator() {\n        }\n        MinLengthValidator.prototype._createValidator = function () {\n            this._validator = Validators.minLength(parseInt(this.minlength, 10));\n        };\n        MinLengthValidator.prototype.ngOnChanges = function (changes) {\n            if (changes['minlength']) {\n                this._createValidator();\n                if (this._onChange)\n                    this._onChange();\n            }\n        };\n        MinLengthValidator.prototype.validate = function (c) {\n            return isPresent(this.minlength) ? this._validator(c) : null;\n        };\n        MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };\n        MinLengthValidator.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',\n                        providers: [MIN_LENGTH_VALIDATOR],\n                        host: { '[attr.minlength]': 'minlength? minlength : null' }\n                    },] },\n        ];\n        /** @nocollapse */\n        MinLengthValidator.ctorParameters = [];\n        MinLengthValidator.propDecorators = {\n            'minlength': [{ type: _angular_core.Input },],\n        };\n        return MinLengthValidator;\n    }());\n    /**\n     * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.\n     *\n     * ## Example:\n     *\n     * {@example common/forms/ts/validators/validators.ts region='max'}\n     */\n    var MAX_LENGTH_VALIDATOR = {\n        provide: NG_VALIDATORS,\n        useExisting: _angular_core.forwardRef(function () { return MaxLengthValidator; }),\n        multi: true\n    };\n    /**\n     * A directive which installs the {@link MaxLengthValidator} for any `formControlName,\n     * `formControl`,\n     * or control with `ngModel` that also has a `maxlength` attribute.\n     *\n     * @stable\n     */\n    var MaxLengthValidator = (function () {\n        function MaxLengthValidator() {\n        }\n        MaxLengthValidator.prototype._createValidator = function () {\n            this._validator = Validators.maxLength(parseInt(this.maxlength, 10));\n        };\n        MaxLengthValidator.prototype.ngOnChanges = function (changes) {\n            if (changes['maxlength']) {\n                this._createValidator();\n                if (this._onChange)\n                    this._onChange();\n            }\n        };\n        MaxLengthValidator.prototype.validate = function (c) {\n            return isPresent(this.maxlength) ? this._validator(c) : null;\n        };\n        MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };\n        MaxLengthValidator.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',\n                        providers: [MAX_LENGTH_VALIDATOR],\n                        host: { '[attr.maxlength]': 'maxlength? maxlength : null' }\n                    },] },\n        ];\n        /** @nocollapse */\n        MaxLengthValidator.ctorParameters = [];\n        MaxLengthValidator.propDecorators = {\n            'maxlength': [{ type: _angular_core.Input },],\n        };\n        return MaxLengthValidator;\n    }());\n    var PATTERN_VALIDATOR = {\n        provide: NG_VALIDATORS,\n        useExisting: _angular_core.forwardRef(function () { return PatternValidator; }),\n        multi: true\n    };\n    /**\n     * A Directive that adds the `pattern` validator to any controls marked with the\n     * `pattern` attribute, via the {@link NG_VALIDATORS} binding. Uses attribute value\n     * as the regex to validate Control value against.  Follows pattern attribute\n     * semantics; i.e. regex must match entire Control value.\n     *\n     * ### Example\n     *\n     * ```\n     * <input [name]=\"fullName\" pattern=\"[a-zA-Z ]*\" ngModel>\n     * ```\n     * @stable\n     */\n    var PatternValidator = (function () {\n        function PatternValidator() {\n        }\n        PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };\n        PatternValidator.prototype.ngOnChanges = function (changes) {\n            if (changes['pattern']) {\n                this._createValidator();\n                if (this._onChange)\n                    this._onChange();\n            }\n        };\n        PatternValidator.prototype.validate = function (c) {\n            return isPresent(this.pattern) ? this._validator(c) : null;\n        };\n        PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };\n        PatternValidator.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',\n                        providers: [PATTERN_VALIDATOR],\n                        host: { '[attr.pattern]': 'pattern? pattern : null' }\n                    },] },\n        ];\n        /** @nocollapse */\n        PatternValidator.ctorParameters = [];\n        PatternValidator.propDecorators = {\n            'pattern': [{ type: _angular_core.Input },],\n        };\n        return PatternValidator;\n    }());\n\n    /**\n     * @whatItDoes Creates an {@link AbstractControl} from a user-specified configuration.\n     *\n     * It is essentially syntactic sugar that shortens the `new FormGroup()`,\n     * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger\n     * forms.\n     *\n     * @howToUse\n     *\n     * To use, inject `FormBuilder` into your component class. You can then call its methods\n     * directly.\n     *\n     * {@example forms/ts/formBuilder/form_builder_example.ts region='Component'}\n     *\n     *  * **npm package**: `@angular/forms`\n     *\n     *  * **NgModule**: {@link ReactiveFormsModule}\n     *\n     * @stable\n     */\n    var FormBuilder = (function () {\n        function FormBuilder() {\n        }\n        /**\n         * Construct a new {@link FormGroup} with the given map of configuration.\n         * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.\n         *\n         * See the {@link FormGroup} constructor for more details.\n         */\n        FormBuilder.prototype.group = function (controlsConfig, extra) {\n            if (extra === void 0) { extra = null; }\n            var controls = this._reduceControls(controlsConfig);\n            var validator = isPresent(extra) ? StringMapWrapper.get(extra, 'validator') : null;\n            var asyncValidator = isPresent(extra) ? StringMapWrapper.get(extra, 'asyncValidator') : null;\n            return new FormGroup(controls, validator, asyncValidator);\n        };\n        /**\n         * Construct a new {@link FormControl} with the given `formState`,`validator`, and\n         * `asyncValidator`.\n         *\n         * `formState` can either be a standalone value for the form control or an object\n         * that contains both a value and a disabled status.\n         *\n         */\n        FormBuilder.prototype.control = function (formState, validator, asyncValidator) {\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            return new FormControl(formState, validator, asyncValidator);\n        };\n        /**\n         * Construct a {@link FormArray} from the given `controlsConfig` array of\n         * configuration, with the given optional `validator` and `asyncValidator`.\n         */\n        FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {\n            var _this = this;\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            var controls = controlsConfig.map(function (c) { return _this._createControl(c); });\n            return new FormArray(controls, validator, asyncValidator);\n        };\n        /** @internal */\n        FormBuilder.prototype._reduceControls = function (controlsConfig) {\n            var _this = this;\n            var controls = {};\n            StringMapWrapper.forEach(controlsConfig, function (controlConfig, controlName) {\n                controls[controlName] = _this._createControl(controlConfig);\n            });\n            return controls;\n        };\n        /** @internal */\n        FormBuilder.prototype._createControl = function (controlConfig) {\n            if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||\n                controlConfig instanceof FormArray) {\n                return controlConfig;\n            }\n            else if (isArray(controlConfig)) {\n                var value = controlConfig[0];\n                var validator = controlConfig.length > 1 ? controlConfig[1] : null;\n                var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;\n                return this.control(value, validator, asyncValidator);\n            }\n            else {\n                return this.control(controlConfig);\n            }\n        };\n        FormBuilder.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        FormBuilder.ctorParameters = [];\n        return FormBuilder;\n    }());\n\n    var SHARED_FORM_DIRECTIVES = [\n        NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor,\n        CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor,\n        RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator,\n        MinLengthValidator, MaxLengthValidator, PatternValidator\n    ];\n    var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];\n    var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];\n    /**\n     * Internal module used for sharing directives between FormsModule and ReactiveFormsModule\n     */\n    var InternalFormsSharedModule = (function () {\n        function InternalFormsSharedModule() {\n        }\n        InternalFormsSharedModule.decorators = [\n            { type: _angular_core.NgModule, args: [{ declarations: SHARED_FORM_DIRECTIVES, exports: SHARED_FORM_DIRECTIVES },] },\n        ];\n        /** @nocollapse */\n        InternalFormsSharedModule.ctorParameters = [];\n        return InternalFormsSharedModule;\n    }());\n\n    /**\n     * The ng module for forms.\n     * @stable\n     */\n    var FormsModule = (function () {\n        function FormsModule() {\n        }\n        FormsModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        declarations: TEMPLATE_DRIVEN_DIRECTIVES,\n                        providers: [RadioControlRegistry],\n                        exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]\n                    },] },\n        ];\n        /** @nocollapse */\n        FormsModule.ctorParameters = [];\n        return FormsModule;\n    }());\n    /**\n     * The ng module for reactive forms.\n     * @stable\n     */\n    var ReactiveFormsModule = (function () {\n        function ReactiveFormsModule() {\n        }\n        ReactiveFormsModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        declarations: [REACTIVE_DRIVEN_DIRECTIVES],\n                        providers: [FormBuilder, RadioControlRegistry],\n                        exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]\n                    },] },\n        ];\n        /** @nocollapse */\n        ReactiveFormsModule.ctorParameters = [];\n        return ReactiveFormsModule;\n    }());\n\n    exports.AbstractControlDirective = AbstractControlDirective;\n    exports.AbstractFormGroupDirective = AbstractFormGroupDirective;\n    exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;\n    exports.ControlContainer = ControlContainer;\n    exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;\n    exports.DefaultValueAccessor = DefaultValueAccessor;\n    exports.NgControl = NgControl;\n    exports.NgControlStatus = NgControlStatus;\n    exports.NgControlStatusGroup = NgControlStatusGroup;\n    exports.NgForm = NgForm;\n    exports.NgModel = NgModel;\n    exports.NgModelGroup = NgModelGroup;\n    exports.FormControlDirective = FormControlDirective;\n    exports.FormControlName = FormControlName;\n    exports.FormGroupDirective = FormGroupDirective;\n    exports.FormArrayName = FormArrayName;\n    exports.FormGroupName = FormGroupName;\n    exports.NgSelectOption = NgSelectOption;\n    exports.SelectControlValueAccessor = SelectControlValueAccessor;\n    exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;\n    exports.MaxLengthValidator = MaxLengthValidator;\n    exports.MinLengthValidator = MinLengthValidator;\n    exports.PatternValidator = PatternValidator;\n    exports.RequiredValidator = RequiredValidator;\n    exports.FormBuilder = FormBuilder;\n    exports.AbstractControl = AbstractControl;\n    exports.FormArray = FormArray;\n    exports.FormControl = FormControl;\n    exports.FormGroup = FormGroup;\n    exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;\n    exports.NG_VALIDATORS = NG_VALIDATORS;\n    exports.Validators = Validators;\n    exports.FormsModule = FormsModule;\n    exports.ReactiveFormsModule = ReactiveFormsModule;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L0Bhbmd1bGFyL2Zvcm1zL2J1bmRsZXMvZm9ybXMudW1kLmpzPzkxMjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5Q0FBeUM7QUFDbEYsQ0FBQywwSEFBMEg7O0FBRTNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtDQUFrQztBQUN4Rix3REFBd0QsNEJBQTRCO0FBQ3BGLG9EQUFvRCx3QkFBd0I7QUFDNUUsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUMsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdURBQXVELGdDQUFnQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjIuMC4wXG4gKiAoYykgMjAxMC0yMDE2IEdvb2dsZSwgSW5jLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgncnhqcy9vcGVyYXRvci90b1Byb21pc2UnKSwgcmVxdWlyZSgncnhqcy9TdWJqZWN0JyksIHJlcXVpcmUoJ3J4anMvT2JzZXJ2YWJsZScpLCByZXF1aXJlKCdyeGpzL29ic2VydmFibGUvZnJvbVByb21pc2UnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGFuZ3VsYXIvY29yZScsICdyeGpzL29wZXJhdG9yL3RvUHJvbWlzZScsICdyeGpzL1N1YmplY3QnLCAncnhqcy9PYnNlcnZhYmxlJywgJ3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZSddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbC5uZyA9IGdsb2JhbC5uZyB8fCB7fSwgZ2xvYmFsLm5nLmZvcm1zID0gZ2xvYmFsLm5nLmZvcm1zIHx8IHt9KSxnbG9iYWwubmcuY29yZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4LGdsb2JhbC5SeCxnbG9iYWwuUnguT2JzZXJ2YWJsZSkpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlLHJ4anNfb3BlcmF0b3JfdG9Qcm9taXNlLHJ4anNfU3ViamVjdCxyeGpzX09ic2VydmFibGUscnhqc19vYnNlcnZhYmxlX2Zyb21Qcm9taXNlKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgZ2xvYmFsU2NvcGU7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBhbnkgd2l0aCBXb3JrZXJHbG9iYWxTY29wZSBmcm9tIGxpYi53ZWJ3b3JrZXIuZC50cyAjMzQ5MlxuICAgICAgICAgICAgZ2xvYmFsU2NvcGUgPSBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsU2NvcGUgPSBnbG9iYWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbFNjb3BlID0gd2luZG93O1xuICAgIH1cbiAgICAvLyBOZWVkIHRvIGRlY2xhcmUgYSBuZXcgdmFyaWFibGUgZm9yIGdsb2JhbCBoZXJlIHNpbmNlIFR5cGVTY3JpcHRcbiAgICAvLyBleHBvcnRzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgc3ltYm9sLlxuICAgIHZhciBnbG9iYWwkMSA9IGdsb2JhbFNjb3BlO1xuICAgIC8vIFRPRE86IHJlbW92ZSBjYWxscyB0byBhc3NlcnQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudFxuICAgIC8vIE5vdGU6IENhbid0IGp1c3QgZXhwb3J0IHRoaXMgYW5kIGltcG9ydCBpbiBpbiBvdGhlciBmaWxlc1xuICAgIC8vIGFzIGBhc3NlcnRgIGlzIGEgcmVzZXJ2ZWQga2V5d29yZCBpbiBEYXJ0XG4gICAgZ2xvYmFsJDEuYXNzZXJ0ID0gZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAvLyBUT0RPOiB0byBiZSBmaXhlZCBwcm9wZXJseSB2aWEgIzI4MzAsIG5vb3AgZm9yIG5vd1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0JsYW5rKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTdHJpbmdNYXAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgICAgICAgLy8gYWxsb3cgYW55IFByb21pc2UvQSsgY29tcGxpYW50IHRoZW5hYmxlLlxuICAgICAgICAvLyBJdCdzIHVwIHRvIHRoZSBjYWxsZXIgdG8gZW5zdXJlIHRoYXQgb2JqLnRoZW4gY29uZm9ybXMgdG8gdGhlIHNwZWNcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChvYmopICYmIGlzRnVuY3Rpb24ob2JqLnRoZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xuICAgIH1cbiAgICB2YXIgU3RyaW5nV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ1dyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU3RyaW5nV3JhcHBlci5mcm9tQ2hhckNvZGUgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTsgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5jaGFyQ29kZUF0ID0gZnVuY3Rpb24gKHMsIGluZGV4KSB7IHJldHVybiBzLmNoYXJDb2RlQXQoaW5kZXgpOyB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLnNwbGl0ID0gZnVuY3Rpb24gKHMsIHJlZ0V4cCkgeyByZXR1cm4gcy5zcGxpdChyZWdFeHApOyB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChzLCBzMikgeyByZXR1cm4gcyA9PT0gczI7IH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBMZWZ0ID0gZnVuY3Rpb24gKHMsIGNoYXJWYWwpIHtcbiAgICAgICAgICAgIGlmIChzICYmIHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzW2ldICE9IGNoYXJWYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMgPSBzLnN1YnN0cmluZyhwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIuc3RyaXBSaWdodCA9IGZ1bmN0aW9uIChzLCBjaGFyVmFsKSB7XG4gICAgICAgICAgICBpZiAocyAmJiBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPSBjaGFyVmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHBvcy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdXcmFwcGVyLnJlcGxhY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgcmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCByZXBsYWNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHMsIGZyb20sIHJlcGxhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoZnJvbSwgcmVwbGFjZSk7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIuc2xpY2UgPSBmdW5jdGlvbiAocywgZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB2b2lkIDApIHsgZnJvbSA9IDA7IH1cbiAgICAgICAgICAgIGlmICh0byA9PT0gdm9pZCAwKSB7IHRvID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHMuc2xpY2UoZnJvbSwgdG8gPT09IG51bGwgPyB1bmRlZmluZWQgOiB0byk7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIucmVwbGFjZUFsbE1hcHBlZCA9IGZ1bmN0aW9uIChzLCBmcm9tLCBjYikge1xuICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZShmcm9tLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgb2Zmc2V0ICYgc3RyaW5nIGZyb20gdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICAgICAgICAgIG1hdGNoZXMuc3BsaWNlKC0yLCAyKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgcmVjZWl2ZXMgbWF0Y2gsIHAxLCAuLi4sIHBuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKG1hdGNoZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ1dyYXBwZXIuY29udGFpbnMgPSBmdW5jdGlvbiAocywgc3Vic3RyKSB7IHJldHVybiBzLmluZGV4T2Yoc3Vic3RyKSAhPSAtMTsgfTtcbiAgICAgICAgU3RyaW5nV3JhcHBlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ1dyYXBwZXI7XG4gICAgfSgpKTtcbiAgICB2YXIgTnVtYmVyV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE51bWJlcldyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTnVtYmVyV3JhcHBlci50b0ZpeGVkID0gZnVuY3Rpb24gKG4sIGZyYWN0aW9uRGlnaXRzKSB7IHJldHVybiBuLnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMpOyB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT09IGI7IH07XG4gICAgICAgIE51bWJlcldyYXBwZXIucGFyc2VJbnRBdXRvUmFkaXggPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHRleHQpO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJXcmFwcGVyLnBhcnNlSW50ID0gZnVuY3Rpb24gKHRleHQsIHJhZGl4KSB7XG4gICAgICAgICAgICBpZiAocmFkaXggPT0gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/WzAtOV0rJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJhZGl4ID09IDE2KSB7XG4gICAgICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspP1swLTlBQkNERUZhYmNkZWZdKyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRleHQsIHJhZGl4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQodGV4dCwgcmFkaXgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnRlZ2VyIGxpdGVyYWwgd2hlbiBwYXJzaW5nICcgKyB0ZXh0ICsgJyBpbiBiYXNlICcgKyByYWRpeCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdW1iZXJXcmFwcGVyLCBcIk5hTlwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5hTjsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE51bWJlcldyYXBwZXIuaXNOdW1lcmljID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiAhaXNOYU4odmFsdWUgLSBwYXJzZUZsb2F0KHZhbHVlKSk7IH07XG4gICAgICAgIE51bWJlcldyYXBwZXIuaXNOYU4gPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGlzTmFOKHZhbHVlKTsgfTtcbiAgICAgICAgTnVtYmVyV3JhcHBlci5pc0ludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpOyB9O1xuICAgICAgICByZXR1cm4gTnVtYmVyV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIC8vIEpTIGhhcyBOYU4gIT09IE5hTlxuICAgIGZ1bmN0aW9uIGxvb3NlSWRlbnRpY2FsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGIgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBpc05hTihhKSAmJiBpc05hTihiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQm9vbChvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzQmxhbmsob2JqKSA/IGZhbHNlIDogb2JqO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcbiAgICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICByZXR1cm4gIWlzSnNPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzQ29uc3RydWN0b3IodmFsdWUsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yID09PSB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJhc2UgY2xhc3MgZm9yIGNvbnRyb2wgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIE9ubHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoZSBmb3JtcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wudmFsdWUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC52YWxpZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wuaW52YWxpZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wucGVuZGluZyA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLmVycm9ycyA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicHJpc3RpbmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC5wcmlzdGluZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLmRpcnR5IDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvdWNoZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC50b3VjaGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInVudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnVudG91Y2hlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLmRpc2FibGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC5lbmFibGVkIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0YXR1c0NoYW5nZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnN0YXR1c0NoYW5nZXMgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wudmFsdWVDaGFuZ2VzIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY29udHJvbCkpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZGlyZWN0aXZlIHRoYXQgY29udGFpbnMgbXVsdGlwbGUge0BsaW5rIE5nQ29udHJvbH1zLlxuICAgICAqXG4gICAgICogT25seSB1c2VkIGJ5IHRoZSBmb3JtcyBtb2R1bGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENvbnRyb2xDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMShDb250cm9sQ29udGFpbmVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDb250cm9sQ29udGFpbmVyKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGZvcm0gdG8gd2hpY2ggdGhpcyBjb250YWluZXIgYmVsb25ncy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnRyb2xDb250YWluZXIucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHBhdGggdG8gdGhpcyBjb250YWluZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBDb250cm9sQ29udGFpbmVyO1xuICAgIH0oQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKSk7XG5cbiAgICB2YXIgTWFwJDEgPSBnbG9iYWwkMS5NYXA7XG4gICAgdmFyIFNldCA9IGdsb2JhbCQxLlNldDtcbiAgICAvLyBTYWZhcmkgYW5kIEludGVybmV0IEV4cGxvcmVyIGRvIG5vdCBzdXBwb3J0IHRoZSBpdGVyYWJsZSBwYXJhbWV0ZXIgdG8gdGhlXG4gICAgLy8gTWFwIGNvbnN0cnVjdG9yLiAgV2Ugd29yayBhcm91bmQgdGhhdCBieSBtYW51YWxseSBhZGRpbmcgdGhlIGl0ZW1zLlxuICAgIHZhciBjcmVhdGVNYXBGcm9tUGFpcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5ldyBNYXAkMShbWzEsIDJdXSkuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXBGcm9tUGFpcnMocGFpcnMpIHsgcmV0dXJuIG5ldyBNYXAkMShwYWlycyk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwQW5kUG9wdWxhdGVGcm9tUGFpcnMocGFpcnMpIHtcbiAgICAgICAgICAgIHZhciBtYXAgPSBuZXcgTWFwJDEoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgICAgICAgICAgICAgIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgdmFyIGNyZWF0ZU1hcEZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5ldyBNYXAkMShuZXcgTWFwJDEoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwRnJvbU1hcChtKSB7IHJldHVybiBuZXcgTWFwJDEobSk7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWFwQW5kUG9wdWxhdGVGcm9tTWFwKG0pIHtcbiAgICAgICAgICAgIHZhciBtYXAgPSBuZXcgTWFwJDEoKTtcbiAgICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyBtYXAuc2V0KGssIHYpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICB2YXIgX2NsZWFyVmFsdWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKChuZXcgTWFwJDEoKSkua2V5cygpLm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBfY2xlYXJWYWx1ZXMobSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlJdGVyYXRvciA9IG0ua2V5cygpO1xuICAgICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICAgIHdoaWxlICghKChrID0ga2V5SXRlcmF0b3IubmV4dCgpKS5kb25lKSkge1xuICAgICAgICAgICAgICAgICAgICBtLnNldChrLnZhbHVlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIF9jbGVhclZhbHVlc1dpdGhGb3JlRWFjaChtKSB7XG4gICAgICAgICAgICAgICAgbS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7IG0uc2V0KGssIG51bGwpOyB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIC8vIFNhZmFyaSBkb2Vzbid0IGltcGxlbWVudCBNYXBJdGVyYXRvci5uZXh0KCksIHdoaWNoIGlzIHVzZWQgaXMgVHJhY2V1cidzIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICAvLyBUT0RPKG1sYXZhbCk6IHJlbW92ZSB0aGUgd29yayBhcm91bmQgb25jZSB3ZSBoYXZlIGEgd29ya2luZyBwb2x5ZmlsbCBvZiBBcnJheS5mcm9tXG4gICAgdmFyIF9hcnJheUZyb21NYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKChuZXcgTWFwJDEoKSkudmFsdWVzKCkubmV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXAobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZXMgPyBBcnJheS5mcm9tKG0udmFsdWVzKCkpIDogQXJyYXkuZnJvbShtLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXBXaXRoRm9yZWFjaChtLCBnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBMaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUobS5zaXplKSwgaSA9IDA7XG4gICAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBnZXRWYWx1ZXMgPyB2IDogaztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICB2YXIgTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTWFwV3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBjcmVhdGVNYXBGcm9tTWFwKG0pOyB9O1xuICAgICAgICBNYXBXcmFwcGVyLmNyZWF0ZUZyb21TdHJpbmdNYXAgPSBmdW5jdGlvbiAoc3RyaW5nTWFwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IE1hcCQxKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0cmluZ01hcCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQocHJvcCwgc3RyaW5nTWFwW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIE1hcFdyYXBwZXIudG9TdHJpbmdNYXAgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgdmFyIHIgPSB7fTtcbiAgICAgICAgICAgIG0uZm9yRWFjaChmdW5jdGlvbiAodiwgaykgeyByZXR1cm4gcltrXSA9IHY7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH07XG4gICAgICAgIE1hcFdyYXBwZXIuY3JlYXRlRnJvbVBhaXJzID0gZnVuY3Rpb24gKHBhaXJzKSB7IHJldHVybiBjcmVhdGVNYXBGcm9tUGFpcnMocGFpcnMpOyB9O1xuICAgICAgICBNYXBXcmFwcGVyLmNsZWFyVmFsdWVzID0gZnVuY3Rpb24gKG0pIHsgX2NsZWFyVmFsdWVzKG0pOyB9O1xuICAgICAgICBNYXBXcmFwcGVyLml0ZXJhYmxlID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG07IH07XG4gICAgICAgIE1hcFdyYXBwZXIua2V5cyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBfYXJyYXlGcm9tTWFwKG0sIGZhbHNlKTsgfTtcbiAgICAgICAgTWFwV3JhcHBlci52YWx1ZXMgPSBmdW5jdGlvbiAobSkgeyByZXR1cm4gX2FycmF5RnJvbU1hcChtLCB0cnVlKTsgfTtcbiAgICAgICAgcmV0dXJuIE1hcFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBKYXZhc2NyaXB0IE9iamVjdHNcbiAgICAgKi9cbiAgICB2YXIgU3RyaW5nTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ01hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBhcmUgbm90IHVzaW5nIE9iamVjdC5jcmVhdGUobnVsbCkgaGVyZSBkdWUgdG9cbiAgICAgICAgICAgIC8vIHBlcmZvcm1hbmNlIVxuICAgICAgICAgICAgLy8gaHR0cDovL2pzcGVyZi5jb20vbmcyLW9iamVjdC1jcmVhdGUtbnVsbFxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmNvbnRhaW5zID0gZnVuY3Rpb24gKG1hcCwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZ2V0ID0gZnVuY3Rpb24gKG1hcCwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwLmhhc093blByb3BlcnR5KGtleSkgPyBtYXBba2V5XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5zZXQgPSBmdW5jdGlvbiAobWFwLCBrZXksIHZhbHVlKSB7IG1hcFtrZXldID0gdmFsdWU7IH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIua2V5cyA9IGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7IH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIudmFsdWVzID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrKSB7IHJldHVybiBtYXBba107IH0pO1xuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmlzRW1wdHkgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIG1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmRlbGV0ZSA9IGZ1bmN0aW9uIChtYXAsIGtleSkgeyBkZWxldGUgbWFwW2tleV07IH07XG4gICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZm9yRWFjaCA9IGZ1bmN0aW9uIChtYXAsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMobWFwKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhtYXBba10sIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0xW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IE9iamVjdC5rZXlzKG0yKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgazEgPSBPYmplY3Qua2V5cyhtMSk7XG4gICAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gazFbaV07XG4gICAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIC8vIEpTIGhhcyBubyB3YXkgdG8gZXhwcmVzcyBhIHN0YXRpY2FsbHkgZml4ZWQgc2l6ZSBsaXN0LCBidXQgZGFydCBkb2VzIHNvIHdlXG4gICAgICAgIC8vIGtlZXAgYm90aCBtZXRob2RzLlxuICAgICAgICBMaXN0V3JhcHBlci5jcmVhdGVGaXhlZFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jcmVhdGVHcm93YWJsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkgeyByZXR1cm4gbmV3IEFycmF5KHNpemUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jbG9uZSA9IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXJyYXkuc2xpY2UoMCk7IH07XG4gICAgICAgIExpc3RXcmFwcGVyLmZvckVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbiAoYXJyYXksIGZuKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm4oYXJyYXlbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5maXJzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFhcnJheSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVswXTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIubGFzdCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgaWYgKCFhcnJheSB8fCBhcnJheS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnJheSwgdmFsdWUsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSB2b2lkIDApIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHZhbHVlLCBzdGFydEluZGV4KTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuY29udGFpbnMgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHsgcmV0dXJuIGxpc3QuaW5kZXhPZihlbCkgIT09IC0xOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZXZlcnNlZCA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgdmFyIGEgPSBMaXN0V3JhcHBlci5jbG9uZShhcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYS5yZXZlcnNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmNvbmNhdCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaW5zZXJ0ID0gZnVuY3Rpb24gKGxpc3QsIGluZGV4LCB2YWx1ZSkgeyBsaXN0LnNwbGljZShpbmRleCwgMCwgdmFsdWUpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCA9IGZ1bmN0aW9uIChsaXN0LCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGxpc3RbaW5kZXhdO1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlQWxsID0gZnVuY3Rpb24gKGxpc3QsIGl0ZW1zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZSA9IGZ1bmN0aW9uIChsaXN0LCBlbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGVsKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5jbGVhciA9IGZ1bmN0aW9uIChsaXN0KSB7IGxpc3QubGVuZ3RoID0gMDsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuaXNFbXB0eSA9IGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0Lmxlbmd0aCA9PSAwOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5maWxsID0gZnVuY3Rpb24gKGxpc3QsIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cbiAgICAgICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBudWxsOyB9XG4gICAgICAgICAgICBsaXN0LmZpbGwodmFsdWUsIHN0YXJ0LCBlbmQgPT09IG51bGwgPyBsaXN0Lmxlbmd0aCA6IGVuZCk7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5zbGljZSA9IGZ1bmN0aW9uIChsLCBmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHZvaWQgMCkgeyBmcm9tID0gMDsgfVxuICAgICAgICAgICAgaWYgKHRvID09PSB2b2lkIDApIHsgdG8gPSBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbC5zbGljZShmcm9tLCB0byA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHRvKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc3BsaWNlID0gZnVuY3Rpb24gKGwsIGZyb20sIGxlbmd0aCkgeyByZXR1cm4gbC5zcGxpY2UoZnJvbSwgbGVuZ3RoKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuc29ydCA9IGZ1bmN0aW9uIChsLCBjb21wYXJlRm4pIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcGFyZUZuKSkge1xuICAgICAgICAgICAgICAgIGwuc29ydChjb21wYXJlRm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbC5zb3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLnRvU3RyaW5nID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIudG9KU09OID0gZnVuY3Rpb24gKGwpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGwpOyB9O1xuICAgICAgICBMaXN0V3JhcHBlci5tYXhpbXVtID0gZnVuY3Rpb24gKGxpc3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzb2x1dGlvbiA9IG51bGw7XG4gICAgICAgICAgICB2YXIgbWF4VmFsdWUgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGlzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gbGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxhbmsoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZVZhbHVlID0gcHJlZGljYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVZhbHVlID4gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc29sdXRpb24gPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gY2FuZGlkYXRlVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvbHV0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5mbGF0dGVuID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkobGlzdCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCA9IGZ1bmN0aW9uIChsaXN0LCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHNvdXJjZVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaXN0V3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIGZ1bmN0aW9uIF9mbGF0dGVuQXJyYXkoc291cmNlLCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzb3VyY2UpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mbGF0dGVuQXJyYXkoaXRlbSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvLyBTYWZhcmkgYW5kIEludGVybmV0IEV4cGxvcmVyIGRvIG5vdCBzdXBwb3J0IHRoZSBpdGVyYWJsZSBwYXJhbWV0ZXIgdG8gdGhlXG4gICAgLy8gU2V0IGNvbnN0cnVjdG9yLiAgV2Ugd29yayBhcm91bmQgdGhhdCBieSBtYW51YWxseSBhZGRpbmcgdGhlIGl0ZW1zLlxuICAgIHZhciBjcmVhdGVTZXRGcm9tTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gbmV3IFNldChbMSwgMiwgM10pO1xuICAgICAgICBpZiAodGVzdC5zaXplID09PSAzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2V0RnJvbUxpc3QobHN0KSB7IHJldHVybiBuZXcgU2V0KGxzdCk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2V0QW5kUG9wdWxhdGVGcm9tTGlzdChsc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gbmV3IFNldChsc3QpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMuc2l6ZSAhPT0gbHN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmFkZChsc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyBmb3IgdmFsaWRhdG9ycyB0byBiZSB1c2VkIGZvciB7QGxpbmsgRm9ybUNvbnRyb2x9cyBpbiBhIGZvcm0uXG4gICAgICpcbiAgICAgKiBQcm92aWRlIHRoaXMgdXNpbmcgYG11bHRpOiB0cnVlYCB0byBhZGQgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29yZS9mb3Jtcy90cy9uZ192YWxpZGF0b3JzL25nX3ZhbGlkYXRvcnMudHMgcmVnaW9uPSduZ192YWxpZGF0b3JzJ31cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5HX1ZBTElEQVRPUlMgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignTmdWYWxpZGF0b3JzJyk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXJzIGZvciBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0byBiZSB1c2VkIGZvciB7QGxpbmsgRm9ybUNvbnRyb2x9c1xuICAgICAqIGluIGEgZm9ybS5cbiAgICAgKlxuICAgICAqIFByb3ZpZGUgdGhpcyB1c2luZyBgbXVsdGk6IHRydWVgIHRvIGFkZCB2YWxpZGF0b3JzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBOR19WQUxJREFUT1JTfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOR19BU1lOQ19WQUxJREFUT1JTID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ05nQXN5bmNWYWxpZGF0b3JzJyk7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBzZXQgb2YgdmFsaWRhdG9ycyB1c2VkIGJ5IGZvcm0gY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBBIHZhbGlkYXRvciBpcyBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEge0BsaW5rIEZvcm1Db250cm9sfSBvciBjb2xsZWN0aW9uIG9mXG4gICAgICogY29udHJvbHMgYW5kIHJldHVybnMgYSBtYXAgb2YgZXJyb3JzLiBBIG51bGwgbWFwIG1lYW5zIHRoYXQgdmFsaWRhdGlvbiBoYXMgcGFzc2VkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB2YXIgbG9naW5Db250cm9sID0gbmV3IEZvcm1Db250cm9sKFwiXCIsIFZhbGlkYXRvcnMucmVxdWlyZWQpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFZhbGlkYXRvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBWYWxpZGF0b3JzKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyBjb250cm9scyB0byBoYXZlIGEgbm9uLWVtcHR5IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5yZXF1aXJlZCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCbGFuayhjb250cm9sLnZhbHVlKSB8fCAoaXNTdHJpbmcoY29udHJvbC52YWx1ZSkgJiYgY29udHJvbC52YWx1ZSA9PSAnJykgP1xuICAgICAgICAgICAgICAgIHsgJ3JlcXVpcmVkJzogdHJ1ZSB9IDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWluaW11bSBsZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIChtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5sZW5ndGggPCBtaW5MZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICB7ICdtaW5sZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IG1pbkxlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IHYubGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWF4aW11bSBsZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm1heExlbmd0aCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5sZW5ndGggPiBtYXhMZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICB7ICdtYXhsZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IG1heExlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IHYubGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgYSBjb250cm9sIHRvIG1hdGNoIGEgcmVnZXggdG8gaXRzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5wYXR0ZXJuID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXR0ZXJuICsgXCIkXCIpO1xuICAgICAgICAgICAgICAgIHZhciB2ID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdCh2KSA/IG51bGwgOlxuICAgICAgICAgICAgICAgICAgICB7ICdwYXR0ZXJuJzogeyAncmVxdWlyZWRQYXR0ZXJuJzogXCJeXCIgKyBwYXR0ZXJuICsgXCIkXCIsICdhY3R1YWxWYWx1ZSc6IHYgfSB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vLW9wIHZhbGlkYXRvci5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMubnVsbFZhbGlkYXRvciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9zZSBtdWx0aXBsZSB2YWxpZGF0b3JzIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB1bmlvblxuICAgICAgICAgKiBvZiB0aGUgaW5kaXZpZHVhbCBlcnJvciBtYXBzLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlID0gZnVuY3Rpb24gKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbGlkYXRvcnMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHByZXNlbnRWYWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIoaXNQcmVzZW50KTtcbiAgICAgICAgICAgIGlmIChwcmVzZW50VmFsaWRhdG9ycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfbWVyZ2VFcnJvcnMoX2V4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyA9IGZ1bmN0aW9uICh2YWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayh2YWxpZGF0b3JzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBwcmVzZW50VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMuZmlsdGVyKGlzUHJlc2VudCk7XG4gICAgICAgICAgICBpZiAocHJlc2VudFZhbGlkYXRvcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBfZXhlY3V0ZUFzeW5jVmFsaWRhdG9ycyhjb250cm9sLCBwcmVzZW50VmFsaWRhdG9ycykubWFwKF9jb252ZXJ0VG9Qcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oX21lcmdlRXJyb3JzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBWYWxpZGF0b3JzO1xuICAgIH0oKSk7XG4gICAgZnVuY3Rpb24gX2NvbnZlcnRUb1Byb21pc2Uob2JqKSB7XG4gICAgICAgIHJldHVybiBpc1Byb21pc2Uob2JqKSA/IG9iaiA6IHJ4anNfb3BlcmF0b3JfdG9Qcm9taXNlLnRvUHJvbWlzZS5jYWxsKG9iaik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leGVjdXRlVmFsaWRhdG9ycyhjb250cm9sLCB2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdihjb250cm9sKTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leGVjdXRlQXN5bmNWYWxpZGF0b3JzKGNvbnRyb2wsIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2KGNvbnRyb2wpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX21lcmdlRXJyb3JzKGFycmF5T2ZFcnJvcnMpIHtcbiAgICAgICAgdmFyIHJlcyA9IGFycmF5T2ZFcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChyZXMsIGVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChlcnJvcnMpID8gU3RyaW5nTWFwV3JhcHBlci5tZXJnZShyZXMsIGVycm9ycykgOiByZXM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXIuaXNFbXB0eShyZXMpID8gbnVsbCA6IHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHByb3ZpZGUgYSB7QGxpbmsgQ29udHJvbFZhbHVlQWNjZXNzb3J9IGZvciBmb3JtIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBEZWZhdWx0VmFsdWVBY2Nlc3Nvcn0gZm9yIGhvdyB0byBpbXBsZW1lbnQgb25lLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTkdfVkFMVUVfQUNDRVNTT1IgPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignTmdWYWx1ZUFjY2Vzc29yJyk7XG5cbiAgICB2YXIgQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIG9uIGEgY2hlY2tib3ggaW5wdXQgZWxlbWVudC5cbiAgICAgKlxuICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAqICBgYGBcbiAgICAgKiAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCJyZW1lbWJlckxvZ2luXCIgbmdNb2RlbD5cbiAgICAgKiAgYGBgXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NoZWNrZWQnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPWNoZWNrYm94XVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9Y2hlY2tib3hdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LmNoZWNrZWQpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0NIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIHZhciBERUZBVUxUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBEZWZhdWx0VmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyB0aGF0IGlzIHVzZWQgYnkgdGhlXG4gICAgICoge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge0BsaW5rIEZvcm1Db250cm9sTmFtZX0gZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAqICBgYGBcbiAgICAgKiAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInNlYXJjaFF1ZXJ5XCIgbmdNb2RlbD5cbiAgICAgKiAgYGBgXG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBEZWZhdWx0VmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIERlZmF1bHRWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IGlzQmxhbmsodmFsdWUpID8gJycgOiB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbZm9ybUNvbnRyb2xOYW1lXSx0ZXh0YXJlYVtmb3JtQ29udHJvbE5hbWVdLGlucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW2Zvcm1Db250cm9sXSx0ZXh0YXJlYVtmb3JtQ29udHJvbF0saW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbbmdNb2RlbF0sdGV4dGFyZWFbbmdNb2RlbF0sW25nRGVmYXVsdENvbnRyb2xdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHZzYXZraW4gcmVwbGFjZSB0aGUgYWJvdmUgc2VsZWN0b3Igd2l0aCB0aGUgb25lIGJlbG93IGl0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMwMTEgaXMgaW1wbGVtZW50ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yOiAnW25nQ29udHJvbF0sW25nTW9kZWxdLFtuZ0Zvcm1Db250cm9sXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoaW5wdXQpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0RFRkFVTFRfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAodmFsaWRhdG9yLnZhbGlkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gdmFsaWRhdG9yLnZhbGlkYXRlKGMpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVBc3luY1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRvci52YWxpZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIHZhbGlkYXRvci52YWxpZGF0ZShjKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgTlVNQkVSX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOdW1iZXJWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBhY2Nlc3NvciBmb3Igd3JpdGluZyBhIG51bWJlciB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIHtAbGluayBOZ01vZGVsfSwge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtAbGluayBGb3JtQ29udHJvbE5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgWyhuZ01vZGVsKV09XCJhZ2VcIj5cbiAgICAgKiAgYGBgXG4gICAgICovXG4gICAgdmFyIE51bWJlclZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOdW1iZXJWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdmFsdWUgbmVlZHMgdG8gYmUgbm9ybWFsaXplZCBmb3IgSUU5LCBvdGhlcndpc2UgaXQgaXMgc2V0IHRvICdudWxsJyB3aGVuIG51bGxcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSBpc0JsYW5rKHZhbHVlKSA/ICcnIDogdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCBub3JtYWxpemVkVmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IGZuKHZhbHVlID09ICcnID8gbnVsbCA6IHBhcnNlRmxvYXQodmFsdWUpKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTlVNQkVSX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE51bWJlclZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1bmltcGxlbWVudGVkKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBiYXNlIGNsYXNzIHRoYXQgYWxsIGNvbnRyb2wgZGlyZWN0aXZlIGV4dGVuZC5cbiAgICAgKiBJdCBiaW5kcyBhIHtAbGluayBGb3JtQ29udHJvbH0gb2JqZWN0IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBVc2VkIGludGVybmFsbHkgYnkgQW5ndWxhciBmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDIoTmdDb250cm9sLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ0NvbnRyb2woKSB7XG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2wucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0NvbnRyb2wucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbDtcbiAgICB9KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSkpO1xuXG4gICAgdmFyIFJBRElPX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNsYXNzIHVzZWQgYnkgQW5ndWxhciB0byB1bmNoZWNrIHJhZGlvIGJ1dHRvbnMgd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZS5cbiAgICAgKi9cbiAgICB2YXIgUmFkaW9Db250cm9sUmVnaXN0cnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSYWRpb0NvbnRyb2xSZWdpc3RyeSgpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY29udHJvbCwgYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycy5wdXNoKFtjb250cm9sLCBhY2Nlc3Nvcl0pO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGFjY2Vzc29yKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhUb1JlbW92ZSA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9hY2Nlc3NvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWNjZXNzb3JzW2ldWzFdID09PSBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgICAgICBpbmRleFRvUmVtb3ZlID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCh0aGlzLl9hY2Nlc3NvcnMsIGluZGV4VG9SZW1vdmUpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGFjY2Vzc29yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzU2FtZUdyb3VwKGMsIGFjY2Vzc29yKSAmJiBjWzFdICE9PSBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgICAgICBjWzFdLmZpcmVVbmNoZWNrKGFjY2Vzc29yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLl9pc1NhbWVHcm91cCA9IGZ1bmN0aW9uIChjb250cm9sUGFpciwgYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGlmICghY29udHJvbFBhaXJbMF0uY29udHJvbClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbFBhaXJbMF0uX3BhcmVudCA9PT0gYWNjZXNzb3IuX2NvbnRyb2wuX3BhcmVudCAmJlxuICAgICAgICAgICAgICAgIGNvbnRyb2xQYWlyWzFdLm5hbWUgPT09IGFjY2Vzc29yLm5hbWU7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIFJhZGlvQ29udHJvbFJlZ2lzdHJ5O1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgcmFkaW8gY29udHJvbCB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgdGhhdCBpcyB1c2VkIGJ5IHRoZVxuICAgICAqIHtAbGluayBOZ01vZGVsfSwge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfSwgYW5kIHtAbGluayBGb3JtQ29udHJvbE5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgKiAgYGBgXG4gICAgICogIEBDb21wb25lbnQoe1xuICAgICAqICAgIHRlbXBsYXRlOiBgXG4gICAgICogICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImZvb2RcIiBbKG5nTW9kZWwpXT1cImZvb2RcIiB2YWx1ZT1cImNoaWNrZW5cIj5cbiAgICAgKiAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiZm9vZFwiIFsobmdNb2RlbCldPVwiZm9vZFwiIHZhbHVlPVwiZmlzaFwiPlxuICAgICAqICAgIGBcbiAgICAgKiAgfSlcbiAgICAgKiAgY2xhc3MgRm9vZENtcCB7XG4gICAgICogICAgZm9vZCA9ICdjaGlja2VuJztcbiAgICAgKiAgfVxuICAgICAqICBgYGBcbiAgICAgKi9cbiAgICB2YXIgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZiwgX3JlZ2lzdHJ5LCBfaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSBfcmVnaXN0cnk7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSB0aGlzLl9pbmplY3Rvci5nZXQoTmdDb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkuYWRkKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVnaXN0cnkucmVtb3ZlKHRoaXMpOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlID09PSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NoZWNrZWQnLCB0aGlzLl9zdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmbihfdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlZ2lzdHJ5LnNlbGVjdChfdGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5maXJlVW5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLndyaXRlVmFsdWUodmFsdWUpOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fY2hlY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSAmJiB0aGlzLmZvcm1Db250cm9sTmFtZSAmJiB0aGlzLm5hbWUgIT09IHRoaXMuZm9ybUNvbnRyb2xOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dOYW1lRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5uYW1lICYmIHRoaXMuZm9ybUNvbnRyb2xOYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuZm9ybUNvbnRyb2xOYW1lO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fdGhyb3dOYW1lRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBJZiB5b3UgZGVmaW5lIGJvdGggYSBuYW1lIGFuZCBhIGZvcm1Db250cm9sTmFtZSBhdHRyaWJ1dGUgb24geW91ciByYWRpbyBidXR0b24sIHRoZWlyIHZhbHVlc1xcbiAgICAgIG11c3QgbWF0Y2guIEV4OiA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIGZvcm1Db250cm9sTmFtZT1cXFwiZm9vZFxcXCIgbmFtZT1cXFwiZm9vZFxcXCI+XFxuICAgIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1yYWRpb11bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXJhZGlvXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1yYWRpb11bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSQURJT19WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFJhZGlvQ29udHJvbFJlZ2lzdHJ5LCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdG9yLCB9LFxuICAgICAgICBdO1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICdmb3JtQ29udHJvbE5hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFNFTEVDVF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmcoaWQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGlkKSlcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIGlmICghaXNQcmltaXRpdmUodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICAgICAgcmV0dXJuIFN0cmluZ1dyYXBwZXIuc2xpY2UoaWQgKyBcIjogXCIgKyB2YWx1ZSwgMCwgNTApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZXh0cmFjdElkKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZy5zcGxpdCgnOicpWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gYSBzZWxlY3QgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIE5vdGU6IFdlIGhhdmUgdG8gbGlzdGVuIHRvIHRoZSAnY2hhbmdlJyBldmVudCBiZWNhdXNlICdpbnB1dCcgZXZlbnRzIGFyZW4ndCBmaXJlZFxuICAgICAqIGZvciBzZWxlY3RzIGluIEZpcmVmb3ggYW5kIElFOlxuICAgICAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwMjQzNTBcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy80NjYwMDQ1L1xuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZVN0cmluZyA9IF9idWlsZFZhbHVlU3RyaW5nKHRoaXMuX2dldE9wdGlvbklkKHZhbHVlKSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWVTdHJpbmcpO1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlU3RyaW5nO1xuICAgICAgICAgICAgICAgIGZuKF90aGlzLl9nZXRPcHRpb25WYWx1ZSh2YWx1ZVN0cmluZykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fcmVnaXN0ZXJPcHRpb24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodGhpcy5faWRDb3VudGVyKyspLnRvU3RyaW5nKCk7IH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25JZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE1hcFdyYXBwZXIua2V5cyh0aGlzLl9vcHRpb25NYXApOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAobG9vc2VJZGVudGljYWwodGhpcy5fb3B0aW9uTWFwLmdldChpZCksIHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fb3B0aW9uTWFwLmdldChfZXh0cmFjdElkKHZhbHVlU3RyaW5nKSk7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHZhbHVlKSA/IHZhbHVlIDogdmFsdWVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sTmFtZV0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtmb3JtQ29udHJvbF0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtTRUxFQ1RfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxzZWxlY3QgbmFtZT1cImNpdHlcIiBuZ01vZGVsPlxuICAgICAqICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgYyBvZiBjaXRpZXNcIiBbdmFsdWVdPVwiY1wiPjwvb3B0aW9uPlxuICAgICAqIDwvc2VsZWN0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ1NlbGVjdE9wdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nU2VsZWN0T3B0aW9uKF9lbGVtZW50LCBfcmVuZGVyZXIsIF9zZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ID0gX3NlbGVjdDtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fc2VsZWN0KSlcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5fc2VsZWN0Ll9yZWdpc3Rlck9wdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUsIFwibmdWYWx1ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLnNldCh0aGlzLmlkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NlbGVjdCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NlbGVjdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnb3B0aW9uJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5Ib3N0IH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ1ZhbHVlJyxdIH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsndmFsdWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdTZWxlY3RPcHRpb247XG4gICAgfSgpKTtcblxuICAgIHZhciBTRUxFQ1RfTVVMVElQTEVfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmckMShpZCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoaWQpKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gXCInXCIgKyB2YWx1ZSArIFwiJ1wiO1xuICAgICAgICBpZiAoIWlzUHJpbWl0aXZlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gJ09iamVjdCc7XG4gICAgICAgIHJldHVybiBTdHJpbmdXcmFwcGVyLnNsaWNlKGlkICsgXCI6IFwiICsgdmFsdWUsIDAsIDUwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2V4dHJhY3RJZCQxKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZy5zcGxpdCgnOicpWzBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gYSBzZWxlY3QgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlO1xuICAgICAgICAgICAgLy8gY29udmVydCB2YWx1ZXMgdG8gaWRzXG4gICAgICAgICAgICB2YXIgaWRzID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gX3RoaXMuX2dldE9wdGlvbklkKHYpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChvcHQsIG8pIHsgb3B0Ll9zZXRTZWxlY3RlZChpZHMuaW5kZXhPZihvLnRvU3RyaW5nKCkpID4gLTEpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChfLmhhc093blByb3BlcnR5KCdzZWxlY3RlZE9wdGlvbnMnKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF8uc2VsZWN0ZWRPcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBvcHRpb25zLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gX3RoaXMuX2dldE9wdGlvblZhbHVlKG9wdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gXy5vcHRpb25zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHQgPSBvcHRpb25zLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF90aGlzLl9nZXRPcHRpb25WYWx1ZShvcHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbihzZWxlY3RlZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9yZWdpc3Rlck9wdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwLnNldChpZCwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25JZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE1hcFdyYXBwZXIua2V5cyh0aGlzLl9vcHRpb25NYXApOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAobG9vc2VJZGVudGljYWwodGhpcy5fb3B0aW9uTWFwLmdldChpZCkuX3ZhbHVlLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9nZXRPcHRpb25WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgdmFyIG9wdCA9IHRoaXMuX29wdGlvbk1hcC5nZXQoX2V4dHJhY3RJZCQxKHZhbHVlU3RyaW5nKSk7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KG9wdCkgPyBvcHQuX3ZhbHVlIDogdmFsdWVTdHJpbmc7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlbGVjdFttdWx0aXBsZV1bZm9ybUNvbnRyb2xOYW1lXSxzZWxlY3RbbXVsdGlwbGVdW2Zvcm1Db250cm9sXSxzZWxlY3RbbXVsdGlwbGVdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NFTEVDVF9NVUxUSVBMRV9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxzZWxlY3QgbXVsdGlwbGUgbmFtZT1cImNpdHlcIiBuZ01vZGVsPlxuICAgICAqICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgYyBvZiBjaXRpZXNcIiBbdmFsdWVdPVwiY1wiPjwvb3B0aW9uPlxuICAgICAqIDwvc2VsZWN0PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHZhciBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTmdTZWxlY3RNdWx0aXBsZU9wdGlvbihfZWxlbWVudCwgX3JlbmRlcmVyLCBfc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdCA9IF9zZWxlY3Q7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NlbGVjdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5fc2VsZWN0Ll9yZWdpc3Rlck9wdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUsIFwibmdWYWx1ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3QgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nJDEodGhpcy5pZCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fc2VsZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUoX2J1aWxkVmFsdWVTdHJpbmckMSh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZS5fc2V0RWxlbWVudFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUuX3NldFNlbGVjdGVkID0gZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9zZWxlY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0Ll9vcHRpb25NYXAuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24uZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnb3B0aW9uJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24uY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICduZ1ZhbHVlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ1ZhbHVlJyxdIH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsndmFsdWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdTZWxlY3RNdWx0aXBsZU9wdGlvbjtcbiAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gY29udHJvbFBhdGgobmFtZSwgcGFyZW50KSB7XG4gICAgICAgIHZhciBwID0gTGlzdFdyYXBwZXIuY2xvbmUocGFyZW50LnBhdGgpO1xuICAgICAgICBwLnB1c2gobmFtZSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRVcENvbnRyb2woY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGNvbnRyb2wpKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGlmIChpc0JsYW5rKGRpci52YWx1ZUFjY2Vzc29yKSlcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICBjb250cm9sLnZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbY29udHJvbC52YWxpZGF0b3IsIGRpci52YWxpZGF0b3JdKTtcbiAgICAgICAgY29udHJvbC5hc3luY1ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKFtjb250cm9sLmFzeW5jVmFsaWRhdG9yLCBkaXIuYXN5bmNWYWxpZGF0b3JdKTtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShjb250cm9sLnZhbHVlKTtcbiAgICAgICAgLy8gdmlldyAtPiBtb2RlbFxuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRyb2wubWFya0FzRGlydHkoKTtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0VmFsdWUobmV3VmFsdWUsIHsgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlOiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRvdWNoZWRcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7IH0pO1xuICAgICAgICBjb250cm9sLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKG5ld1ZhbHVlLCBlbWl0TW9kZWxFdmVudCkge1xuICAgICAgICAgICAgLy8gY29udHJvbCAtPiB2aWV3XG4gICAgICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci53cml0ZVZhbHVlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIC8vIGNvbnRyb2wgLT4gbmdNb2RlbFxuICAgICAgICAgICAgaWYgKGVtaXRNb2RlbEV2ZW50KVxuICAgICAgICAgICAgICAgIGRpci52aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGlyLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSkge1xuICAgICAgICAgICAgY29udHJvbC5yZWdpc3Rlck9uRGlzYWJsZWRDaGFuZ2UoZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHsgZGlyLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmUtcnVuIHZhbGlkYXRpb24gd2hlbiB2YWxpZGF0b3IgYmluZGluZyBjaGFuZ2VzLCBlLmcuIG1pbmxlbmd0aD0zIC0+IG1pbmxlbmd0aD00XG4gICAgICAgIGRpci5fcmF3VmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSlcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkaXIuX3Jhd0FzeW5jVmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSlcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhblVwQ29udHJvbChjb250cm9sLCBkaXIpIHtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPbkNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBfbm9Db250cm9sRXJyb3IoZGlyKTsgfSk7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25Ub3VjaGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9ub0NvbnRyb2xFcnJvcihkaXIpOyB9KTtcbiAgICAgICAgZGlyLl9yYXdWYWxpZGF0b3JzLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRvcikgeyByZXR1cm4gdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UobnVsbCk7IH0pO1xuICAgICAgICBkaXIuX3Jhd0FzeW5jVmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHsgcmV0dXJuIHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKG51bGwpOyB9KTtcbiAgICAgICAgaWYgKGNvbnRyb2wpXG4gICAgICAgICAgICBjb250cm9sLl9jbGVhckNoYW5nZUZucygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRVcEZvcm1Db250YWluZXIoY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGNvbnRyb2wpKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGNvbnRyb2wudmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFtjb250cm9sLnZhbGlkYXRvciwgZGlyLnZhbGlkYXRvcl0pO1xuICAgICAgICBjb250cm9sLmFzeW5jVmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMoW2NvbnRyb2wuYXN5bmNWYWxpZGF0b3IsIGRpci5hc3luY1ZhbGlkYXRvcl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbm9Db250cm9sRXJyb3IoZGlyKSB7XG4gICAgICAgIHJldHVybiBfdGhyb3dFcnJvcihkaXIsICdUaGVyZSBpcyBubyBGb3JtQ29udHJvbCBpbnN0YW5jZSBhdHRhY2hlZCB0byBmb3JtIGNvbnRyb2wgZWxlbWVudCB3aXRoJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF90aHJvd0Vycm9yKGRpciwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgbWVzc2FnZUVuZDtcbiAgICAgICAgaWYgKGRpci5wYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSBcInBhdGg6ICdcIiArIGRpci5wYXRoLmpvaW4oJyAtPiAnKSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpci5wYXRoWzBdKSB7XG4gICAgICAgICAgICBtZXNzYWdlRW5kID0gXCJuYW1lOiAnXCIgKyBkaXIucGF0aCArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZUVuZCA9ICd1bnNwZWNpZmllZCBuYW1lIGF0dHJpYnV0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgKyBcIiBcIiArIG1lc3NhZ2VFbmQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodmFsaWRhdG9ycykgPyBWYWxpZGF0b3JzLmNvbXBvc2UodmFsaWRhdG9ycy5tYXAobm9ybWFsaXplVmFsaWRhdG9yKSkgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh2YWxpZGF0b3JzKSA/IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKHZhbGlkYXRvcnMubWFwKG5vcm1hbGl6ZUFzeW5jVmFsaWRhdG9yKSkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdmlld01vZGVsKSB7XG4gICAgICAgIGlmICghU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhjaGFuZ2VzLCAnbW9kZWwnKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGNoYW5nZSA9IGNoYW5nZXNbJ21vZGVsJ107XG4gICAgICAgIGlmIChjaGFuZ2UuaXNGaXJzdENoYW5nZSgpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAhbG9vc2VJZGVudGljYWwodmlld01vZGVsLCBjaGFuZ2UuY3VycmVudFZhbHVlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCdWlsdEluQWNjZXNzb3IodmFsdWVBY2Nlc3Nvcikge1xuICAgICAgICByZXR1cm4gKGhhc0NvbnN0cnVjdG9yKHZhbHVlQWNjZXNzb3IsIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IpIHx8XG4gICAgICAgICAgICBoYXNDb25zdHJ1Y3Rvcih2YWx1ZUFjY2Vzc29yLCBOdW1iZXJWYWx1ZUFjY2Vzc29yKSB8fFxuICAgICAgICAgICAgaGFzQ29uc3RydWN0b3IodmFsdWVBY2Nlc3NvciwgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IpIHx8XG4gICAgICAgICAgICBoYXNDb25zdHJ1Y3Rvcih2YWx1ZUFjY2Vzc29yLCBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yKSB8fFxuICAgICAgICAgICAgaGFzQ29uc3RydWN0b3IodmFsdWVBY2Nlc3NvciwgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcikpO1xuICAgIH1cbiAgICAvLyBUT0RPOiB2c2F2a2luIHJlbW92ZSBpdCBvbmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMwMTEgaXMgaW1wbGVtZW50ZWRcbiAgICBmdW5jdGlvbiBzZWxlY3RWYWx1ZUFjY2Vzc29yKGRpciwgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodmFsdWVBY2Nlc3NvcnMpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBkZWZhdWx0QWNjZXNzb3I7XG4gICAgICAgIHZhciBidWlsdGluQWNjZXNzb3I7XG4gICAgICAgIHZhciBjdXN0b21BY2Nlc3NvcjtcbiAgICAgICAgdmFsdWVBY2Nlc3NvcnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKGhhc0NvbnN0cnVjdG9yKHYsIERlZmF1bHRWYWx1ZUFjY2Vzc29yKSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBY2Nlc3NvciA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0J1aWx0SW5BY2Nlc3Nvcih2KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoYnVpbHRpbkFjY2Vzc29yKSlcbiAgICAgICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTW9yZSB0aGFuIG9uZSBidWlsdC1pbiB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgICAgICAgICAgYnVpbHRpbkFjY2Vzc29yID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY3VzdG9tQWNjZXNzb3IpKVxuICAgICAgICAgICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdNb3JlIHRoYW4gb25lIGN1c3RvbSB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjdXN0b21BY2Nlc3NvcikpXG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tQWNjZXNzb3I7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoYnVpbHRpbkFjY2Vzc29yKSlcbiAgICAgICAgICAgIHJldHVybiBidWlsdGluQWNjZXNzb3I7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZGVmYXVsdEFjY2Vzc29yKSlcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QWNjZXNzb3I7XG4gICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbGlkIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBiYXNlIGNsYXNzIGZvciBjb2RlIHNoYXJlZCBiZXR3ZWVuIHtAbGluayBOZ01vZGVsR3JvdXB9IGFuZCB7QGxpbmsgRm9ybUdyb3VwTmFtZX0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZEZvcm1Hcm91cCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVGb3JtR3JvdXAodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUge0BsaW5rIEZvcm1Hcm91cH0gYmFja2luZyB0aGlzIGJpbmRpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldEZvcm1Hcm91cCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgcGF0aCB0byB0aGlzIGNvbnRyb2wgZ3JvdXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSB7QGxpbmsgRm9ybX0gdG8gd2hpY2ggdGhpcyBncm91cCBiZWxvbmdzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBBYnN0cmFjdENvbnRyb2xTdGF0dXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xTdGF0dXMoY2QpIHtcbiAgICAgICAgICAgIHRoaXMuX2NkID0gY2Q7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1VudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC51bnRvdWNoZWQgOiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzVG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC50b3VjaGVkIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnByaXN0aW5lIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLmRpcnR5IDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ZhbGlkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnZhbGlkIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0ludmFsaWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9jZC5jb250cm9sKSA/IHRoaXMuX2NkLmNvbnRyb2wuaW52YWxpZCA6IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBYnN0cmFjdENvbnRyb2xTdGF0dXM7XG4gICAgfSgpKTtcbiAgICB2YXIgbmdDb250cm9sU3RhdHVzSG9zdCA9IHtcbiAgICAgICAgJ1tjbGFzcy5uZy11bnRvdWNoZWRdJzogJ25nQ2xhc3NVbnRvdWNoZWQnLFxuICAgICAgICAnW2NsYXNzLm5nLXRvdWNoZWRdJzogJ25nQ2xhc3NUb3VjaGVkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1wcmlzdGluZV0nOiAnbmdDbGFzc1ByaXN0aW5lJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1kaXJ0eV0nOiAnbmdDbGFzc0RpcnR5JyxcbiAgICAgICAgJ1tjbGFzcy5uZy12YWxpZF0nOiAnbmdDbGFzc1ZhbGlkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1pbnZhbGlkXSc6ICduZ0NsYXNzSW52YWxpZCdcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpcmVjdGl2ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gQW5ndWxhciBmb3JtIGNvbnRyb2xzIHRoYXQgc2V0cyBDU1MgY2xhc3Nlc1xuICAgICAqIGJhc2VkIG9uIGNvbnRyb2wgc3RhdHVzICh2YWxpZC9pbnZhbGlkL2RpcnR5L2V0YykuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nQ29udHJvbFN0YXR1cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKE5nQ29udHJvbFN0YXR1cywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzKGNkKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmdDb250cm9sU3RhdHVzLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbE5hbWVdLFtuZ01vZGVsXSxbZm9ybUNvbnRyb2xdJywgaG9zdDogbmdDb250cm9sU3RhdHVzSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nQ29udHJvbFN0YXR1cy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBOZ0NvbnRyb2xTdGF0dXM7XG4gICAgfShBYnN0cmFjdENvbnRyb2xTdGF0dXMpKTtcbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgYXV0b21hdGljYWxseSBhcHBsaWVkIHRvIEFuZ3VsYXIgZm9ybSBncm91cHMgdGhhdCBzZXRzIENTUyBjbGFzc2VzXG4gICAgICogYmFzZWQgb24gY29udHJvbCBzdGF0dXMgKHZhbGlkL2ludmFsaWQvZGlydHkvZXRjKS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDb250cm9sU3RhdHVzR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhOZ0NvbnRyb2xTdGF0dXNHcm91cCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzR3JvdXAoY2QpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNkKTtcbiAgICAgICAgfVxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdLFtmb3JtQXJyYXlOYW1lXSxbbmdNb2RlbEdyb3VwXSxbZm9ybUdyb3VwXSxmb3JtOm5vdChbbmdOb0Zvcm1dKSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBuZ0NvbnRyb2xTdGF0dXNIb3N0XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdDb250cm9sU3RhdHVzR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbFN0YXR1c0dyb3VwO1xuICAgIH0oQWJzdHJhY3RDb250cm9sU3RhdHVzKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlIGJ5IGRpcmVjdGl2ZXMgYW5kIGNvbXBvbmVudHMgdG8gZW1pdCBjdXN0b20gRXZlbnRzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVzXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIGBaaXBweWAgYWx0ZXJuYXRpdmVseSBlbWl0cyBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIHdoZW4gaXRzXG4gICAgICogdGl0bGUgZ2V0cyBjbGlja2VkOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ3ppcHB5JyxcbiAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICogICA8ZGl2IGNsYXNzPVwiemlwcHlcIj5cbiAgICAgKiAgICAgPGRpdiAoY2xpY2spPVwidG9nZ2xlKClcIj5Ub2dnbGU8L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBbaGlkZGVuXT1cIiF2aXNpYmxlXCI+XG4gICAgICogICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgPC9kaXY+YH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFppcHB5IHtcbiAgICAgKiAgIHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAqICAgQE91dHB1dCgpIG9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqICAgQE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKlxuICAgICAqICAgdG9nZ2xlKCkge1xuICAgICAqICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xuICAgICAqICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICogICAgICAgdGhpcy5vcGVuLmVtaXQobnVsbCk7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgdGhpcy5jbG9zZS5lbWl0KG51bGwpO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIGV2ZW50cyBwYXlsb2FkIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGUgcGFyYW1ldGVyIGAkZXZlbnRgIG9uIHRoZSBjb21wb25lbnRzIG91dHB1dCBldmVudFxuICAgICAqIGhhbmRsZXI6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8emlwcHkgKG9wZW4pPVwib25PcGVuKCRldmVudClcIiAoY2xvc2UpPVwib25DbG9zZSgkZXZlbnQpXCI+PC96aXBweT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzZXMgUnguT2JzZXJ2YWJsZSBidXQgcHJvdmlkZXMgYW4gYWRhcHRlciB0byBtYWtlIGl0IHdvcmsgYXMgc3BlY2lmaWVkIGhlcmU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2podXNhaW4vb2JzZXJ2YWJsZS1zcGVjXG4gICAgICpcbiAgICAgKiBPbmNlIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjIGlzIGF2YWlsYWJsZSwgc3dpdGNoIHRvIGl0LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDUoRXZlbnRFbWl0dGVyLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBbRXZlbnRFbWl0dGVyXSwgd2hpY2ggZGVwZW5kaW5nIG9uIFtpc0FzeW5jXSxcbiAgICAgICAgICogZGVsaXZlcnMgZXZlbnRzIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoaXNBc3luYykge1xuICAgICAgICAgICAgaWYgKGlzQXN5bmMgPT09IHZvaWQgMCkgeyBpc0FzeW5jID0gZmFsc2U7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPSBpc0FzeW5jO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7IH07XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGdlbmVyYXRvck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGVyRm47XG4gICAgICAgICAgICB2YXIgZXJyb3JGbiA9IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICB2YXIgY29tcGxldGVGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0ICYmIHR5cGVvZiBnZW5lcmF0b3JPck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWx1ZSAvKiogVE9ETyAjOTEwMCAqLykgeyBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUgLyoqIFRPRE8gIzkxMDAgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9KTtcbiAgICAgICAgICAgICAgICB9IDogZnVuY3Rpb24gKHZhbHVlIC8qKiBUT0RPICM5MTAwICovKSB7IGdlbmVyYXRvck9yTmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yRm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IoZXJyKTsgfSk7IH0gOiBmdW5jdGlvbiAoZXJyKSB7IGVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBsZXRlKCk7IH0pOyB9IDogZnVuY3Rpb24gKCkgeyBjb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnN1YnNjcmliZS5jYWxsKHRoaXMsIHNjaGVkdWxlckZuLCBlcnJvckZuLCBjb21wbGV0ZUZuKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICB9KHJ4anNfU3ViamVjdC5TdWJqZWN0KSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyB2YWxpZCwgaS5lLiB0aGF0IG5vIGVycm9ycyBleGlzdCBpbiB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIFZBTElEID0gJ1ZBTElEJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIGludmFsaWQsIGkuZS4gdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBJTlZBTElEID0gJ0lOVkFMSUQnO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgRm9ybUNvbnRyb2wgaXMgcGVuZGluZywgaS5lLiB0aGF0IGFzeW5jIHZhbGlkYXRpb24gaXMgb2NjdXJyaW5nIGFuZFxuICAgICAqIGVycm9ycyBhcmUgbm90IHlldCBhdmFpbGFibGUgZm9yIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgUEVORElORyA9ICdQRU5ESU5HJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIGRpc2FibGVkLCBpLmUuIHRoYXQgdGhlIGNvbnRyb2wgaXMgZXhlbXB0IGZyb20gYW5jZXN0b3JcbiAgICAgKiBjYWxjdWxhdGlvbnMgb2YgdmFsaWRpdHkgb3IgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIERJU0FCTEVEID0gJ0RJU0FCTEVEJztcbiAgICBmdW5jdGlvbiBfZmluZChjb250cm9sLCBwYXRoLCBkZWxpbWl0ZXIpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsocGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoZGVsaW1pdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEFycmF5ICYmIExpc3RXcmFwcGVyLmlzRW1wdHkocGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uICh2LCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIEZvcm1Hcm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodi5jb250cm9sc1tuYW1lXSkgPyB2LmNvbnRyb2xzW25hbWVdIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBGb3JtQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodi5hdChpbmRleCkpID8gdi5hdChpbmRleCkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRyb2wpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b09ic2VydmFibGUocikge1xuICAgICAgICByZXR1cm4gaXNQcm9taXNlKHIpID8gcnhqc19vYnNlcnZhYmxlX2Zyb21Qcm9taXNlLmZyb21Qcm9taXNlKHIpIDogcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29lcmNlVG9WYWxpZGF0b3IodmFsaWRhdG9yKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbGlkYXRvcikgPyBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3IpIDogdmFsaWRhdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFzeW5jVmFsaWRhdG9yKSA/IGNvbXBvc2VBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3IpIDogYXN5bmNWYWxpZGF0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIHtAbGluayBGb3JtQ29udHJvbH0sIHtAbGluayBGb3JtR3JvdXB9LCBhbmRcbiAgICAgKiB7QGxpbmsgRm9ybUFycmF5fS5cbiAgICAgKlxuICAgICAqIEl0IHByb3ZpZGVzIHNvbWUgb2YgdGhlIHNoYXJlZCBiZWhhdmlvciB0aGF0IGFsbCBjb250cm9scyBhbmQgZ3JvdXBzIG9mIGNvbnRyb2xzIGhhdmUsIGxpa2VcbiAgICAgKiBydW5uaW5nIHZhbGlkYXRvcnMsIGNhbGN1bGF0aW5nIHN0YXR1cywgYW5kIHJlc2V0dGluZyBzdGF0ZS4gSXQgYWxzbyBkZWZpbmVzIHRoZSBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCBhcmUgc2hhcmVkIGJldHdlZW4gYWxsIHN1Yi1jbGFzc2VzLCBsaWtlIGB2YWx1ZWAsIGB2YWxpZGAsIGFuZCBgZGlydHlgLiBJdCBzaG91bGRuJ3QgYmVcbiAgICAgKiBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Q29udHJvbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFic3RyYWN0Q29udHJvbCh2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBhc3luY1ZhbGlkYXRvcjtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInN0YXR1c1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC4gVGhlcmUgYXJlIGZvdXIgcG9zc2libGVcbiAgICAgICAgICAgICAqIHZhbGlkYXRpb24gc3RhdHVzZXM6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiAqKlZBTElEKio6ICBjb250cm9sIGhhcyBwYXNzZWQgYWxsIHZhbGlkYXRpb24gY2hlY2tzXG4gICAgICAgICAgICAgKiAqICoqSU5WQUxJRCoqOiBjb250cm9sIGhhcyBmYWlsZWQgYXQgbGVhc3Qgb25lIHZhbGlkYXRpb24gY2hlY2tcbiAgICAgICAgICAgICAqICogKipQRU5ESU5HKio6IGNvbnRyb2wgaXMgaW4gdGhlIG1pZHN0IG9mIGNvbmR1Y3RpbmcgYSB2YWxpZGF0aW9uIGNoZWNrXG4gICAgICAgICAgICAgKiAqICoqRElTQUJMRUQqKjogY29udHJvbCBpcyBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZXNlIHN0YXR1c2VzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIGEgY29udHJvbCBjYW5ub3QgYmVcbiAgICAgICAgICAgICAqIGJvdGggdmFsaWQgQU5EIGludmFsaWQgb3IgaW52YWxpZCBBTkQgZGlzYWJsZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsaWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHZhbGlkYCB3aGVuIGl0cyBgc3RhdHVzID09PSBWQUxJRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3JkZXIgdG8gaGF2ZSB0aGlzIHN0YXR1cywgdGhlIGNvbnRyb2wgbXVzdCBoYXZlIHBhc3NlZCBhbGwgaXRzXG4gICAgICAgICAgICAgKiB2YWxpZGF0aW9uIGNoZWNrcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IFZBTElEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiaW52YWxpZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgaW52YWxpZGAgd2hlbiBpdHMgYHN0YXR1cyA9PT0gSU5WQUxJRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3JkZXIgdG8gaGF2ZSB0aGlzIHN0YXR1cywgdGhlIGNvbnRyb2wgbXVzdCBoYXZlIGZhaWxlZFxuICAgICAgICAgICAgICogYXQgbGVhc3Qgb25lIG9mIGl0cyB2YWxpZGF0aW9uIGNoZWNrcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IElOVkFMSUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwZW5kaW5nXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBwZW5kaW5nYCB3aGVuIGl0cyBgc3RhdHVzID09PSBQRU5ESU5HYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGJlIGluIHRoZVxuICAgICAgICAgICAgICogbWlkZGxlIG9mIGNvbmR1Y3RpbmcgYSB2YWxpZGF0aW9uIGNoZWNrLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PSBQRU5ESU5HOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYGRpc2FibGVkYCB3aGVuIGl0cyBgc3RhdHVzID09PSBESVNBQkxFRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRGlzYWJsZWQgY29udHJvbHMgYXJlIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAgICAgICAgICogYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIHRoZWlyIGFuY2VzdG9yXG4gICAgICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXMgPT09IERJU0FCTEVEOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZW5hYmxlZGAgYXMgbG9uZyBhcyBpdHMgYHN0YXR1cyAhPT0gRElTQUJMRURgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzLCBpdCBoYXMgYSBzdGF0dXMgb2YgYFZBTElEYCwgYElOVkFMSURgLCBvclxuICAgICAgICAgICAgICogYFBFTkRJTkdgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyAhPT0gRElTQUJMRUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJlcnJvcnNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFueSBlcnJvcnMgZ2VuZXJhdGVkIGJ5IGZhaWxpbmcgdmFsaWRhdGlvbi4gSWYgdGhlcmVcbiAgICAgICAgICAgICAqIGFyZSBubyBlcnJvcnMsIGl0IHdpbGwgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZXJyb3JzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicHJpc3RpbmVcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHByaXN0aW5lYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCBjaGFuZ2VkXG4gICAgICAgICAgICAgKiB0aGUgdmFsdWUgaW4gdGhlIFVJLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBwcm9ncmFtbWF0aWMgY2hhbmdlcyB0byBhIGNvbnRyb2wncyB2YWx1ZSB3aWxsXG4gICAgICAgICAgICAgKiAqbm90KiBtYXJrIGl0IGRpcnR5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ByaXN0aW5lOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYGRpcnR5YCBpZiB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgdmFsdWVcbiAgICAgICAgICAgICAqIGluIHRoZSBVSS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgcHJvZ3JhbW1hdGljIGNoYW5nZXMgdG8gYSBjb250cm9sJ3MgdmFsdWUgd2lsbFxuICAgICAgICAgICAgICogKm5vdCogbWFyayBpdCBkaXJ0eS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5wcmlzdGluZTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInRvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIEEgY29udHJvbCBpcyBtYXJrZWQgYHRvdWNoZWRgIG9uY2UgdGhlIHVzZXIgaGFzIHRyaWdnZXJlZFxuICAgICAgICAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3RvdWNoZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHVudG91Y2hlZGAgaWYgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgdHJpZ2dlcmVkXG4gICAgICAgICAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhdGhpcy5fdG91Y2hlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVtaXRzIGFuIGV2ZW50IGV2ZXJ5IHRpbWUgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sIGNoYW5nZXMsIGluXG4gICAgICAgICAgICAgKiB0aGUgVUkgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl92YWx1ZUNoYW5nZXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJzdGF0dXNDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1pdHMgYW4gZXZlbnQgZXZlcnkgdGltZSB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2xcbiAgICAgICAgICAgICAqIGlzIHJlLWNhbGN1bGF0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzQ2hhbmdlczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHRoYXQgYXJlIGFjdGl2ZSBvbiB0aGlzIGNvbnRyb2wuICBDYWxsaW5nXG4gICAgICAgICAqIHRoaXMgd2lsbCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIHN5bmMgdmFsaWRhdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0VmFsaWRhdG9ycyA9IGZ1bmN0aW9uIChuZXdWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gY29lcmNlVG9WYWxpZGF0b3IobmV3VmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFzeW5jIHZhbGlkYXRvcnMgdGhhdCBhcmUgYWN0aXZlIG9uIHRoaXMgY29udHJvbC4gQ2FsbGluZyB0aGlzXG4gICAgICAgICAqIHdpbGwgb3ZlcndyaXRlIGFueSBleGlzdGluZyBhc3luYyB2YWxpZGF0b3JzLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRBc3luY1ZhbGlkYXRvcnMgPSBmdW5jdGlvbiAobmV3VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmFzeW5jVmFsaWRhdG9yID0gY29lcmNlVG9Bc3luY1ZhbGlkYXRvcihuZXdWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1wdGllcyBvdXQgdGhlIHN5bmMgdmFsaWRhdG9yIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmNsZWFyVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHsgdGhpcy52YWxpZGF0b3IgPSBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1wdGllcyBvdXQgdGhlIGFzeW5jIHZhbGlkYXRvciBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5jbGVhckFzeW5jVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5hc3luY1ZhbGlkYXRvciA9IG51bGw7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgdG91Y2hlZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBhbHNvIG1hcmsgYWxsIGRpcmVjdCBhbmNlc3RvcnMgYXMgYHRvdWNoZWRgIHRvIG1haW50YWluXG4gICAgICAgICAqIHRoZSBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzVG91Y2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIG9ubHlTZWxmID0gbm9ybWFsaXplQm9vbChvbmx5U2VsZik7XG4gICAgICAgICAgICB0aGlzLl90b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fcGFyZW50KSAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzVG91Y2hlZCh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGB1bnRvdWNoZWRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgYW55IGNoaWxkcmVuLCBpdCB3aWxsIGFsc28gbWFyayBhbGwgY2hpbGRyZW4gYXMgYHVudG91Y2hlZGBcbiAgICAgICAgICogdG8gbWFpbnRhaW4gdGhlIG1vZGVsLCBhbmQgcmUtY2FsY3VsYXRlIHRoZSBgdG91Y2hlZGAgc3RhdHVzIG9mIGFsbCBwYXJlbnRcbiAgICAgICAgICogY29udHJvbHMuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLm1hcmtBc1VudG91Y2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLm1hcmtBc1VudG91Y2hlZCh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fcGFyZW50KSAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgZGlydHlgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYWxzbyBtYXJrIGFsbCBkaXJlY3QgYW5jZXN0b3JzIGFzIGBkaXJ0eWAgdG8gbWFpbnRhaW5cbiAgICAgICAgICogdGhlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNEaXJ0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIG9ubHlTZWxmID0gbm9ybWFsaXplQm9vbChvbmx5U2VsZik7XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9wYXJlbnQpICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNEaXJ0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwcmlzdGluZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGl0IHdpbGwgYWxzbyBtYXJrIGFsbCBjaGlsZHJlbiBhcyBgcHJpc3RpbmVgXG4gICAgICAgICAqIHRvIG1haW50YWluIHRoZSBtb2RlbCwgYW5kIHJlLWNhbGN1bGF0ZSB0aGUgYHByaXN0aW5lYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzUHJpc3RpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5tYXJrQXNQcmlzdGluZSh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fcGFyZW50KSAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHBlbmRpbmdgLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNQZW5kaW5nID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgb25seVNlbGYgPSBub3JtYWxpemVCb29sKG9ubHlTZWxmKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFBFTkRJTkc7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3BhcmVudCkgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Lm1hcmtBc1BlbmRpbmcoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgY29udHJvbC4gVGhpcyBtZWFucyB0aGUgY29udHJvbCB3aWxsIGJlIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAgICAgKiBleGNsdWRlZCBmcm9tIHRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgYW55IHBhcmVudC4gSXRzIHN0YXR1cyBpcyBgRElTQUJMRURgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgY2hpbGRyZW4sIGFsbCBjaGlsZHJlbiB3aWxsIGJlIGRpc2FibGVkIHRvIG1haW50YWluIHRoZSBtb2RlbC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIGVtaXRFdmVudCA9IGlzUHJlc2VudChlbWl0RXZlbnQpID8gZW1pdEV2ZW50IDogdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IERJU0FCTEVEO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLmRpc2FibGUoeyBvbmx5U2VsZjogdHJ1ZSB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcy5lbWl0KHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuY2VzdG9ycyhvbmx5U2VsZik7XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlcyB0aGUgY29udHJvbC4gVGhpcyBtZWFucyB0aGUgY29udHJvbCB3aWxsIGJlIGluY2x1ZGVkIGluIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAgICAgKiB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIGl0cyBwYXJlbnQuIEl0cyBzdGF0dXMgaXMgcmUtY2FsY3VsYXRlZCBiYXNlZCBvbiBpdHMgdmFsdWUgYW5kXG4gICAgICAgICAqIGl0cyB2YWxpZGF0b3JzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgY2hpbGRyZW4sIGFsbCBjaGlsZHJlbiB3aWxsIGJlIGVuYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFZBTElEO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IGNvbnRyb2wuZW5hYmxlKHsgb25seVNlbGY6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5jZXN0b3JzKG9ubHlTZWxmKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVBbmNlc3RvcnMgPSBmdW5jdGlvbiAob25seVNlbGYpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fcGFyZW50KSAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7IHRoaXMuX3BhcmVudCA9IHBhcmVudDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlLWNhbGN1bGF0ZXMgdGhlIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQnkgZGVmYXVsdCwgaXQgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IG9mIGl0cyBhbmNlc3RvcnMuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICBvbmx5U2VsZiA9IG5vcm1hbGl6ZUJvb2wob25seVNlbGYpO1xuICAgICAgICAgICAgZW1pdEV2ZW50ID0gaXNQcmVzZW50KGVtaXRFdmVudCkgPyBlbWl0RXZlbnQgOiB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0SW5pdGlhbFN0YXR1cygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLl9ydW5WYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSB0aGlzLl9jYWxjdWxhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzID09PSBWQUxJRCB8fCB0aGlzLl9zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVuQXN5bmNWYWxpZGF0b3IoZW1pdEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzLmVtaXQodGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9wYXJlbnQpICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVUcmVlVmFsaWRpdHkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBlbWl0RXZlbnQgPSAoX2EgPT09IHZvaWQgMCA/IHsgZW1pdEV2ZW50OiB0cnVlIH0gOiBfYSkuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjdHJsKSB7IHJldHVybiBjdHJsLl91cGRhdGVUcmVlVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTsgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3NldEluaXRpYWxTdGF0dXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3N0YXR1cyA9IHRoaXMuX2FsbENvbnRyb2xzRGlzYWJsZWQoKSA/IERJU0FCTEVEIDogVkFMSUQ7IH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3J1blZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy52YWxpZGF0b3IpID8gdGhpcy52YWxpZGF0b3IodGhpcykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9ydW5Bc3luY1ZhbGlkYXRvciA9IGZ1bmN0aW9uIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuYXN5bmNWYWxpZGF0b3IpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gUEVORElORztcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxFeGlzdGluZ1N1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBvYnMgPSB0b09ic2VydmFibGUodGhpcy5hc3luY1ZhbGlkYXRvcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uID0gb2JzLnN1YnNjcmliZSh7IG5leHQ6IGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIF90aGlzLnNldEVycm9ycyhyZXMsIHsgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7IH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2NhbmNlbEV4aXN0aW5nU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIGVycm9ycyBvbiBhIGZvcm0gY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHdoZW4gdmFsaWRhdGlvbnMgYXJlIHJ1biBtYW51YWxseSBieSB0aGUgdXNlciwgcmF0aGVyIHRoYW4gYXV0b21hdGljYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FsbGluZyBgc2V0RXJyb3JzYCB3aWxsIGFsc28gdXBkYXRlIHRoZSB2YWxpZGl0eSBvZiB0aGUgcGFyZW50IGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBjb25zdCBsb2dpbiA9IG5ldyBGb3JtQ29udHJvbChcInNvbWVMb2dpblwiKTtcbiAgICAgICAgICogbG9naW4uc2V0RXJyb3JzKHtcbiAgICAgICAgICogICBcIm5vdFVuaXF1ZVwiOiB0cnVlXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBleHBlY3QobG9naW4udmFsaWQpLnRvRXF1YWwoZmFsc2UpO1xuICAgICAgICAgKiBleHBlY3QobG9naW4uZXJyb3JzKS50b0VxdWFsKHtcIm5vdFVuaXF1ZVwiOiB0cnVlfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGxvZ2luLnNldFZhbHVlKFwic29tZU90aGVyTG9naW5cIik7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbCh0cnVlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldEVycm9ycyA9IGZ1bmN0aW9uIChlcnJvcnMsIF9hKSB7XG4gICAgICAgICAgICB2YXIgZW1pdEV2ZW50ID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5lbWl0RXZlbnQ7XG4gICAgICAgICAgICBlbWl0RXZlbnQgPSBpc1ByZXNlbnQoZW1pdEV2ZW50KSA/IGVtaXRFdmVudCA6IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb250cm9sc0Vycm9ycyhlbWl0RXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGEgY2hpbGQgY29udHJvbCBnaXZlbiB0aGUgY29udHJvbCdzIG5hbWUgb3IgcGF0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogUGF0aHMgY2FuIGJlIHBhc3NlZCBpbiBhcyBhbiBhcnJheSBvciBhIHN0cmluZyBkZWxpbWl0ZWQgYnkgYSBkb3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGdldCBhIGNvbnRyb2wgbmVzdGVkIHdpdGhpbiBhIGBwZXJzb25gIHN1Yi1ncm91cDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgdGhpcy5mb3JtLmdldCgncGVyc29uLm5hbWUnKTtgXG4gICAgICAgICAqXG4gICAgICAgICAqIC1PUi1cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgdGhpcy5mb3JtLmdldChbJ3BlcnNvbicsICduYW1lJ10pO2BcbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIF9maW5kKHRoaXMsIHBhdGgsICcuJyk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gcGF0aCBoYXMgdGhlIGVycm9yIHNwZWNpZmllZC4gT3RoZXJ3aXNlXG4gICAgICAgICAqIHJldHVybnMgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIG5vIHBhdGggaXMgZ2l2ZW4sIGl0IGNoZWNrcyBmb3IgdGhlIGVycm9yIG9uIHRoZSBwcmVzZW50IGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBpc1ByZXNlbnQocGF0aCkgJiYgIUxpc3RXcmFwcGVyLmlzRW1wdHkocGF0aCkgPyB0aGlzLmdldChwYXRoKSA6IHRoaXM7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbnRyb2wpICYmIGlzUHJlc2VudChjb250cm9sLl9lcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZ01hcFdyYXBwZXIuZ2V0KGNvbnRyb2wuX2Vycm9ycywgZXJyb3JDb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuIE90aGVyd2lzZVxuICAgICAgICAgKiByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBubyBwYXRoIGlzIGdpdmVuLCBpdCBjaGVja3MgZm9yIHRoZSBlcnJvciBvbiB0aGUgcHJlc2VudCBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5nZXRFcnJvcihlcnJvckNvZGUsIHBhdGgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgdG9wLWxldmVsIGFuY2VzdG9yIG9mIHRoaXMgY29udHJvbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpc1ByZXNlbnQoeC5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0geC5fcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzID0gZnVuY3Rpb24gKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gdGhpcy5fY2FsY3VsYXRlU3RhdHVzKCk7XG4gICAgICAgICAgICBpZiAoZW1pdEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5lbWl0KHRoaXMuX3N0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzKGVtaXRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5faW5pdE9ic2VydmFibGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fY2FsY3VsYXRlU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FsbENvbnRyb2xzRGlzYWJsZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRElTQUJMRUQ7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX2Vycm9ycykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW55Q29udHJvbHNIYXZlU3RhdHVzKFBFTkRJTkcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQRU5ESU5HO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhJTlZBTElEKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIHJldHVybiBWQUxJRDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc0hhdmVTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuc3RhdHVzID09IHN0YXR1czsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHNEaXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scyhmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC5kaXJ0eTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHNUb3VjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FueUNvbnRyb2xzKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnRvdWNoZWQ7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVByaXN0aW5lID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSAhdGhpcy5fYW55Q29udHJvbHNEaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9wYXJlbnQpICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fdXBkYXRlVG91Y2hlZCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoZWQgPSB0aGlzLl9hbnlDb250cm9sc1RvdWNoZWQoKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fcGFyZW50KSAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fb25EaXNhYmxlZENoYW5nZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7IH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5faXNCb3hlZFZhbHVlID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nTWFwKGZvcm1TdGF0ZSkgJiYgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPT09IDIgJiYgJ3ZhbHVlJyBpbiBmb3JtU3RhdGUgJiZcbiAgICAgICAgICAgICAgICAnZGlzYWJsZWQnIGluIGZvcm1TdGF0ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Q29udHJvbDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzIG9mIGFuIGluZGl2aWR1YWwgZm9ybSBjb250cm9sLlxuICAgICAqXG4gICAgICogSXQgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3Mgb2YgQW5ndWxhciBmb3JtcywgYWxvbmcgd2l0aFxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGFuZCB7QGxpbmsgRm9ybUFycmF5fS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogV2hlbiBpbnN0YW50aWF0aW5nIGEge0BsaW5rIEZvcm1Db250cm9sfSwgeW91IGNhbiBwYXNzIGluIGFuIGluaXRpYWwgdmFsdWUgYXMgdGhlXG4gICAgICogZmlyc3QgYXJndW1lbnQuIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGN0cmwgPSBuZXcgRm9ybUNvbnRyb2woJ3NvbWUgdmFsdWUnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnZhbHVlKTsgICAgIC8vICdzb21lIHZhbHVlJ1xuICAgICAqYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gaW5pdGlhbGl6ZSB0aGUgY29udHJvbCB3aXRoIGEgZm9ybSBzdGF0ZSBvYmplY3Qgb24gaW5zdGFudGlhdGlvbixcbiAgICAgKiB3aGljaCBpbmNsdWRlcyBib3RoIHRoZSB2YWx1ZSBhbmQgd2hldGhlciBvciBub3QgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGN0cmwgPSBuZXcgRm9ybUNvbnRyb2woe3ZhbHVlOiAnbi9hJywgZGlzYWJsZWQ6IHRydWV9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnZhbHVlKTsgICAgIC8vICduL2EnXG4gICAgICogY29uc29sZS5sb2coY3RybC5zdGF0dXMpOyAgIC8vICdESVNBQkxFRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRvIGluY2x1ZGUgYSBzeW5jIHZhbGlkYXRvciAob3IgYW4gYXJyYXkgb2Ygc3luYyB2YWxpZGF0b3JzKSB3aXRoIHRoZSBjb250cm9sLFxuICAgICAqIHBhc3MgaXQgaW4gYXMgdGhlIHNlY29uZCBhcmd1bWVudC4gQXN5bmMgdmFsaWRhdG9ycyBhcmUgYWxzbyBzdXBwb3J0ZWQsIGJ1dFxuICAgICAqIGhhdmUgdG8gYmUgcGFzc2VkIGluIHNlcGFyYXRlbHkgYXMgdGhlIHRoaXJkIGFyZy5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICogY29uc29sZS5sb2coY3RybC52YWx1ZSk7ICAgICAvLyAnJ1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwuc3RhdHVzKTsgICAvLyAnSU5WQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNlZSBpdHMgc3VwZXJjbGFzcywge0BsaW5rIEFic3RyYWN0Q29udHJvbH0sIGZvciBtb3JlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEZvcm1Db250cm9sLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQ29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmIChmb3JtU3RhdGUgPT09IHZvaWQgMCkgeyBmb3JtU3RhdGUgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjb2VyY2VUb1ZhbGlkYXRvcih2YWxpZGF0b3IpLCBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKGFzeW5jVmFsaWRhdG9yKSk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlGb3JtU3RhdGUoZm9ybVN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIGZvcm0gY29udHJvbCB0byBgdmFsdWVgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgb25seVNlbGZgIGlzIGB0cnVlYCwgdGhpcyBjaGFuZ2Ugd2lsbCBvbmx5IGFmZmVjdCB0aGUgdmFsaWRhdGlvbiBvZiB0aGlzIGBGb3JtQ29udHJvbGBcbiAgICAgICAgICogYW5kIG5vdCBpdHMgcGFyZW50IGNvbXBvbmVudC4gVGhpcyBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGVtaXRFdmVudGAgaXMgYHRydWVgLCB0aGlzXG4gICAgICAgICAqIGNoYW5nZSB3aWxsIGNhdXNlIGEgYHZhbHVlQ2hhbmdlc2AgZXZlbnQgb24gdGhlIGBGb3JtQ29udHJvbGAgdG8gYmUgZW1pdHRlZC4gVGhpcyBkZWZhdWx0c1xuICAgICAgICAgKiB0byB0cnVlIChhcyBpdCBmYWxscyB0aHJvdWdoIHRvIGB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5YCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2VgIGlzIGB0cnVlYCwgdGhlIHZpZXcgd2lsbCBiZSBub3RpZmllZCBhYm91dCB0aGUgbmV3IHZhbHVlXG4gICAgICAgICAqIHZpYSBhbiBgb25DaGFuZ2VgIGV2ZW50LiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIGBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2VgIGlzIG5vdFxuICAgICAgICAgKiBzcGVjaWZpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBlbWl0Vmlld1RvTW9kZWxDaGFuZ2VgIGlzIGB0cnVlYCwgYW4gbmdNb2RlbENoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIHRvIHVwZGF0ZSB0aGVcbiAgICAgICAgICogbW9kZWwuICBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIGBlbWl0Vmlld1RvTW9kZWxDaGFuZ2VgIGlzIG5vdCBzcGVjaWZpZWQuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG9ubHlTZWxmID0gX2Iub25seVNlbGYsIGVtaXRFdmVudCA9IF9iLmVtaXRFdmVudCwgZW1pdE1vZGVsVG9WaWV3Q2hhbmdlID0gX2IuZW1pdE1vZGVsVG9WaWV3Q2hhbmdlLCBlbWl0Vmlld1RvTW9kZWxDaGFuZ2UgPSBfYi5lbWl0Vmlld1RvTW9kZWxDaGFuZ2U7XG4gICAgICAgICAgICBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgPSBpc1ByZXNlbnQoZW1pdE1vZGVsVG9WaWV3Q2hhbmdlKSA/IGVtaXRNb2RlbFRvVmlld0NoYW5nZSA6IHRydWU7XG4gICAgICAgICAgICBlbWl0Vmlld1RvTW9kZWxDaGFuZ2UgPSBpc1ByZXNlbnQoZW1pdFZpZXdUb01vZGVsQ2hhbmdlKSA/IGVtaXRWaWV3VG9Nb2RlbENoYW5nZSA6IHRydWU7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlLmxlbmd0aCAmJiBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2VGbikgeyByZXR1cm4gY2hhbmdlRm4oX3RoaXMuX3ZhbHVlLCBlbWl0Vmlld1RvTW9kZWxDaGFuZ2UpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiwgZW1pdEV2ZW50OiBlbWl0RXZlbnQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXRjaGVzIHRoZSB2YWx1ZSBvZiBhIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZnVuY3Rpb25hbGx5IHRoZSBzYW1lIGFzIHtAbGluayBGb3JtQ29udHJvbC5zZXRWYWx1ZX0gYXQgdGhpcyBsZXZlbC5cbiAgICAgICAgICogSXQgZXhpc3RzIGZvciBzeW1tZXRyeSB3aXRoIHtAbGluayBGb3JtR3JvdXAucGF0Y2hWYWx1ZX0gb24gYEZvcm1Hcm91cHNgIGFuZCBgRm9ybUFycmF5c2AsXG4gICAgICAgICAqIHdoZXJlIGl0IGRvZXMgYmVoYXZlIGRpZmZlcmVudGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc2V0cyB0aGUgZm9ybSBjb250cm9sLiBUaGlzIG1lYW5zIGJ5IGRlZmF1bHQ6XG4gICAgICAgICAqXG4gICAgICAgICAqICogaXQgaXMgbWFya2VkIGFzIGBwcmlzdGluZWBcbiAgICAgICAgICogKiBpdCBpcyBtYXJrZWQgYXMgYHVudG91Y2hlZGBcbiAgICAgICAgICogKiB2YWx1ZSBpcyBzZXQgdG8gbnVsbFxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgdGhyb3VnaCBhIHN0YW5kYWxvbmVcbiAgICAgICAgICogdmFsdWUgb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB0aGF0IGNvbnRhaW5zIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZCBzdGF0ZVxuICAgICAgICAgKiAodGhlc2UgYXJlIHRoZSBvbmx5IHR3byBwcm9wZXJ0aWVzIHRoYXQgY2Fubm90IGJlIGNhbGN1bGF0ZWQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBFeDpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogdGhpcy5jb250cm9sLnJlc2V0KCdOYW5jeScpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmNvbnRyb2wudmFsdWUpOyAgLy8gJ05hbmN5J1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogT1JcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHRoaXMuY29udHJvbC5yZXNldCh7dmFsdWU6ICdOYW5jeScsIGRpc2FibGVkOiB0cnVlfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuY29udHJvbC52YWx1ZSk7ICAvLyAnTmFuY3knXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuY29udHJvbC5zdGF0dXMpOyAgLy8gJ0RJU0FCTEVEJ1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChmb3JtU3RhdGUsIF9hKSB7XG4gICAgICAgICAgICBpZiAoZm9ybVN0YXRlID09PSB2b2lkIDApIHsgZm9ybVN0YXRlID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Rm9ybVN0YXRlKGZvcm1TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLm1hcmtBc1ByaXN0aW5lKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5tYXJrQXNVbnRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuX3ZhbHVlLCB7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2FsbENvbnRyb2xzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpc2FibGVkOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgY2hhbmdlIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlLnB1c2goZm4pOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2NsZWFyQ2hhbmdlRm5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBmb3IgZGlzYWJsZWQgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlID0gZm47IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGNiKSB7IH07XG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fYXBwbHlGb3JtU3RhdGUgPSBmdW5jdGlvbiAoZm9ybVN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNCb3hlZFZhbHVlKGZvcm1TdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IGZvcm1TdGF0ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBmb3JtU3RhdGUuZGlzYWJsZWQgPyB0aGlzLmRpc2FibGUoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IGZvcm1TdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Db250cm9sO1xuICAgIH0oQWJzdHJhY3RDb250cm9sKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdGUgb2YgYSBncm91cCBvZiB7QGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQSBgRm9ybUdyb3VwYCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCBjaGlsZCB7QGxpbmsgRm9ybUNvbnRyb2x9IGludG8gb25lIG9iamVjdCxcbiAgICAgKiB3aXRoIGVhY2ggY29udHJvbCBuYW1lIGFzIHRoZSBrZXkuICBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1c2VzXG4gICAgICogb2YgaXRzIGNoaWxkcmVuLiBGb3IgZXhhbXBsZSwgaWYgb25lIG9mIHRoZSBjb250cm9scyBpbiBhIGdyb3VwIGlzIGludmFsaWQsIHRoZSBlbnRpcmVcbiAgICAgKiBncm91cCBiZWNvbWVzIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBgRm9ybUdyb3VwYCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxuICAgICAqIGFsb25nIHdpdGgge0BsaW5rIEZvcm1Db250cm9sfSBhbmQge0BsaW5rIEZvcm1BcnJheX0uXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFdoZW4gaW5zdGFudGlhdGluZyBhIHtAbGluayBGb3JtR3JvdXB9LCBwYXNzIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZCBjb250cm9scyBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gVGhlIGtleSBmb3IgZWFjaCBjaGlsZCB3aWxsIGJlIHRoZSBuYW1lIHVuZGVyIHdoaWNoIGl0IGlzIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnKSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDsgJ0RyZXcnfVxuICAgICAqIGNvbnNvbGUubG9nKGZvcm0uc3RhdHVzKTsgIC8vICdWQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbmNsdWRlIGdyb3VwLWxldmVsIHZhbGlkYXRvcnMgYXMgdGhlIHNlY29uZCBhcmcsIG9yIGdyb3VwLWxldmVsIGFzeW5jXG4gICAgICogdmFsaWRhdG9ycyBhcyB0aGUgdGhpcmQgYXJnLiBUaGVzZSBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gcGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICogdGhhdCBjb25zaWRlcnMgdGhlIHZhbHVlIG9mIG1vcmUgdGhhbiBvbmUgY2hpbGQgY29udHJvbC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICogICBwYXNzd29yZDogbmV3IEZvcm1Db250cm9sKCcnLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBwYXNzd29yZENvbmZpcm06IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqIH0sIHBhc3N3b3JkTWF0Y2hWYWxpZGF0b3IpO1xuICAgICAqXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBwYXNzd29yZE1hdGNoVmFsaWRhdG9yKGc6IEZvcm1Hcm91cCkge1xuICAgICAqICAgIHJldHVybiBnLmdldCgncGFzc3dvcmQnKS52YWx1ZSA9PT0gZy5nZXQoJ3Bhc3N3b3JkQ29uZmlybScpLnZhbHVlXG4gICAgICogICAgICAgPyBudWxsIDogeydtaXNtYXRjaCc6IHRydWV9O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Hcm91cCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ2KEZvcm1Hcm91cCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUdyb3VwKGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgICAgIHRoaXMuX2luaXRPYnNlcnZhYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9scygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGNvbnRyb2wgd2l0aCB0aGUgZ3JvdXAncyBsaXN0IG9mIGNvbnRyb2xzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBkb2VzIG5vdCB1cGRhdGUgdmFsdWUgb3IgdmFsaWRpdHkgb2YgdGhlIGNvbnRyb2wsIHNvIGZvclxuICAgICAgICAgKiBtb3N0IGNhc2VzIHlvdSdsbCB3YW50IHRvIHVzZSB7QGxpbmsgRm9ybUdyb3VwLmFkZENvbnRyb2x9IGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyQ29udHJvbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0gPSBjb250cm9sO1xuICAgICAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgICAgICBjb250cm9sLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSh0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2w7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBjb250cm9sIHRvIHRoaXMgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckNvbnRyb2wobmFtZSwgY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIGEgY29udHJvbCBmcm9tIHRoaXMgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tuYW1lXS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIFN0cmluZ01hcFdyYXBwZXIuZGVsZXRlKHRoaXMuY29udHJvbHMsIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2UgYW4gZXhpc3RpbmcgY29udHJvbC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuc2V0Q29udHJvbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5kZWxldGUodGhpcy5jb250cm9scywgbmFtZSk7XG4gICAgICAgICAgICBpZiAoY29udHJvbClcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbChuYW1lLCBjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZXJlIGlzIGFuIGVuYWJsZWQgY29udHJvbCB3aXRoIHRoZSBnaXZlbiBuYW1lIGluIHRoZSBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIGRpc2FibGVkIGNvbnRyb2xzLiBJZiB5b3UnZCBsaWtlIHRvIGNoZWNrIGZvclxuICAgICAgICAgKiBleGlzdGVuY2UgaW4gdGhlIGdyb3VwIG9ubHksIHVzZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoY29udHJvbE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmhhc093blByb3BlcnR5KGNvbnRyb2xOYW1lKSAmJiB0aGlzLmNvbnRyb2xzW2NvbnRyb2xOYW1lXS5lbmFibGVkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogIFNldHMgdGhlIHZhbHVlIG9mIHRoZSB7QGxpbmsgRm9ybUdyb3VwfS4gSXQgYWNjZXB0cyBhbiBvYmplY3QgdGhhdCBtYXRjaGVzXG4gICAgICAgICAqICB0aGUgc3RydWN0dXJlIG9mIHRoZSBncm91cCwgd2l0aCBjb250cm9sIG5hbWVzIGFzIGtleXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHN0cmljdCBjaGVja3MsIHNvIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgeW91IHRyeVxuICAgICAgICAgKiB0byBzZXQgdGhlIHZhbHVlIG9mIGEgY29udHJvbCB0aGF0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgeW91IGV4Y2x1ZGUgdGhlXG4gICAgICAgICAqIHZhbHVlIG9mIGEgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICogICAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICB9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogbnVsbCwgbGFzdDogbnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogIGZvcm0uc2V0VmFsdWUoe2ZpcnN0OiAnTmFuY3knLCBsYXN0OiAnRHJldyd9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDogJ0RyZXcnfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQodmFsdWUpO1xuICAgICAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5mb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAobmV3VmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nKG5hbWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2xzW25hbWVdLnNldFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUGF0Y2hlcyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtR3JvdXB9LiBJdCBhY2NlcHRzIGFuIG9iamVjdCB3aXRoIGNvbnRyb2xcbiAgICAgICAgICogIG5hbWVzIGFzIGtleXMsIGFuZCB3aWxsIGRvIGl0cyBiZXN0IHRvIG1hdGNoIHRoZSB2YWx1ZXMgdG8gdGhlIGNvcnJlY3QgY29udHJvbHNcbiAgICAgICAgICogIGluIHRoZSBncm91cC5cbiAgICAgICAgICpcbiAgICAgICAgICogIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgZ3JvdXAgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICogIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICogICAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICB9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogbnVsbCwgbGFzdDogbnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogIGZvcm0ucGF0Y2hWYWx1ZSh7Zmlyc3Q6ICdOYW5jeSd9KTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDogbnVsbH1cbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChuZXdWYWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb250cm9sc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sc1tuYW1lXS5wYXRjaFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSB7QGxpbmsgRm9ybUdyb3VwfS4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIFRoZSBncm91cCBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHByaXN0aW5lYFxuICAgICAgICAgKiAqIFRoZSBncm91cCBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHVudG91Y2hlZGBcbiAgICAgICAgICogKiBUaGUgdmFsdWUgb2YgYWxsIGRlc2NlbmRhbnRzIHdpbGwgYmUgbnVsbCBvciBudWxsIG1hcHNcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIGluIGEgbWFwIG9mIHN0YXRlc1xuICAgICAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiB5b3VyIGZvcm0sIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLiBUaGUgc3RhdGVcbiAgICAgICAgICogY2FuIGJlIGEgc3RhbmRhbG9uZSB2YWx1ZSBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHdpdGggYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkXG4gICAgICAgICAqIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogdGhpcy5mb3JtLnJlc2V0KHtmaXJzdDogJ25hbWUnLCBsYXN0OyAnbGFzdCBuYW1lJ30pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmZvcm0udmFsdWUpOyAgLy8ge2ZpcnN0OiAnbmFtZScsIGxhc3Q6ICdsYXN0IG5hbWUnfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogLSBPUiAtXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmZvcm0ucmVzZXQoe1xuICAgICAgICAgKiAgIGZpcnN0OiB7dmFsdWU6ICduYW1lJywgZGlzYWJsZWQ6IHRydWV9LFxuICAgICAgICAgKiAgIGxhc3Q6ICdsYXN0J1xuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5mb3JtLnZhbHVlKTsgIC8vIHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ31cbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5mb3JtLmdldCgnZmlyc3QnKS5zdGF0dXMpOyAgLy8gJ0RJU0FCTEVEJ1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5yZXNldCh2YWx1ZVtuYW1lXSwgeyBvbmx5U2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1Hcm91cH0sIGluY2x1ZGluZyBhbnkgZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSdkIGxpa2UgdG8gaW5jbHVkZSBhbGwgdmFsdWVzIHJlZ2FyZGxlc3Mgb2YgZGlzYWJsZWQgc3RhdHVzLCB1c2UgdGhpcyBtZXRob2QuXG4gICAgICAgICAqIE90aGVyd2lzZSwgdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgdGhlIGJlc3Qgd2F5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VDaGlsZHJlbih7fSwgZnVuY3Rpb24gKGFjYywgY29udHJvbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGFjY1tuYW1lXSA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3Rocm93SWZDb250cm9sTWlzc2luZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgVGhlcmUgYXJlIG5vIGZvcm0gY29udHJvbHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgZ3JvdXAgeWV0LiAgSWYgeW91J3JlIHVzaW5nIG5nTW9kZWwsXFxuICAgICAgICB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgbmV4dCB0aWNrIChlLmcuIHVzZSBzZXRUaW1lb3V0KS5cXG4gICAgICBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udHJvbHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBmb3JtIGNvbnRyb2wgd2l0aCBuYW1lOiBcIiArIG5hbWUgKyBcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fZm9yRWFjaENoaWxkID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmZvckVhY2godGhpcy5jb250cm9scywgY2IpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3NldFVwQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5zZXRQYXJlbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKF90aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZhbHVlID0gdGhpcy5fcmVkdWNlVmFsdWUoKTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcmVzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMgfHwgKF90aGlzLmNvbnRhaW5zKG5hbWUpICYmIGNvbmRpdGlvbihjb250cm9sKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fcmVkdWNlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKHt9LCBmdW5jdGlvbiAoYWNjLCBjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZCB8fCBfdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSBjb250cm9sLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fcmVkdWNlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoaW5pdFZhbHVlLCBmbikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGluaXRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkgeyByZXMgPSBmbihyZXMsIGNvbnRyb2wsIG5hbWUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fYWxsQ29udHJvbHNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbE5hbWUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbY29udHJvbE5hbWVdLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKS5sZW5ndGggPiAwIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBhIHZhbHVlIGZvciBmb3JtIGNvbnRyb2wgd2l0aCBuYW1lOiAnXCIgKyBuYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Hcm91cDtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGFuIGFycmF5IG9mIHtAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBBIGBGb3JtQXJyYXlgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBvZiBlYWNoIGNoaWxkIHtAbGluayBGb3JtQ29udHJvbH0gaW50byBhbiBhcnJheS5cbiAgICAgKiBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1c2VzIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZlxuICAgICAqIHRoZSBjb250cm9scyBpbiBhIGBGb3JtQXJyYXlgIGlzIGludmFsaWQsIHRoZSBlbnRpcmUgYXJyYXkgYmVjb21lcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogYEZvcm1BcnJheWAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcbiAgICAgKiBhbG9uZyB3aXRoIHtAbGluayBGb3JtQ29udHJvbH0gYW5kIHtAbGluayBGb3JtR3JvdXB9LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7QGxpbmsgRm9ybUFycmF5fSwgcGFzcyBpbiBhbiBhcnJheSBvZiBjaGlsZCBjb250cm9scyBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgKiAgIG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnKSxcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gWydOYW5jeScsICdEcmV3J11cbiAgICAgKiBjb25zb2xlLmxvZyhhcnIuc3RhdHVzKTsgIC8vICdWQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbmNsdWRlIGFycmF5LWxldmVsIHZhbGlkYXRvcnMgYXMgdGhlIHNlY29uZCBhcmcsIG9yIGFycmF5LWxldmVsIGFzeW5jXG4gICAgICogdmFsaWRhdG9ycyBhcyB0aGUgdGhpcmQgYXJnLiBUaGVzZSBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gcGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICogdGhhdCBjb25zaWRlcnMgdGhlIHZhbHVlIG9mIG1vcmUgdGhhbiBvbmUgY2hpbGQgY29udHJvbC5cbiAgICAgKlxuICAgICAqICMjIyBBZGRpbmcgb3IgcmVtb3ZpbmcgY29udHJvbHNcbiAgICAgKlxuICAgICAqIFRvIGNoYW5nZSB0aGUgY29udHJvbHMgaW4gdGhlIGFycmF5LCB1c2UgdGhlIGBwdXNoYCwgYGluc2VydGAsIG9yIGByZW1vdmVBdGAgbWV0aG9kc1xuICAgICAqIGluIGBGb3JtQXJyYXlgIGl0c2VsZi4gVGhlc2UgbWV0aG9kcyBlbnN1cmUgdGhlIGNvbnRyb2xzIGFyZSBwcm9wZXJseSB0cmFja2VkIGluIHRoZVxuICAgICAqIGZvcm0ncyBoaWVyYXJjaHkuIERvIG5vdCBtb2RpZnkgdGhlIGFycmF5IG9mIGBBYnN0cmFjdENvbnRyb2xgcyB1c2VkIHRvIGluc3RhbnRpYXRlXG4gICAgICogdGhlIGBGb3JtQXJyYXlgIGRpcmVjdGx5LCBhcyB0aGF0IHdpbGwgcmVzdWx0IGluIHN0cmFuZ2UgYW5kIHVuZXhwZWN0ZWQgYmVoYXZpb3Igc3VjaFxuICAgICAqIGFzIGJyb2tlbiBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUFycmF5LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQXJyYXkoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgICAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2xzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRyb2xzW2luZGV4XTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCBhIG5ldyB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnB1c2goY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGEgbmV3IHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCBjb250cm9sKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5pbnNlcnQodGhpcy5jb250cm9scywgaW5kZXgsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgY29udHJvbCBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnJlbW92ZUF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tpbmRleF0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCh0aGlzLmNvbnRyb2xzLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwbGFjZSBhbiBleGlzdGluZyBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5zZXRDb250cm9sID0gZnVuY3Rpb24gKGluZGV4LCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tpbmRleF0pXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sc1tpbmRleF0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVBdCh0aGlzLmNvbnRyb2xzLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLmluc2VydCh0aGlzLmNvbnRyb2xzLCBpbmRleCwgY29udHJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGVuZ3RoIG9mIHRoZSBjb250cm9sIGFycmF5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1BcnJheX0uIEl0IGFjY2VwdHMgYW4gYXJyYXkgdGhhdCBtYXRjaGVzXG4gICAgICAgICAqICB0aGUgc3RydWN0dXJlIG9mIHRoZSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBzdHJpY3QgY2hlY2tzLCBzbyBpdCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHlvdSB0cnlcbiAgICAgICAgICogdG8gc2V0IHRoZSB2YWx1ZSBvZiBhIGNvbnRyb2wgdGhhdCBkb2Vzbid0IGV4aXN0IG9yIGlmIHlvdSBleGNsdWRlIHRoZVxuICAgICAgICAgKiB2YWx1ZSBvZiBhIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqICBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIF0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbbnVsbCwgbnVsbF1cbiAgICAgICAgICpcbiAgICAgICAgICogIGFyci5zZXRWYWx1ZShbJ05hbmN5JywgJ0RyZXcnXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCAnRHJldyddXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCh2YWx1ZSk7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChuZXdWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nKGluZGV4KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hdChpbmRleCkuc2V0VmFsdWUobmV3VmFsdWUsIHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBQYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1BcnJheX0uIEl0IGFjY2VwdHMgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIHRoZVxuICAgICAgICAgKiAgc3RydWN0dXJlIG9mIHRoZSBjb250cm9sLCBhbmQgd2lsbCBkbyBpdHMgYmVzdCB0byBtYXRjaCB0aGUgdmFsdWVzIHRvIHRoZSBjb3JyZWN0XG4gICAgICAgICAqICBjb250cm9scyBpbiB0aGUgZ3JvdXAuXG4gICAgICAgICAqXG4gICAgICAgICAqICBJdCBhY2NlcHRzIGJvdGggc3VwZXItc2V0cyBhbmQgc3ViLXNldHMgb2YgdGhlIGFycmF5IHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqICBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIF0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbbnVsbCwgbnVsbF1cbiAgICAgICAgICpcbiAgICAgICAgICogIGFyci5wYXRjaFZhbHVlKFsnTmFuY3knXSk7XG4gICAgICAgICAqICBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCBudWxsXVxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKG5ld1ZhbHVlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdChpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLnBhdGNoVmFsdWUobmV3VmFsdWUsIHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIHtAbGluayBGb3JtQXJyYXl9LiBUaGlzIG1lYW5zIGJ5IGRlZmF1bHQ6XG4gICAgICAgICAqXG4gICAgICAgICAqICogVGhlIGFycmF5IGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgcHJpc3RpbmVgXG4gICAgICAgICAqICogVGhlIGFycmF5IGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgdW50b3VjaGVkYFxuICAgICAgICAgKiAqIFRoZSB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgd2lsbCBiZSBudWxsIG9yIG51bGwgbWFwc1xuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc3RhdGVzXG4gICAgICAgICAqIHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBjb250cm9sLiBUaGUgc3RhdGUgY2FuIGJlIGEgc3RhbmRhbG9uZSB2YWx1ZVxuICAgICAgICAgKiBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHdpdGggYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogdGhpcy5hcnIucmVzZXQoWyduYW1lJywgJ2xhc3QgbmFtZSddKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5hcnIudmFsdWUpOyAgLy8gWyduYW1lJywgJ2xhc3QgbmFtZSddXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiAtIE9SIC1cbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHRoaXMuYXJyLnJlc2V0KFtcbiAgICAgICAgICogICB7dmFsdWU6ICduYW1lJywgZGlzYWJsZWQ6IHRydWV9LFxuICAgICAgICAgKiAgICdsYXN0J1xuICAgICAgICAgKiBdKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5hcnIudmFsdWUpOyAgLy8gWyduYW1lJywgJ2xhc3QgbmFtZSddXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLmdldCgwKS5zdGF0dXMpOyAgLy8gJ0RJU0FCTEVEJ1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IFtdOyB9XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzZXQodmFsdWVbaW5kZXhdLCB7IG9ubHlTZWxmOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWdncmVnYXRlIHZhbHVlIG9mIHRoZSBhcnJheSwgaW5jbHVkaW5nIGFueSBkaXNhYmxlZCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgeW91J2QgbGlrZSB0byBpbmNsdWRlIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMsIHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyB0aGUgYmVzdCB3YXkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmdldFJhd1ZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jb250cm9scy5tYXAoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wudmFsdWU7IH0pOyB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3Rocm93SWZDb250cm9sTWlzc2luZyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgVGhlcmUgYXJlIG5vIGZvcm0gY29udHJvbHMgcmVnaXN0ZXJlZCB3aXRoIHRoaXMgYXJyYXkgeWV0LiAgSWYgeW91J3JlIHVzaW5nIG5nTW9kZWwsXFxuICAgICAgICB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgbmV4dCB0aWNrIChlLmcuIHVzZSBzZXRUaW1lb3V0KS5cXG4gICAgICBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgZm9ybSBjb250cm9sIGF0IGluZGV4IFwiICsgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2ZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sLCBpbmRleCkgeyBjYihjb250cm9sLCBpbmRleCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5jb250cm9scy5maWx0ZXIoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZW5hYmxlZCB8fCBfdGhpcy5kaXNhYmxlZDsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnZhbHVlOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLnNvbWUoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZW5hYmxlZCAmJiBjb25kaXRpb24oY29udHJvbCk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3NldFVwQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBfdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgaSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVtpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgc3VwcGx5IGEgdmFsdWUgZm9yIGZvcm0gY29udHJvbCBhdCBpbmRleDogXCIgKyBpICsgXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX2FsbENvbnRyb2xzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jb250cm9sczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5lbmFibGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5sZW5ndGggPiAwIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuX3JlZ2lzdGVyQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICBjb250cm9sLnNldFBhcmVudCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQXJyYXk7XG4gICAgfShBYnN0cmFjdENvbnRyb2wpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybURpcmVjdGl2ZVByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nRm9ybTsgfSlcbiAgICB9O1xuICAgIHZhciByZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHRvcC1sZXZlbCB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSBhbmQgYmluZHMgaXQgdG8gYSBmb3JtXG4gICAgICogdG8gdHJhY2sgYWdncmVnYXRlIGZvcm0gdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBBcyBzb29uIGFzIHlvdSBpbXBvcnQgdGhlIGBGb3Jtc01vZHVsZWAsIHRoaXMgZGlyZWN0aXZlIGJlY29tZXMgYWN0aXZlIGJ5IGRlZmF1bHQgb25cbiAgICAgKiBhbGwgYDxmb3JtPmAgdGFncy4gIFlvdSBkb24ndCBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdGb3JtYCBhcyB0aGUga2V5XG4gICAgICogKGV4OiBgI215Rm9ybT1cIm5nRm9ybVwiYCkuIFRoaXMgaXMgb3B0aW9uYWwsIGJ1dCB1c2VmdWwuICBNYW55IHByb3BlcnRpZXMgZnJvbSB0aGUgdW5kZXJseWluZ1xuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIGFyZSBkdXBsaWNhdGVkIG9uIHRoZSBkaXJlY3RpdmUgaXRzZWxmLCBzbyBhIHJlZmVyZW5jZSB0byBpdFxuICAgICAqIHdpbGwgZ2l2ZSB5b3UgYWNjZXNzIHRvIHRoZSBhZ2dyZWdhdGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXR1cyBvZiB0aGUgZm9ybSwgYXMgd2VsbCBhc1xuICAgICAqIHVzZXIgaW50ZXJhY3Rpb24gcHJvcGVydGllcyBsaWtlIGBkaXJ0eWAgYW5kIGB0b3VjaGVkYC5cbiAgICAgKlxuICAgICAqIFRvIHJlZ2lzdGVyIGNoaWxkIGNvbnRyb2xzIHdpdGggdGhlIGZvcm0sIHlvdSdsbCB3YW50IHRvIHVzZSB7QGxpbmsgTmdNb2RlbH0gd2l0aCBhXG4gICAgICogYG5hbWVgIGF0dHJpYnV0ZS4gIFlvdSBjYW4gYWxzbyB1c2Uge0BsaW5rIE5nTW9kZWxHcm91cH0gaWYgeW91J2QgbGlrZSB0byBjcmVhdGVcbiAgICAgKiBzdWItZ3JvdXBzIHdpdGhpbiB0aGUgZm9ybS5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gbGlzdGVuIHRvIHRoZSBkaXJlY3RpdmUncyBgbmdTdWJtaXRgIGV2ZW50IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHVzZXIgaGFzXG4gICAgICogdHJpZ2dlcmVkIGEgZm9ybSBzdWJtaXNzaW9uLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm0vc2ltcGxlX2Zvcm1fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nRm9ybSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KE5nRm9ybSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdGb3JtKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm0gPVxuICAgICAgICAgICAgICAgIG5ldyBGb3JtR3JvdXAoe30sIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpLCBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInN1Ym1pdHRlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N1Ym1pdHRlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImNvbnRyb2xzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtLmNvbnRyb2xzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGRpci5fY29udHJvbCA9IGNvbnRhaW5lci5yZWdpc3RlckNvbnRyb2woZGlyLm5hbWUsIGRpci5jb250cm9sKTtcbiAgICAgICAgICAgICAgICBzZXRVcENvbnRyb2woZGlyLmNvbnRyb2wsIGRpcik7XG4gICAgICAgICAgICAgICAgZGlyLmNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5nZXRDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICAgICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoZ3JvdXAsIGRpcik7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyQ29udHJvbChkaXIubmFtZSwgZ3JvdXApO1xuICAgICAgICAgICAgICAgIGdyb3VwLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuZ2V0Rm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZGlyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3RybCA9IF90aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuY29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUub25TdWJtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdC5lbWl0KG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLm9uUmVzZXQgPSBmdW5jdGlvbiAoKSB7IHRoaXMucmVzZXRGb3JtKCk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVzZXRGb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgdGhpcy5mb3JtLnJlc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuX2ZpbmRDb250YWluZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBMaXN0V3JhcHBlci5pc0VtcHR5KHBhdGgpID8gdGhpcy5mb3JtIDogdGhpcy5mb3JtLmdldChwYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdmb3JtOm5vdChbbmdOb0Zvcm1dKTpub3QoW2Zvcm1Hcm91cF0pLG5nRm9ybSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKHN1Ym1pdCknOiAnb25TdWJtaXQoKScsICcocmVzZXQpJzogJ29uUmVzZXQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsnbmdTdWJtaXQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nRm9ybS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nRm9ybTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgRXhhbXBsZXMgPSB7XG4gICAgICAgIGZvcm1Db250cm9sTmFtZTogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cXFwiZmlyc3ROYW1lXFxcIj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICBmaXJzdE5hbWU6IG5ldyBGb3JtQ29udHJvbCgpXFxuICAgIH0pO1wiLFxuICAgICAgICBmb3JtR3JvdXBOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICAgPGRpdiBmb3JtR3JvdXBOYW1lPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgICA8aW5wdXQgZm9ybUNvbnRyb2xOYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICBwZXJzb246IG5ldyBGb3JtR3JvdXAoeyBmaXJzdE5hbWU6IG5ldyBGb3JtQ29udHJvbCgpIH0pXFxuICAgIH0pO1wiLFxuICAgICAgICBmb3JtQXJyYXlOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICA8ZGl2IGZvcm1BcnJheU5hbWU9XFxcImNpdGllc1xcXCI+XFxuICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IGNpdHkgb2YgY2l0eUFycmF5LmNvbnRyb2xzOyBsZXQgaT1pbmRleFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBbZm9ybUNvbnRyb2xOYW1lXT1cXFwiaVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMuY2l0eUFycmF5ID0gbmV3IEZvcm1BcnJheShbbmV3IEZvcm1Db250cm9sKCdTRicpXSk7XFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgIGNpdGllczogdGhpcy5jaXR5QXJyYXlcXG4gICAgfSk7XCIsXG4gICAgICAgIG5nTW9kZWxHcm91cDogXCJcXG4gICAgPGZvcm0+XFxuICAgICAgIDxkaXYgbmdNb2RlbEdyb3VwPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInBlcnNvbi5uYW1lXFxcIiBuYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8L2Rpdj5cXG4gICAgPC9mb3JtPlwiLFxuICAgICAgICBuZ01vZGVsV2l0aEZvcm1Hcm91cDogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwic2hvd01vcmVDb250cm9sc1xcXCIgW25nTW9kZWxPcHRpb25zXT1cXFwie3N0YW5kYWxvbmU6IHRydWV9XFxcIj5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgIH07XG5cbiAgICB2YXIgVGVtcGxhdGVEcml2ZW5FcnJvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZURyaXZlbkVycm9ycygpIHtcbiAgICAgICAgfVxuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5tb2RlbFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIG5nTW9kZWwgY2Fubm90IGJlIHVzZWQgdG8gcmVnaXN0ZXIgZm9ybSBjb250cm9scyB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBUcnkgdXNpbmdcXG4gICAgICBmb3JtR3JvdXAncyBwYXJ0bmVyIGRpcmVjdGl2ZSBcXFwiZm9ybUNvbnRyb2xOYW1lXFxcIiBpbnN0ZWFkLiAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Db250cm9sTmFtZSArIFwiXFxuXFxuICAgICAgT3IsIGlmIHlvdSdkIGxpa2UgdG8gYXZvaWQgcmVnaXN0ZXJpbmcgdGhpcyBmb3JtIGNvbnRyb2wsIGluZGljYXRlIHRoYXQgaXQncyBzdGFuZGFsb25lIGluIG5nTW9kZWxPcHRpb25zOlxcblxcbiAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsV2l0aEZvcm1Hcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLmZvcm1Hcm91cE5hbWVFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBuZ01vZGVsIGNhbm5vdCBiZSB1c2VkIHRvIHJlZ2lzdGVyIGZvcm0gY29udHJvbHMgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXBOYW1lIG9yIGZvcm1BcnJheU5hbWUgZGlyZWN0aXZlLlxcblxcbiAgICAgIE9wdGlvbiAxOiBVc2UgZm9ybUNvbnRyb2xOYW1lIGluc3RlYWQgb2YgbmdNb2RlbCAocmVhY3RpdmUgc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgT3B0aW9uIDI6ICBVcGRhdGUgbmdNb2RlbCdzIHBhcmVudCBiZSBuZ01vZGVsR3JvdXAgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5taXNzaW5nTmFtZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmIG5nTW9kZWwgaXMgdXNlZCB3aXRoaW4gYSBmb3JtIHRhZywgZWl0aGVyIHRoZSBuYW1lIGF0dHJpYnV0ZSBtdXN0IGJlIHNldCBvciB0aGUgZm9ybVxcbiAgICAgIGNvbnRyb2wgbXVzdCBiZSBkZWZpbmVkIGFzICdzdGFuZGFsb25lJyBpbiBuZ01vZGVsT3B0aW9ucy5cXG5cXG4gICAgICBFeGFtcGxlIDE6IDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicGVyc29uLmZpcnN0TmFtZVxcXCIgbmFtZT1cXFwiZmlyc3RcXFwiPlxcbiAgICAgIEV4YW1wbGUgMjogPGlucHV0IFsobmdNb2RlbCldPVxcXCJwZXJzb24uZmlyc3ROYW1lXFxcIiBbbmdNb2RlbE9wdGlvbnNdPVxcXCJ7c3RhbmRhbG9uZTogdHJ1ZX1cXFwiPlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxHcm91cFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIG5nTW9kZWxHcm91cCBjYW5ub3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuXFxuXFxuICAgICAgT3B0aW9uIDE6IFVzZSBmb3JtR3JvdXBOYW1lIGluc3RlYWQgb2YgbmdNb2RlbEdyb3VwIChyZWFjdGl2ZSBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtR3JvdXBOYW1lICsgXCJcXG5cXG4gICAgICBPcHRpb24gMjogIFVzZSBhIHJlZ3VsYXIgZm9ybSB0YWcgaW5zdGVhZCBvZiB0aGUgZm9ybUdyb3VwIGRpcmVjdGl2ZSAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLm5nTW9kZWxHcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZURyaXZlbkVycm9ycztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBtb2RlbEdyb3VwUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdNb2RlbEdyb3VwOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhbmQgYmluZHMgYSB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIGFzIGEgY2hpbGQgb2Yge0BsaW5rIE5nRm9ybX0gKG9yIGluIG90aGVyIHdvcmRzLFxuICAgICAqIHdpdGhpbiBgPGZvcm0+YCB0YWdzKS5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGRpcmVjdGl2ZSBpZiB5b3UnZCBsaWtlIHRvIGNyZWF0ZSBhIHN1Yi1ncm91cCB3aXRoaW4gYSBmb3JtLiBUaGlzIGNhblxuICAgICAqIGNvbWUgaW4gaGFuZHkgaWYgeW91IHdhbnQgdG8gdmFsaWRhdGUgYSBzdWItZ3JvdXAgb2YgeW91ciBmb3JtIHNlcGFyYXRlbHkgZnJvbVxuICAgICAqIHRoZSByZXN0IG9mIHlvdXIgZm9ybSwgb3IgaWYgc29tZSB2YWx1ZXMgaW4geW91ciBkb21haW4gbW9kZWwgbWFrZSBtb3JlIHNlbnNlIHRvXG4gICAgICogY29uc3VtZSB0b2dldGhlciBpbiBhIG5lc3RlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBQYXNzIGluIHRoZSBuYW1lIHlvdSdkIGxpa2UgdGhpcyBzdWItZ3JvdXAgdG8gaGF2ZSBhbmQgaXQgd2lsbCBiZWNvbWUgdGhlIGtleVxuICAgICAqIGZvciB0aGUgc3ViLWdyb3VwIGluIHRoZSBmb3JtJ3MgZnVsbCB2YWx1ZS4gWW91IGNhbiBhbHNvIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG9cbiAgICAgKiBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ01vZGVsR3JvdXBgIChleDogYCNteUdyb3VwPVwibmdNb2RlbEdyb3VwXCJgKS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZ01vZGVsR3JvdXAvbmdfbW9kZWxfZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2RlbEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDgoTmdNb2RlbEdyb3VwLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ01vZGVsR3JvdXAocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ01vZGVsR3JvdXAucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdGb3JtKSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsR3JvdXBQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbEdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ01vZGVsR3JvdXBdJywgcHJvdmlkZXJzOiBbbW9kZWxHcm91cFByb3ZpZGVyXSwgZXhwb3J0QXM6ICduZ01vZGVsR3JvdXAnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdNb2RlbEdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ01vZGVsR3JvdXAucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbEdyb3VwJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kZWxHcm91cDtcbiAgICB9KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1Db250cm9sQmluZGluZyA9IHtcbiAgICAgICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nTW9kZWw7IH0pXG4gICAgfTtcbiAgICB2YXIgcmVzb2x2ZWRQcm9taXNlJDEgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgZnJvbSBhIGRvbWFpbiBtb2RlbCBhbmQgYmluZHMgaXRcbiAgICAgKiB0byBhIGZvcm0gY29udHJvbCBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhlIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2Ugd2lsbCB0cmFjayB0aGUgdmFsdWUsIHVzZXIgaW50ZXJhY3Rpb24sIGFuZFxuICAgICAqIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sIGFuZCBrZWVwIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSBtb2RlbC4gSWYgdXNlZFxuICAgICAqIHdpdGhpbiBhIHBhcmVudCBmb3JtLCB0aGUgZGlyZWN0aXZlIHdpbGwgYWxzbyByZWdpc3RlciBpdHNlbGYgd2l0aCB0aGUgZm9ybSBhcyBhIGNoaWxkXG4gICAgICogY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgYnkgaXRzZWxmIG9yIGFzIHBhcnQgb2YgYSBsYXJnZXIgZm9ybS4gQWxsIHlvdSBuZWVkIGlzIHRoZVxuICAgICAqIGBuZ01vZGVsYCBzZWxlY3RvciB0byBhY3RpdmF0ZSBpdC5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgYSBkb21haW4gbW9kZWwgYXMgYW4gb3B0aW9uYWwge0BsaW5rIEBJbnB1dH0uIElmIHlvdSBoYXZlIGEgb25lLXdheSBiaW5kaW5nXG4gICAgICogdG8gYG5nTW9kZWxgIHdpdGggYFtdYCBzeW50YXgsIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZG9tYWluIG1vZGVsIGluIHRoZSBjb21wb25lbnRcbiAgICAgKiBjbGFzcyB3aWxsIHNldCB0aGUgdmFsdWUgaW4gdGhlIHZpZXcuIElmIHlvdSBoYXZlIGEgdHdvLXdheSBiaW5kaW5nIHdpdGggYFsoKV1gIHN5bnRheFxuICAgICAqIChhbHNvIGtub3duIGFzICdiYW5hbmEtYm94IHN5bnRheCcpLCB0aGUgdmFsdWUgaW4gdGhlIFVJIHdpbGwgYWx3YXlzIGJlIHN5bmNlZCBiYWNrIHRvXG4gICAgICogdGhlIGRvbWFpbiBtb2RlbCBpbiB5b3VyIGNsYXNzIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBpbnNwZWN0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhc3NvY2lhdGVkIHtAbGluayBGb3JtQ29udHJvbH0gKGxpa2VcbiAgICAgKiB2YWxpZGl0eSBzdGF0ZSksIHlvdSBjYW4gYWxzbyBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmdcbiAgICAgKiBgbmdNb2RlbGAgYXMgdGhlIGtleSAoZXg6IGAjbXlWYXI9XCJuZ01vZGVsXCJgKS4gWW91IGNhbiB0aGVuIGFjY2VzcyB0aGUgY29udHJvbCB1c2luZyB0aGVcbiAgICAgKiBkaXJlY3RpdmUncyBgY29udHJvbGAgcHJvcGVydHksIGJ1dCBtb3N0IHByb3BlcnRpZXMgeW91J2xsIG5lZWQgKGxpa2UgYHZhbGlkYCBhbmQgYGRpcnR5YClcbiAgICAgKiB3aWxsIGZhbGwgdGhyb3VnaCB0byB0aGUgY29udHJvbCBhbnl3YXksIHNvIHlvdSBjYW4gYWNjZXNzIHRoZW0gZGlyZWN0bHkuIFlvdSBjYW4gc2VlIGFcbiAgICAgKiBmdWxsIGxpc3Qgb2YgcHJvcGVydGllcyBkaXJlY3RseSBhdmFpbGFibGUgaW4ge0BsaW5rIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZX0uXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGUgb2YgYSBzaW1wbGUgc3RhbmRhbG9uZSBjb250cm9sIHVzaW5nIGBuZ01vZGVsYDpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVOZ01vZGVsL3NpbXBsZV9uZ19tb2RlbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIGBuZ01vZGVsYCB3aXRoaW4gYDxmb3JtPmAgdGFncywgeW91J2xsIGFsc28gbmVlZCB0byBzdXBwbHkgYSBgbmFtZWAgYXR0cmlidXRlXG4gICAgICogc28gdGhhdCB0aGUgY29udHJvbCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBwYXJlbnQgZm9ybSB1bmRlciB0aGF0IG5hbWUuXG4gICAgICpcbiAgICAgKiBJdCdzIHdvcnRoIG5vdGluZyB0aGF0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGZvcm0sIHlvdSBvZnRlbiBjYW4gc2tpcCBvbmUtd2F5IG9yXG4gICAgICogdHdvLXdheSBiaW5kaW5nIGJlY2F1c2UgdGhlIHBhcmVudCBmb3JtIHdpbGwgc3luYyB0aGUgdmFsdWUgZm9yIHlvdS4gWW91IGNhbiBhY2Nlc3NcbiAgICAgKiBpdHMgcHJvcGVydGllcyBieSBleHBvcnRpbmcgaXQgaW50byBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ0Zvcm1gIChleDpcbiAgICAgKiBgI2Y9XCJuZ0Zvcm1cImApLiBUaGVuIHlvdSBjYW4gcGFzcyBpdCB3aGVyZSBpdCBuZWVkcyB0byBnbyBvbiBzdWJtaXQuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgZG8gbmVlZCB0byBwb3B1bGF0ZSBpbml0aWFsIHZhbHVlcyBpbnRvIHlvdXIgZm9ybSwgdXNpbmcgYSBvbmUtd2F5IGJpbmRpbmcgZm9yXG4gICAgICogYG5nTW9kZWxgIHRlbmRzIHRvIGJlIHN1ZmZpY2llbnQgYXMgbG9uZyBhcyB5b3UgdXNlIHRoZSBleHBvcnRlZCBmb3JtJ3MgdmFsdWUgcmF0aGVyXG4gICAgICogdGhhbiB0aGUgZG9tYWluIG1vZGVsJ3MgdmFsdWUgb24gc3VibWl0LlxuICAgICAqXG4gICAgICogVGFrZSBhIGxvb2sgYXQgYW4gZXhhbXBsZSBvZiB1c2luZyBgbmdNb2RlbGAgd2l0aGluIGEgZm9ybTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtL3NpbXBsZV9mb3JtX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nTW9kZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNyhOZ01vZGVsLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ01vZGVsKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9jb250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tGb3JFcnJvcnMoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVnaXN0ZXJlZClcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2woKTtcbiAgICAgICAgICAgIGlmICgnaXNEaXNhYmxlZCcgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZm9ybURpcmVjdGl2ZSAmJiB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlQ29udHJvbCh0aGlzKTsgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jb250cm9sOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KSA6IFt0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ01vZGVsLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3NldFVwQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU3RhbmRhbG9uZSgpID8gdGhpcy5fc2V0VXBTdGFuZGFsb25lKCkgOlxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9pc1N0YW5kYWxvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX3BhcmVudCB8fCAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5zdGFuZGFsb25lKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3NldFVwU3RhbmRhbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFVwQ29udHJvbCh0aGlzLl9jb250cm9sLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja0ZvckVycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNTdGFuZGFsb25lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fY2hlY2tQYXJlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMuZm9ybUdyb3VwTmFtZUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdGb3JtKSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5uYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSAmJiAhdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubWlzc2luZ05hbWVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3VwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbihmdW5jdGlvbiAoKSB7IF90aGlzLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUsIHsgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZSB9KTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl91cGRhdGVEaXNhYmxlZCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkVmFsdWUgPSBjaGFuZ2VzWydpc0Rpc2FibGVkJ10uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBkaXNhYmxlZFZhbHVlICE9IG51bGwgJiYgZGlzYWJsZWRWYWx1ZSAhPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZSQxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkICYmICFfdGhpcy5jb250cm9sLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuZGlzYWJsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNEaXNhYmxlZCAmJiBfdGhpcy5jb250cm9sLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ01vZGVsXTpub3QoW2Zvcm1Db250cm9sTmFtZV0pOm5vdChbZm9ybUNvbnRyb2xdKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtQ29udHJvbEJpbmRpbmddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ01vZGVsJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nTW9kZWwuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ01vZGVsLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICdpc0Rpc2FibGVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydkaXNhYmxlZCcsXSB9LF0sXG4gICAgICAgICAgICAnbW9kZWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWwnLF0gfSxdLFxuICAgICAgICAgICAgJ29wdGlvbnMnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWxPcHRpb25zJyxdIH0sXSxcbiAgICAgICAgICAgICd1cGRhdGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCwgYXJnczogWyduZ01vZGVsQ2hhbmdlJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kZWw7XG4gICAgfShOZ0NvbnRyb2wpKTtcblxuICAgIHZhciBSZWFjdGl2ZUVycm9ycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlYWN0aXZlRXJyb3JzKCkge1xuICAgICAgICB9XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmNvbnRyb2xQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtQ29udHJvbE5hbWUgbXVzdCBiZSB1c2VkIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS4gIFlvdSdsbCB3YW50IHRvIGFkZCBhIGZvcm1Hcm91cFxcbiAgICAgICBkaXJlY3RpdmUgYW5kIHBhc3MgaXQgYW4gZXhpc3RpbmcgRm9ybUdyb3VwIGluc3RhbmNlICh5b3UgY2FuIGNyZWF0ZSBvbmUgaW4geW91ciBjbGFzcykuXFxuXFxuICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Db250cm9sTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLm5nTW9kZWxHcm91cEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Db250cm9sTmFtZSBjYW5ub3QgYmUgdXNlZCB3aXRoIGFuIG5nTW9kZWxHcm91cCBwYXJlbnQuIEl0IGlzIG9ubHkgY29tcGF0aWJsZSB3aXRoIHBhcmVudHNcXG4gICAgICAgdGhhdCBhbHNvIGhhdmUgYSBcXFwiZm9ybVxcXCIgcHJlZml4OiBmb3JtR3JvdXBOYW1lLCBmb3JtQXJyYXlOYW1lLCBvciBmb3JtR3JvdXAuXFxuXFxuICAgICAgIE9wdGlvbiAxOiAgVXBkYXRlIHRoZSBwYXJlbnQgdG8gYmUgZm9ybUdyb3VwTmFtZSAocmVhY3RpdmUgZm9ybSBzdHJhdGVneSlcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgICBPcHRpb24gMjogVXNlIG5nTW9kZWwgaW5zdGVhZCBvZiBmb3JtQ29udHJvbE5hbWUgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSlcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMubmdNb2RlbEdyb3VwKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMubWlzc2luZ0Zvcm1FeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtR3JvdXAgZXhwZWN0cyBhIEZvcm1Hcm91cCBpbnN0YW5jZS4gUGxlYXNlIHBhc3Mgb25lIGluLlxcblxcbiAgICAgICBFeGFtcGxlOlxcblxcbiAgICAgICBcIiArIEV4YW1wbGVzLmZvcm1Db250cm9sTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmdyb3VwUGFyZW50RXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUdyb3VwTmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXFxuICAgICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxcblxcbiAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtR3JvdXBOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuYXJyYXlQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtQXJyYXlOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcXG4gICAgICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxcblxcbiAgICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUFycmF5TmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0aXZlRXJyb3JzLmRpc2FibGVkQXR0cldhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcXG4gICAgICBJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIHdpdGggYSByZWFjdGl2ZSBmb3JtIGRpcmVjdGl2ZS4gSWYgeW91IHNldCBkaXNhYmxlZCB0byB0cnVlXFxuICAgICAgd2hlbiB5b3Ugc2V0IHVwIHRoaXMgY29udHJvbCBpbiB5b3VyIGNvbXBvbmVudCBjbGFzcywgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSB3aWxsIGFjdHVhbGx5IGJlIHNldCBpbiB0aGUgRE9NIGZvclxcbiAgICAgIHlvdS4gV2UgcmVjb21tZW5kIHVzaW5nIHRoaXMgYXBwcm9hY2ggdG8gYXZvaWQgJ2NoYW5nZWQgYWZ0ZXIgY2hlY2tlZCcgZXJyb3JzLlxcbiAgICAgICBcXG4gICAgICBFeGFtcGxlOiBcXG4gICAgICBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XFxuICAgICAgICBmaXJzdDogbmV3IEZvcm1Db250cm9sKHt2YWx1ZTogJ05hbmN5JywgZGlzYWJsZWQ6IHRydWV9LCBWYWxpZGF0b3JzLnJlcXVpcmVkKSxcXG4gICAgICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgnRHJldycsIFZhbGlkYXRvcnMucmVxdWlyZWQpXFxuICAgICAgfSk7XFxuICAgIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlYWN0aXZlRXJyb3JzO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ5ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1Db250cm9sQmluZGluZyQxID0ge1xuICAgICAgICBwcm92aWRlOiBOZ0NvbnRyb2wsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUNvbnRyb2xEaXJlY3RpdmU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBTeW5jcyBhIHN0YW5kYWxvbmUge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSB0byBhIGZvcm0gY29udHJvbCBlbGVtZW50LlxuICAgICAqXG4gICAgICogSW4gb3RoZXIgd29yZHMsIHRoaXMgZGlyZWN0aXZlIGVuc3VyZXMgdGhhdCBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIHtAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZSBwcm9ncmFtbWF0aWNhbGx5IHdpbGwgYmUgd3JpdHRlbiB0byB0aGUgRE9NIGVsZW1lbnQgKG1vZGVsIC0+IHZpZXcpLiBDb252ZXJzZWx5LFxuICAgICAqIGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUgRE9NIGVsZW1lbnQgdGhyb3VnaCB1c2VyIGlucHV0IHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZVxuICAgICAqIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgKHZpZXcgLT4gbW9kZWwpLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBkaXJlY3RpdmUgaWYgeW91J2QgbGlrZSB0byBjcmVhdGUgYW5kIG1hbmFnZSBhIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgZGlyZWN0bHkuXG4gICAgICogU2ltcGx5IGNyZWF0ZSBhIHtAbGluayBGb3JtQ29udHJvbH0sIHNhdmUgaXQgdG8geW91ciBjb21wb25lbnQgY2xhc3MsIGFuZCBwYXNzIGl0IGludG8gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Db250cm9sRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgYXMgYSBzdGFuZGFsb25lIGNvbnRyb2wuICBVbmxpa2Uge0BsaW5rIEZvcm1Db250cm9sTmFtZX0sXG4gICAgICogaXQgZG9lcyBub3QgcmVxdWlyZSB0aGF0IHlvdXIge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSBiZSBwYXJ0IG9mIGFueSBwYXJlbnRcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSwgYW5kIGl0IHdvbid0IGJlIHJlZ2lzdGVyZWQgdG8gYW55IHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IHRoYXRcbiAgICAgKiBleGlzdHMgYWJvdmUgaXQuXG4gICAgICpcbiAgICAgKiAqKkdldCB0aGUgdmFsdWUqKjogdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgYWx3YXlzIHN5bmNlZCBhbmQgYXZhaWxhYmxlIG9uIHRoZVxuICAgICAqIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UuIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpblxuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogKipTZXQgdGhlIHZhbHVlKio6IFlvdSBjYW4gcGFzcyBpbiBhbiBpbml0aWFsIHZhbHVlIHdoZW4gaW5zdGFudGlhdGluZyB0aGUge0BsaW5rIEZvcm1Db250cm9sfSxcbiAgICAgKiBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvIGxpc3RlbiB0b1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtQ29udHJvbC9zaW1wbGVfZm9ybV9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgUmVhY3RpdmVGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDkoRm9ybUNvbnRyb2xEaXJlY3RpdmUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Db250cm9sRGlyZWN0aXZlKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9yYXdWYWxpZGF0b3JzID0gdmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaXNEaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7IFJlYWN0aXZlRXJyb3JzLmRpc2FibGVkQXR0cldhcm5pbmcoKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNDb250cm9sQ2hhbmdlZChjaGFuZ2VzKSkge1xuICAgICAgICAgICAgICAgIHNldFVwQ29udHJvbCh0aGlzLmZvcm0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybS51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0uc2V0VmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fcmF3VmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLnZpZXdUb01vZGVsVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUuZW1pdChuZXdWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZS5faXNDb250cm9sQ2hhbmdlZCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlci5jb250YWlucyhjaGFuZ2VzLCAnZm9ybScpO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xdJywgcHJvdmlkZXJzOiBbZm9ybUNvbnRyb2xCaW5kaW5nJDFdLCBleHBvcnRBczogJ25nRm9ybScgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTFVFX0FDQ0VTU09SLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ2Zvcm0nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Db250cm9sJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAndXBkYXRlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQsIGFyZ3M6IFsnbmdNb2RlbENoYW5nZScsXSB9LF0sXG4gICAgICAgICAgICAnaXNEaXNhYmxlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZGlzYWJsZWQnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUNvbnRyb2xEaXJlY3RpdmU7XG4gICAgfShOZ0NvbnRyb2wpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1EaXJlY3RpdmVQcm92aWRlciQxID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Hcm91cERpcmVjdGl2ZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIEJpbmRzIGFuIGV4aXN0aW5nIHtAbGluayBGb3JtR3JvdXB9IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGFjY2VwdHMgYW4gZXhpc3Rpbmcge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UuIEl0IHdpbGwgdGhlbiB1c2UgdGhpc1xuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHRvIG1hdGNoIGFueSBjaGlsZCB7QGxpbmsgRm9ybUNvbnRyb2x9LCB7QGxpbmsgRm9ybUdyb3VwfSxcbiAgICAgKiBhbmQge0BsaW5rIEZvcm1BcnJheX0gaW5zdGFuY2VzIHRvIGNoaWxkIHtAbGluayBGb3JtQ29udHJvbE5hbWV9LCB7QGxpbmsgRm9ybUdyb3VwTmFtZX0sXG4gICAgICogYW5kIHtAbGluayBGb3JtQXJyYXlOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogKipTZXQgdmFsdWUqKjogWW91IGNhbiBzZXQgdGhlIGZvcm0ncyBpbml0aWFsIHZhbHVlIHdoZW4gaW5zdGFudGlhdGluZyB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZyB0aGUge0BsaW5rIEZvcm1Hcm91cH0nc1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX0gbWV0aG9kcy5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgZm9ybSwgeW91IGNhbiBzdWJzY3JpYmVcbiAgICAgKiB0byB0aGUge0BsaW5rIEZvcm1Hcm91cH0ncyB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICogaXRzIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIEluIHRoaXMgZXhhbXBsZSwgd2UgY3JlYXRlIGZvcm0gY29udHJvbHMgZm9yIGZpcnN0IG5hbWUgYW5kIGxhc3QgbmFtZS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICoqTmdNb2R1bGUqKjoge0BsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9XG4gICAgICpcbiAgICAgKiAgQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtR3JvdXBEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTEoRm9ybUdyb3VwRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtR3JvdXBEaXJlY3RpdmUoX3ZhbGlkYXRvcnMsIF9hc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IF92YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gX2FzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gW107XG4gICAgICAgICAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9ybVByZXNlbnQoKTtcbiAgICAgICAgICAgIGlmIChTdHJpbmdNYXBXcmFwcGVyLmNvbnRhaW5zKGNoYW5nZXMsICdmb3JtJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVWYWxpZGF0b3JzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVSZWdpc3RyYXRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInN1Ym1pdHRlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N1Ym1pdHRlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcENvbnRyb2woY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgcmV0dXJuIGN0cmw7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0Q29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlbW92ZUNvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IExpc3RXcmFwcGVyLnJlbW92ZSh0aGlzLmRpcmVjdGl2ZXMsIGRpcik7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIHNldFVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZW1vdmVGb3JtR3JvdXAgPSBmdW5jdGlvbiAoZGlyKSB7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0Rm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuYWRkRm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIHNldFVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZW1vdmVGb3JtQXJyYXkgPSBmdW5jdGlvbiAoZGlyKSB7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuZ2V0Rm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZGlyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGN0cmwgPSB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgIGN0cmwuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm9uU3VibWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQuZW1pdChudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5vblJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJlc2V0Rm9ybSgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlc2V0Rm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVEb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0N0cmwgPSBfdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpci5fY29udHJvbCAhPT0gbmV3Q3RybCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhblVwQ29udHJvbChkaXIuX2NvbnRyb2wsIGRpcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDdHJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VXBDb250cm9sKG5ld0N0cmwsIGRpcik7XG4gICAgICAgICAgICAgICAgICAgIGRpci5fY29udHJvbCA9IG5ld0N0cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZvcm0uX3VwZGF0ZVRyZWVWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVJlZ2lzdHJhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5mb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkRm9ybSlcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRGb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb2xkRm9ybSA9IHRoaXMuZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzeW5jID0gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0udmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt0aGlzLmZvcm0udmFsaWRhdG9yLCBzeW5jXSk7XG4gICAgICAgICAgICB2YXIgYXN5bmMgPSBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX2FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0uYXN5bmNWYWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyhbdGhpcy5mb3JtLmFzeW5jVmFsaWRhdG9yLCBhc3luY10pO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja0Zvcm1QcmVzZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5mb3JtKSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLm1pc3NpbmdGb3JtRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZm9ybURpcmVjdGl2ZVByb3ZpZGVyJDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKHN1Ym1pdCknOiAnb25TdWJtaXQoKScsICcocmVzZXQpJzogJ29uUmVzZXQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ2Zvcm0nOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Hcm91cCcsXSB9LF0sXG4gICAgICAgICAgICAnbmdTdWJtaXQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgfShDb250cm9sQ29udGFpbmVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBmb3JtR3JvdXBOYW1lUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUdyb3VwTmFtZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFN5bmNzIGEgbmVzdGVkIHtAbGluayBGb3JtR3JvdXB9IHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIHBhcmVudCB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfSAoc2VsZWN0b3I6XG4gICAgICogYFtmb3JtR3JvdXBdYCkuXG4gICAgICpcbiAgICAgKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgbmVzdGVkIHtAbGluayBGb3JtR3JvdXB9IHlvdSB3YW50IHRvIGxpbmssIGFuZFxuICAgICAqIHdpbGwgbG9vayBmb3IgYSB7QGxpbmsgRm9ybUdyb3VwfSByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZSBwYXJlbnRcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB5b3UgcGFzc2VkIGludG8ge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0uXG4gICAgICpcbiAgICAgKiBOZXN0ZWQgZm9ybSBncm91cHMgY2FuIGNvbWUgaW4gaGFuZHkgd2hlbiB5b3Ugd2FudCB0byB2YWxpZGF0ZSBhIHN1Yi1ncm91cCBvZiBhXG4gICAgICogZm9ybSBzZXBhcmF0ZWx5IGZyb20gdGhlIHJlc3Qgb3Igd2hlbiB5b3UnZCBsaWtlIHRvIGdyb3VwIHRoZSB2YWx1ZXMgb2YgY2VydGFpblxuICAgICAqIGNvbnRyb2xzIGludG8gdGhlaXIgb3duIG5lc3RlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgZ3JvdXAqKjogWW91IGNhbiBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQge0BsaW5rIEZvcm1Hcm91cH0gdXNpbmcgdGhlXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5nZXR9IG1ldGhvZC4gRXg6IGB0aGlzLmZvcm0uZ2V0KCduYW1lJylgLlxuICAgICAqXG4gICAgICogWW91IGNhbiBhbHNvIGFjY2VzcyBpbmRpdmlkdWFsIGNvbnRyb2xzIHdpdGhpbiB0aGUgZ3JvdXAgdXNpbmcgZG90IHN5bnRheC5cbiAgICAgKiBFeDogYHRoaXMuZm9ybS5nZXQoJ25hbWUuZmlyc3QnKWBcbiAgICAgKlxuICAgICAqICoqR2V0IHRoZSB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0uIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICoqU2V0IHRoZSB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciBlYWNoIGNoaWxkIGNvbnRyb2wgd2hlbiBpbnN0YW50aWF0aW5nXG4gICAgICogdGhlIHtAbGluayBGb3JtR3JvdXB9LCBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgZ3JvdXAsIHlvdSBjYW5cbiAgICAgKiBzdWJzY3JpYmUgdG8gdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzbyBsaXN0ZW4gdG9cbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c0NoYW5nZXN9IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHZhbGlkYXRpb24gc3RhdHVzIGlzXG4gICAgICogcmUtY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvbmVzdGVkRm9ybUdyb3VwL25lc3RlZF9mb3JtX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgUmVhY3RpdmVGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUdyb3VwTmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMihGb3JtR3JvdXBOYW1lLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtR3JvdXBOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwTmFtZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMuZ3JvdXBQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwTmFtZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUdyb3VwTmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtR3JvdXBOYW1lUHJvdmlkZXJdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUdyb3VwTmFtZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1Hcm91cE5hbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUdyb3VwTmFtZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtR3JvdXBOYW1lO1xuICAgIH0oQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpKTtcbiAgICB2YXIgZm9ybUFycmF5TmFtZVByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1BcnJheU5hbWU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBTeW5jcyBhIG5lc3RlZCB7QGxpbmsgRm9ybUFycmF5fSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBpcyBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggYSBwYXJlbnQge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gKHNlbGVjdG9yOlxuICAgICAqIGBbZm9ybUdyb3VwXWApLlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIG5lc3RlZCB7QGxpbmsgRm9ybUFycmF5fSB5b3Ugd2FudCB0byBsaW5rLCBhbmRcbiAgICAgKiB3aWxsIGxvb2sgZm9yIGEge0BsaW5rIEZvcm1BcnJheX0gcmVnaXN0ZXJlZCB3aXRoIHRoYXQgbmFtZSBpbiB0aGUgcGFyZW50XG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgeW91IHBhc3NlZCBpbnRvIHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogTmVzdGVkIGZvcm0gYXJyYXlzIGNhbiBjb21lIGluIGhhbmR5IHdoZW4geW91IGhhdmUgYSBncm91cCBvZiBmb3JtIGNvbnRyb2xzIGJ1dFxuICAgICAqIHlvdSdyZSBub3Qgc3VyZSBob3cgbWFueSB0aGVyZSB3aWxsIGJlLiBGb3JtIGFycmF5cyBhbGxvdyB5b3UgdG8gY3JlYXRlIG5ld1xuICAgICAqIGZvcm0gY29udHJvbHMgZHluYW1pY2FsbHkuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgYXJyYXkqKjogWW91IGNhbiBhY2Nlc3MgdGhlIGFzc29jaWF0ZWQge0BsaW5rIEZvcm1BcnJheX0gdXNpbmcgdGhlXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5nZXR9IG1ldGhvZCBvbiB0aGUgcGFyZW50IHtAbGluayBGb3JtR3JvdXB9LlxuICAgICAqIEV4OiBgdGhpcy5mb3JtLmdldCgnY2l0aWVzJylgLlxuICAgICAqXG4gICAgICogKipHZXQgdGhlIHZhbHVlKio6IHRoZSBgdmFsdWVgIHByb3BlcnR5IGlzIGFsd2F5cyBzeW5jZWQgYW5kIGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUFycmF5fS4gU2VlIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGluIHtAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogKipTZXQgdGhlIHZhbHVlKio6IFlvdSBjYW4gc2V0IGFuIGluaXRpYWwgdmFsdWUgZm9yIGVhY2ggY2hpbGQgY29udHJvbCB3aGVuIGluc3RhbnRpYXRpbmdcbiAgICAgKiB0aGUge0BsaW5rIEZvcm1BcnJheX0sIG9yIHlvdSBjYW4gc2V0IHRoZSB2YWx1ZSBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nIHRoZVxuICAgICAqIHtAbGluayBGb3JtQXJyYXl9J3Mge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfVxuICAgICAqIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiAqKkxpc3RlbiB0byB2YWx1ZSoqOiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIGFycmF5LCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgRm9ybUFycmF5fSdzIHtAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzb1xuICAgICAqIGxpc3RlbiB0byBpdHMge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uXG4gICAgICogc3RhdHVzIGlzIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAqKkFkZCBuZXcgY29udHJvbHMqKjogWW91IGNhbiBhZGQgbmV3IGNvbnRyb2xzIHRvIHRoZSB7QGxpbmsgRm9ybUFycmF5fSBkeW5hbWljYWxseSBieVxuICAgICAqIGNhbGxpbmcgaXRzIHtAbGluayBGb3JtQXJyYXkucHVzaH0gbWV0aG9kLlxuICAgICAqICBFeDogYHRoaXMuZm9ybS5nZXQoJ2NpdGllcycpLnB1c2gobmV3IEZvcm1Db250cm9sKCkpO2BcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvbmVzdGVkRm9ybUFycmF5L25lc3RlZF9mb3JtX2FycmF5X2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICogKipOZ01vZHVsZSoqOiBgUmVhY3RpdmVGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUFycmF5TmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMihGb3JtQXJyYXlOYW1lLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQXJyYXlOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzO1xuICAgICAgICB9XG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkRm9ybUFycmF5KHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlRm9ybUFycmF5KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybURpcmVjdGl2ZS5nZXRGb3JtQXJyYXkodGhpcyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUFycmF5TmFtZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMuYXJyYXlQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUFycmF5TmFtZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUFycmF5TmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtQXJyYXlOYW1lUHJvdmlkZXJdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUFycmF5TmFtZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUFycmF5TmFtZScsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQXJyYXlOYW1lO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuICAgIGZ1bmN0aW9uIF9oYXNJbnZhbGlkUGFyZW50KHBhcmVudCkge1xuICAgICAgICByZXR1cm4gIShwYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBOYW1lKSAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cERpcmVjdGl2ZSkgJiZcbiAgICAgICAgICAgICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUFycmF5TmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgY29udHJvbE5hbWVCaW5kaW5nID0ge1xuICAgICAgICBwcm92aWRlOiBOZ0NvbnRyb2wsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUNvbnRyb2xOYW1lOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgIFN5bmNzIGEge0BsaW5rIEZvcm1Db250cm9sfSBpbiBhbiBleGlzdGluZyB7QGxpbmsgRm9ybUdyb3VwfSB0byBhIGZvcm0gY29udHJvbFxuICAgICAqIGVsZW1lbnQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEluIG90aGVyIHdvcmRzLCB0aGlzIGRpcmVjdGl2ZSBlbnN1cmVzIHRoYXQgYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9XG4gICAgICogaW5zdGFuY2UgcHJvZ3JhbW1hdGljYWxseSB3aWxsIGJlIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IChtb2RlbCAtPiB2aWV3KS4gQ29udmVyc2VseSxcbiAgICAgKiBhbnkgdmFsdWVzIHdyaXR0ZW4gdG8gdGhlIERPTSBlbGVtZW50IHRocm91Z2ggdXNlciBpbnB1dCB3aWxsIGJlIHJlZmxlY3RlZCBpbiB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlICh2aWV3IC0+IG1vZGVsKS5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIGEgcGFyZW50IHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IChzZWxlY3RvcjpcbiAgICAgKiBgW2Zvcm1Hcm91cF1gKS5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIHlvdSB3YW50IHRvXG4gICAgICogbGluaywgYW5kIHdpbGwgbG9vayBmb3IgYSB7QGxpbmsgRm9ybUNvbnRyb2x9IHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlXG4gICAgICogY2xvc2VzdCB7QGxpbmsgRm9ybUdyb3VwfSBvciB7QGxpbmsgRm9ybUFycmF5fSBhYm92ZSBpdC5cbiAgICAgKlxuICAgICAqICoqQWNjZXNzIHRoZSBjb250cm9sKio6IFlvdSBjYW4gYWNjZXNzIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9IGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIHRoaXMgZGlyZWN0aXZlIGJ5IHVzaW5nIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLmdldH0gbWV0aG9kLlxuICAgICAqIEV4OiBgdGhpcy5mb3JtLmdldCgnZmlyc3QnKTtgXG4gICAgICpcbiAgICAgKiAqKkdldCB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlIHtAbGluayBGb3JtQ29udHJvbH0uXG4gICAgICogU2VlIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGluIHtAbGluayBBYnN0cmFjdENvbnRyb2x9LlxuICAgICAqXG4gICAgICogICoqU2V0IHZhbHVlKio6IFlvdSBjYW4gc2V0IGFuIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBjb250cm9sIHdoZW4gaW5zdGFudGlhdGluZyB0aGVcbiAgICAgKiAge0BsaW5rIEZvcm1Db250cm9sfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZ1xuICAgICAqICB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnNldFZhbHVlfSBvciB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9LlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogSW4gdGhpcyBleGFtcGxlLCB3ZSBjcmVhdGUgZm9ybSBjb250cm9scyBmb3IgZmlyc3QgbmFtZSBhbmQgbGFzdCBuYW1lLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm1Hcm91cC9zaW1wbGVfZm9ybV9ncm91cF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogICogKipOZ01vZHVsZSoqOiB7QGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX1cbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sTmFtZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQxMChGb3JtQ29udHJvbE5hbWUsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Db250cm9sTmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJpc0Rpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHsgUmVhY3RpdmVFcnJvcnMuZGlzYWJsZWRBdHRyV2FybmluZygpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2FkZGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUudXBkYXRlTW9kZWwodGhpcywgdGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2wodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl9yYXdWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRyb2w7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBOYW1lKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgUmVhY3RpdmVFcnJvcnMubmdNb2RlbEdyb3VwRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwRGlyZWN0aXZlKSAmJlxuICAgICAgICAgICAgICAgICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUFycmF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5jb250cm9sUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUuX3NldFVwQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbCA9IHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbC5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbE5hbWVdJywgcHJvdmlkZXJzOiBbY29udHJvbE5hbWVCaW5kaW5nXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2tpcFNlbGYgfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxVRV9BQ0NFU1NPUixdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUNvbnRyb2xOYW1lJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAndXBkYXRlJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQsIGFyZ3M6IFsnbmdNb2RlbENoYW5nZScsXSB9LF0sXG4gICAgICAgICAgICAnaXNEaXNhYmxlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZGlzYWJsZWQnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUNvbnRyb2xOYW1lO1xuICAgIH0oTmdDb250cm9sKSk7XG5cbiAgICB2YXIgUkVRVUlSRURfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlcXVpcmVkVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgdG8gYW55IGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxuICAgICAqIGByZXF1aXJlZGAgYXR0cmlidXRlLCB2aWEgdGhlIHtAbGluayBOR19WQUxJREFUT1JTfSBiaW5kaW5nLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxpbnB1dCBuYW1lPVwiZnVsbE5hbWVcIiBuZ01vZGVsIHJlcXVpcmVkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBSZXF1aXJlZFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlcXVpcmVkVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZXF1aXJlZFZhbGlkYXRvci5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yZXF1aXJlZDsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWlyZWQgPSBpc1ByZXNlbnQodmFsdWUpICYmIFwiXCIgKyB2YWx1ZSAhPT0gJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVpcmVkID8gVmFsaWRhdG9ycy5yZXF1aXJlZChjKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbcmVxdWlyZWRdW2Zvcm1Db250cm9sTmFtZV0sW3JlcXVpcmVkXVtmb3JtQ29udHJvbF0sW3JlcXVpcmVkXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSRVFVSVJFRF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIucmVxdWlyZWRdJzogJ3JlcXVpcmVkPyBcIlwiIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ3JlcXVpcmVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXF1aXJlZFZhbGlkYXRvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVyIHdoaWNoIGFkZHMge0BsaW5rIE1pbkxlbmd0aFZhbGlkYXRvcn0gdG8ge0BsaW5rIE5HX1ZBTElEQVRPUlN9LlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vZm9ybXMvdHMvdmFsaWRhdG9ycy92YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbWluJ31cbiAgICAgKi9cbiAgICB2YXIgTUlOX0xFTkdUSF9WQUxJREFUT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWluTGVuZ3RoVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZGlyZWN0aXZlIHdoaWNoIGluc3RhbGxzIHRoZSB7QGxpbmsgTWluTGVuZ3RoVmFsaWRhdG9yfSBmb3IgYW55IGBmb3JtQ29udHJvbE5hbWVgLFxuICAgICAqIGBmb3JtQ29udHJvbGAsIG9yIGNvbnRyb2wgd2l0aCBgbmdNb2RlbGAgdGhhdCBhbHNvIGhhcyBhIGBtaW5sZW5ndGhgIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTWluTGVuZ3RoVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gTWluTGVuZ3RoVmFsaWRhdG9yKCkge1xuICAgICAgICB9XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUuX2NyZWF0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMubWluTGVuZ3RoKHBhcnNlSW50KHRoaXMubWlubGVuZ3RoLCAxMCkpO1xuICAgICAgICB9O1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzWydtaW5sZW5ndGgnXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubWlubGVuZ3RoKSA/IHRoaXMuX3ZhbGlkYXRvcihjKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttaW5sZW5ndGhdW2Zvcm1Db250cm9sTmFtZV0sW21pbmxlbmd0aF1bZm9ybUNvbnRyb2xdLFttaW5sZW5ndGhdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01JTl9MRU5HVEhfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLm1pbmxlbmd0aF0nOiAnbWlubGVuZ3RoPyBtaW5sZW5ndGggOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdtaW5sZW5ndGgnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE1pbkxlbmd0aFZhbGlkYXRvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVyIHdoaWNoIGFkZHMge0BsaW5rIE1heExlbmd0aFZhbGlkYXRvcn0gdG8ge0BsaW5rIE5HX1ZBTElEQVRPUlN9LlxuICAgICAqXG4gICAgICogIyMgRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBjb21tb24vZm9ybXMvdHMvdmFsaWRhdG9ycy92YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbWF4J31cbiAgICAgKi9cbiAgICB2YXIgTUFYX0xFTkdUSF9WQUxJREFUT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF4TGVuZ3RoVmFsaWRhdG9yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgZGlyZWN0aXZlIHdoaWNoIGluc3RhbGxzIHRoZSB7QGxpbmsgTWF4TGVuZ3RoVmFsaWRhdG9yfSBmb3IgYW55IGBmb3JtQ29udHJvbE5hbWUsXG4gICAgICogYGZvcm1Db250cm9sYCxcbiAgICAgKiBvciBjb250cm9sIHdpdGggYG5nTW9kZWxgIHRoYXQgYWxzbyBoYXMgYSBgbWF4bGVuZ3RoYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE1heExlbmd0aFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1heExlbmd0aFZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLl9jcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLm1heExlbmd0aChwYXJzZUludCh0aGlzLm1heGxlbmd0aCwgMTApKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlc1snbWF4bGVuZ3RoJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm1heGxlbmd0aCkgPyB0aGlzLl92YWxpZGF0b3IoYykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbE5hbWVdLFttYXhsZW5ndGhdW2Zvcm1Db250cm9sXSxbbWF4bGVuZ3RoXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNQVhfTEVOR1RIX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5tYXhsZW5ndGhdJzogJ21heGxlbmd0aD8gbWF4bGVuZ3RoIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbWF4bGVuZ3RoJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNYXhMZW5ndGhWYWxpZGF0b3I7XG4gICAgfSgpKTtcbiAgICB2YXIgUEFUVEVSTl9WQUxJREFUT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gUGF0dGVyblZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGBwYXR0ZXJuYCB2YWxpZGF0b3IgdG8gYW55IGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxuICAgICAqIGBwYXR0ZXJuYCBhdHRyaWJ1dGUsIHZpYSB0aGUge0BsaW5rIE5HX1ZBTElEQVRPUlN9IGJpbmRpbmcuIFVzZXMgYXR0cmlidXRlIHZhbHVlXG4gICAgICogYXMgdGhlIHJlZ2V4IHRvIHZhbGlkYXRlIENvbnRyb2wgdmFsdWUgYWdhaW5zdC4gIEZvbGxvd3MgcGF0dGVybiBhdHRyaWJ1dGVcbiAgICAgKiBzZW1hbnRpY3M7IGkuZS4gcmVnZXggbXVzdCBtYXRjaCBlbnRpcmUgQ29udHJvbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8aW5wdXQgW25hbWVdPVwiZnVsbE5hbWVcIiBwYXR0ZXJuPVwiW2EtekEtWiBdKlwiIG5nTW9kZWw+XG4gICAgICogYGBgXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBQYXR0ZXJuVmFsaWRhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUGF0dGVyblZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkgeyB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLnBhdHRlcm4odGhpcy5wYXR0ZXJuKTsgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNbJ3BhdHRlcm4nXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnBhdHRlcm4pID8gdGhpcy5fdmFsaWRhdG9yKGMpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbcGF0dGVybl1bZm9ybUNvbnRyb2xOYW1lXSxbcGF0dGVybl1bZm9ybUNvbnRyb2xdLFtwYXR0ZXJuXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtQQVRURVJOX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5wYXR0ZXJuXSc6ICdwYXR0ZXJuPyBwYXR0ZXJuIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdwYXR0ZXJuJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQYXR0ZXJuVmFsaWRhdG9yO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBDcmVhdGVzIGFuIHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGZyb20gYSB1c2VyLXNwZWNpZmllZCBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogSXQgaXMgZXNzZW50aWFsbHkgc3ludGFjdGljIHN1Z2FyIHRoYXQgc2hvcnRlbnMgdGhlIGBuZXcgRm9ybUdyb3VwKClgLFxuICAgICAqIGBuZXcgRm9ybUNvbnRyb2woKWAsIGFuZCBgbmV3IEZvcm1BcnJheSgpYCBib2lsZXJwbGF0ZSB0aGF0IGNhbiBidWlsZCB1cCBpbiBsYXJnZXJcbiAgICAgKiBmb3Jtcy5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVG8gdXNlLCBpbmplY3QgYEZvcm1CdWlsZGVyYCBpbnRvIHlvdXIgY29tcG9uZW50IGNsYXNzLiBZb3UgY2FuIHRoZW4gY2FsbCBpdHMgbWV0aG9kc1xuICAgICAqIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL2Zvcm1CdWlsZGVyL2Zvcm1fYnVpbGRlcl9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogICogKipOZ01vZHVsZSoqOiB7QGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX1cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGb3JtQnVpbGRlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEgbmV3IHtAbGluayBGb3JtR3JvdXB9IHdpdGggdGhlIGdpdmVuIG1hcCBvZiBjb25maWd1cmF0aW9uLlxuICAgICAgICAgKiBWYWxpZCBrZXlzIGZvciB0aGUgYGV4dHJhYCBwYXJhbWV0ZXIgbWFwIGFyZSBgdmFsaWRhdG9yYCBhbmQgYGFzeW5jVmFsaWRhdG9yYC5cbiAgICAgICAgICpcbiAgICAgICAgICogU2VlIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSBjb25zdHJ1Y3RvciBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLmdyb3VwID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnLCBleHRyYSkge1xuICAgICAgICAgICAgaWYgKGV4dHJhID09PSB2b2lkIDApIHsgZXh0cmEgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgY29udHJvbHMgPSB0aGlzLl9yZWR1Y2VDb250cm9scyhjb250cm9sc0NvbmZpZyk7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gaXNQcmVzZW50KGV4dHJhKSA/IFN0cmluZ01hcFdyYXBwZXIuZ2V0KGV4dHJhLCAndmFsaWRhdG9yJykgOiBudWxsO1xuICAgICAgICAgICAgdmFyIGFzeW5jVmFsaWRhdG9yID0gaXNQcmVzZW50KGV4dHJhKSA/IFN0cmluZ01hcFdyYXBwZXIuZ2V0KGV4dHJhLCAnYXN5bmNWYWxpZGF0b3InKSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1Hcm91cChjb250cm9scywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3QgYSBuZXcge0BsaW5rIEZvcm1Db250cm9sfSB3aXRoIHRoZSBnaXZlbiBgZm9ybVN0YXRlYCxgdmFsaWRhdG9yYCwgYW5kXG4gICAgICAgICAqIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIGBmb3JtU3RhdGVgIGNhbiBlaXRoZXIgYmUgYSBzdGFuZGFsb25lIHZhbHVlIGZvciB0aGUgZm9ybSBjb250cm9sIG9yIGFuIG9iamVjdFxuICAgICAgICAgKiB0aGF0IGNvbnRhaW5zIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuY29udHJvbCA9IGZ1bmN0aW9uIChmb3JtU3RhdGUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybUNvbnRyb2woZm9ybVN0YXRlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIHtAbGluayBGb3JtQXJyYXl9IGZyb20gdGhlIGdpdmVuIGBjb250cm9sc0NvbmZpZ2AgYXJyYXkgb2ZcbiAgICAgICAgICogY29uZmlndXJhdGlvbiwgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uYWwgYHZhbGlkYXRvcmAgYW5kIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yID09PSB2b2lkIDApIHsgdmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKGFzeW5jVmFsaWRhdG9yID09PSB2b2lkIDApIHsgYXN5bmNWYWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICB2YXIgY29udHJvbHMgPSBjb250cm9sc0NvbmZpZy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIF90aGlzLl9jcmVhdGVDb250cm9sKGMpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybUFycmF5KGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuX3JlZHVjZUNvbnRyb2xzID0gZnVuY3Rpb24gKGNvbnRyb2xzQ29uZmlnKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0ge307XG4gICAgICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLmZvckVhY2goY29udHJvbHNDb25maWcsIGZ1bmN0aW9uIChjb250cm9sQ29uZmlnLCBjb250cm9sTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2xOYW1lXSA9IF90aGlzLl9jcmVhdGVDb250cm9sKGNvbnRyb2xDb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbHM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIucHJvdG90eXBlLl9jcmVhdGVDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2xDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgRm9ybUNvbnRyb2wgfHwgY29udHJvbENvbmZpZyBpbnN0YW5jZW9mIEZvcm1Hcm91cCB8fFxuICAgICAgICAgICAgICAgIGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBGb3JtQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoY29udHJvbENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sQ29uZmlnWzBdO1xuICAgICAgICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBjb250cm9sQ29uZmlnLmxlbmd0aCA+IDEgPyBjb250cm9sQ29uZmlnWzFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgYXN5bmNWYWxpZGF0b3IgPSBjb250cm9sQ29uZmlnLmxlbmd0aCA+IDIgPyBjb250cm9sQ29uZmlnWzJdIDogbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKHZhbHVlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2woY29udHJvbENvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1CdWlsZGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgRm9ybUJ1aWxkZXIuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEZvcm1CdWlsZGVyO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU0hBUkVEX0ZPUk1fRElSRUNUSVZFUyA9IFtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24sIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24sIERlZmF1bHRWYWx1ZUFjY2Vzc29yLCBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciwgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sU3RhdHVzLCBOZ0NvbnRyb2xTdGF0dXNHcm91cCwgUmVxdWlyZWRWYWxpZGF0b3IsXG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvciwgTWF4TGVuZ3RoVmFsaWRhdG9yLCBQYXR0ZXJuVmFsaWRhdG9yXG4gICAgXTtcbiAgICB2YXIgVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVMgPSBbTmdNb2RlbCwgTmdNb2RlbEdyb3VwLCBOZ0Zvcm1dO1xuICAgIHZhciBSRUFDVElWRV9EUklWRU5fRElSRUNUSVZFUyA9IFtGb3JtQ29udHJvbERpcmVjdGl2ZSwgRm9ybUdyb3VwRGlyZWN0aXZlLCBGb3JtQ29udHJvbE5hbWUsIEZvcm1Hcm91cE5hbWUsIEZvcm1BcnJheU5hbWVdO1xuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZHVsZSB1c2VkIGZvciBzaGFyaW5nIGRpcmVjdGl2ZXMgYmV0d2VlbiBGb3Jtc01vZHVsZSBhbmQgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICAgICAqL1xuICAgIHZhciBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7IGRlY2xhcmF0aW9uczogU0hBUkVEX0ZPUk1fRElSRUNUSVZFUywgZXhwb3J0czogU0hBUkVEX0ZPUk1fRElSRUNUSVZFUyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBuZyBtb2R1bGUgZm9yIGZvcm1zLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybXNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBGb3Jtc01vZHVsZSgpIHtcbiAgICAgICAgfVxuICAgICAgICBGb3Jtc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFUyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JhZGlvQ29udHJvbFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFU11cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3Jtc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gRm9ybXNNb2R1bGU7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgbmcgbW9kdWxlIGZvciByZWFjdGl2ZSBmb3Jtcy5cbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFJlYWN0aXZlRm9ybXNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZWFjdGl2ZUZvcm1zTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1JFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0Zvcm1CdWlsZGVyLCBSYWRpb0NvbnRyb2xSZWdpc3RyeV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVNdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gUmVhY3RpdmVGb3Jtc01vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgZXhwb3J0cy5BYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUgPSBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5BYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSA9IEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciA9IENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5Db250cm9sQ29udGFpbmVyID0gQ29udHJvbENvbnRhaW5lcjtcbiAgICBleHBvcnRzLk5HX1ZBTFVFX0FDQ0VTU09SID0gTkdfVkFMVUVfQUNDRVNTT1I7XG4gICAgZXhwb3J0cy5EZWZhdWx0VmFsdWVBY2Nlc3NvciA9IERlZmF1bHRWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuTmdDb250cm9sID0gTmdDb250cm9sO1xuICAgIGV4cG9ydHMuTmdDb250cm9sU3RhdHVzID0gTmdDb250cm9sU3RhdHVzO1xuICAgIGV4cG9ydHMuTmdDb250cm9sU3RhdHVzR3JvdXAgPSBOZ0NvbnRyb2xTdGF0dXNHcm91cDtcbiAgICBleHBvcnRzLk5nRm9ybSA9IE5nRm9ybTtcbiAgICBleHBvcnRzLk5nTW9kZWwgPSBOZ01vZGVsO1xuICAgIGV4cG9ydHMuTmdNb2RlbEdyb3VwID0gTmdNb2RlbEdyb3VwO1xuICAgIGV4cG9ydHMuRm9ybUNvbnRyb2xEaXJlY3RpdmUgPSBGb3JtQ29udHJvbERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkZvcm1Db250cm9sTmFtZSA9IEZvcm1Db250cm9sTmFtZTtcbiAgICBleHBvcnRzLkZvcm1Hcm91cERpcmVjdGl2ZSA9IEZvcm1Hcm91cERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkZvcm1BcnJheU5hbWUgPSBGb3JtQXJyYXlOYW1lO1xuICAgIGV4cG9ydHMuRm9ybUdyb3VwTmFtZSA9IEZvcm1Hcm91cE5hbWU7XG4gICAgZXhwb3J0cy5OZ1NlbGVjdE9wdGlvbiA9IE5nU2VsZWN0T3B0aW9uO1xuICAgIGV4cG9ydHMuU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IgPSBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLlNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IgPSBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yO1xuICAgIGV4cG9ydHMuTWF4TGVuZ3RoVmFsaWRhdG9yID0gTWF4TGVuZ3RoVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuTWluTGVuZ3RoVmFsaWRhdG9yID0gTWluTGVuZ3RoVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuUGF0dGVyblZhbGlkYXRvciA9IFBhdHRlcm5WYWxpZGF0b3I7XG4gICAgZXhwb3J0cy5SZXF1aXJlZFZhbGlkYXRvciA9IFJlcXVpcmVkVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuRm9ybUJ1aWxkZXIgPSBGb3JtQnVpbGRlcjtcbiAgICBleHBvcnRzLkFic3RyYWN0Q29udHJvbCA9IEFic3RyYWN0Q29udHJvbDtcbiAgICBleHBvcnRzLkZvcm1BcnJheSA9IEZvcm1BcnJheTtcbiAgICBleHBvcnRzLkZvcm1Db250cm9sID0gRm9ybUNvbnRyb2w7XG4gICAgZXhwb3J0cy5Gb3JtR3JvdXAgPSBGb3JtR3JvdXA7XG4gICAgZXhwb3J0cy5OR19BU1lOQ19WQUxJREFUT1JTID0gTkdfQVNZTkNfVkFMSURBVE9SUztcbiAgICBleHBvcnRzLk5HX1ZBTElEQVRPUlMgPSBOR19WQUxJREFUT1JTO1xuICAgIGV4cG9ydHMuVmFsaWRhdG9ycyA9IFZhbGlkYXRvcnM7XG4gICAgZXhwb3J0cy5Gb3Jtc01vZHVsZSA9IEZvcm1zTW9kdWxlO1xuICAgIGV4cG9ydHMuUmVhY3RpdmVGb3Jtc01vZHVsZSA9IFJlYWN0aXZlRm9ybXNNb2R1bGU7XG5cbn0pKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L0Bhbmd1bGFyL2Zvcm1zL2J1bmRsZXMvZm9ybXMudW1kLmpzXG4gKiogbW9kdWxlIGlkID0gMjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 29:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(22);\nvar router_1 = __webpack_require__(30);\nvar ng2_ui_1 = __webpack_require__(58);\nvar AppComponent = (function () {\n    function AppComponent(router, location) {\n        var _this = this;\n        this.router = router;\n        this.location = location;\n        ng2_ui_1.Ng2MapComponent['apiUrl'] = \"https://maps.google.com/maps/api/js?key=AIzaSyCbMGRUwcqKjlYX4h4-P6t-xcDryRYLmCM\";\n        router.events.subscribe(function (event) {\n            _this.sendToGoogleAnalytics(event);\n        });\n    }\n    AppComponent.prototype.sendToGoogleAnalytics = function (event) {\n        if (event instanceof router_1.NavigationEnd) {\n            // When the route is '/', location.path actually returns ''.\n            var newRoute = this.location.path() || '/';\n            if (this.currentRoute != newRoute) {\n                //console.log('>>>>>>>>>>>>>>>>>>>> sending google analytics', 'send', 'pageview', newRoute);\n                window['ga']('send', 'pageview', newRoute);\n                this.currentRoute = newRoute;\n            }\n        }\n    };\n    AppComponent = __decorate([\n        core_1.Component({\n            selector: 'my-app',\n            template: __webpack_require__(357)\n        }), \n        __metadata('design:paramtypes', [router_1.Router, common_1.Location])\n    ], AppComponent);\n    return AppComponent;\n}());\nexports.AppComponent = AppComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvYXBwLmNvbXBvbmVudC50cz8yMmJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBMEIsQ0FBZSxDQUFDO0FBQzFDLG1DQUF5QixFQUFpQixDQUFDO0FBQzNDLG1DQUF1QyxFQUFpQixDQUFDO0FBQ3pELG1DQUFnQyxFQUFRLENBQUM7QUFNekM7SUFHRSxzQkFDVSxNQUFjLEVBQ2QsUUFBa0I7UUFMOUIsaUJBd0JDO1FBcEJXLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBRTFCLHdCQUFlLENBQUMsUUFBUSxDQUFDLEdBQUcsaUZBQWlGLENBQUM7UUFDOUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUUsZUFBSztZQUM1QixLQUFJLENBQUMscUJBQXFCLENBQUMsS0FBSyxDQUFDO1FBQ25DLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELDRDQUFxQixHQUFyQixVQUFzQixLQUFVO1FBQzlCLEVBQUUsQ0FBQyxDQUFDLEtBQUssWUFBWSxzQkFBYSxDQUFDLENBQUMsQ0FBQztZQUNuQyw0REFBNEQ7WUFDNUQsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxHQUFHLENBQUM7WUFDM0MsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDO2dCQUNsQyw2RkFBNkY7Z0JBQzdGLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2dCQUMzQyxJQUFJLENBQUMsWUFBWSxHQUFHLFFBQVEsQ0FBQztZQUMvQixDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUEzQkg7UUFBQyxnQkFBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLFFBQVE7WUFDbEIsUUFBUSxFQUFFLG1CQUFPLENBQUMsR0FBWSxDQUFDO1NBQ2hDLENBQUM7O29CQUFBO0lBeUJGLG1CQUFDO0FBQUQsQ0FBQztBQXhCWSxvQkFBWSxlQXdCeEIiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExvY2F0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFJvdXRlciwgTmF2aWdhdGlvbkVuZCB9ICBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgTmcyTWFwQ29tcG9uZW50IH0gZnJvbSBcIm5nMi11aVwiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hcHAuaHRtbCcpXG59KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gIHByaXZhdGUgY3VycmVudFJvdXRlOnN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJvdXRlcjogUm91dGVyLFxuICAgIHByaXZhdGUgbG9jYXRpb246IExvY2F0aW9uXG4gICkge1xuICAgIE5nMk1hcENvbXBvbmVudFsnYXBpVXJsJ10gPSBcImh0dHBzOi8vbWFwcy5nb29nbGUuY29tL21hcHMvYXBpL2pzP2tleT1BSXphU3lDYk1HUlV3Y3FLamxZWDRoNC1QNnQteGNEcnlSWUxtQ01cIjtcbiAgICByb3V0ZXIuZXZlbnRzLnN1YnNjcmliZSggZXZlbnQgPT4ge1xuICAgICAgdGhpcy5zZW5kVG9Hb29nbGVBbmFseXRpY3MoZXZlbnQpXG4gICAgfSk7XG4gIH1cblxuICBzZW5kVG9Hb29nbGVBbmFseXRpY3MoZXZlbnQ6IGFueSk6IGFueSB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkge1xuICAgICAgLy8gV2hlbiB0aGUgcm91dGUgaXMgJy8nLCBsb2NhdGlvbi5wYXRoIGFjdHVhbGx5IHJldHVybnMgJycuXG4gICAgICBsZXQgbmV3Um91dGUgPSB0aGlzLmxvY2F0aW9uLnBhdGgoKSB8fCAnLyc7XG4gICAgICBpZiAodGhpcy5jdXJyZW50Um91dGUgIT0gbmV3Um91dGUpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnPj4+Pj4+Pj4+Pj4+Pj4+Pj4+Pj4gc2VuZGluZyBnb29nbGUgYW5hbHl0aWNzJywgJ3NlbmQnLCAncGFnZXZpZXcnLCBuZXdSb3V0ZSk7XG4gICAgICAgIHdpbmRvd1snZ2EnXSgnc2VuZCcsICdwYWdldmlldycsIG5ld1JvdXRlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Um91dGUgPSBuZXdSb3V0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvYXBwLmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 58:
/***/ function(module, exports, __webpack_require__) {

	eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(24), __webpack_require__(21), __webpack_require__(22), __webpack_require__(28), __webpack_require__(59), __webpack_require__(2));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\", \"@angular/common\", \"@angular/http\", \"rxjs/Rx\", \"rxjs/Subject\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ng2-ui\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"), require(\"@angular/common\"), require(\"@angular/http\"), require(\"rxjs/Rx\"), require(\"rxjs/Subject\"));\n\telse\n\t\troot[\"ng2-ui\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"], root[\"@angular/common\"], root[\"@angular/http\"], root[\"rxjs/Rx\"], root[\"rxjs/Subject\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__, __WEBPACK_EXTERNAL_MODULE_9__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t};\n\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t};\n\tvar core_1 = __webpack_require__(1);\n\tvar forms_1 = __webpack_require__(2);\n\tvar platform_browser_1 = __webpack_require__(3);\n\tvar ng2_overlay_1 = __webpack_require__(4);\n\texports.OverlayManager = ng2_overlay_1.OverlayManager;\n\tvar ng2_auto_complete_1 = __webpack_require__(5);\n\tvar ng2_datetime_picker_1 = __webpack_require__(10);\n\tvar ng2_collapsable_1 = __webpack_require__(11);\n\tvar ng2_infinite_list_1 = __webpack_require__(12);\n\tvar ng2_map_1 = __webpack_require__(13);\n\texports.Ng2MapComponent = ng2_map_1.Ng2MapComponent;\n\tvar ng2_menu_1 = __webpack_require__(14);\n\tvar ng2_parallax_scroll_1 = __webpack_require__(15);\n\tvar ng2_popup_1 = __webpack_require__(16);\n\texports.Ng2MessagePopupComponent = ng2_popup_1.Ng2MessagePopupComponent;\n\texports.Ng2PopupComponent = ng2_popup_1.Ng2PopupComponent;\n\tvar ng2_sticky_1 = __webpack_require__(17);\n\tvar ng2_tab_1 = __webpack_require__(18);\n\tvar ng2_tooltip_overlay_1 = __webpack_require__(19);\n\tvar ng2_scrollable_1 = __webpack_require__(20);\n\texports.Ng2ScrollableDirective = ng2_scrollable_1.Ng2ScrollableDirective;\n\tvar ng2_ui_sortable_1 = __webpack_require__(21);\n\tvar Ng2UIModule = (function () {\n\t    function Ng2UIModule() {\n\t    }\n\t    Ng2UIModule = __decorate([\n\t        core_1.NgModule({\n\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t            exports: [\n\t                ng2_auto_complete_1.Ng2AutoCompleteModule,\n\t                ng2_datetime_picker_1.Ng2DatetimePickerModule,\n\t                ng2_collapsable_1.Ng2CollapsableModule,\n\t                ng2_infinite_list_1.Ng2InfiniteListModule,\n\t                ng2_map_1.Ng2MapModule,\n\t                ng2_menu_1.Ng2MenuModule,\n\t                ng2_parallax_scroll_1.Ng2ParallaxScrollModule,\n\t                ng2_popup_1.Ng2PopupModule,\n\t                ng2_sticky_1.Ng2StickyModule,\n\t                ng2_tab_1.Ng2TabModule,\n\t                ng2_scrollable_1.Ng2ScrollableModule,\n\t                ng2_tooltip_overlay_1.Ng2TooltipOverlayModule,\n\t                ng2_overlay_1.Ng2OverlayModule,\n\t                ng2_ui_sortable_1.Ng2SortableModule\n\t            ],\n\t            providers: [ng2_overlay_1.OverlayManager]\n\t        }), \n\t        __metadata('design:paramtypes', [])\n\t    ], Ng2UIModule);\n\t    return Ng2UIModule;\n\t}());\n\texports.Ng2UIModule = Ng2UIModule;\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-overlay\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-overlay\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar overlay_1 = __webpack_require__(4);\n\t\texports.Overlay = overlay_1.Overlay;\n\t\tvar overlay_manager_1 = __webpack_require__(6);\n\t\texports.OverlayManager = overlay_manager_1.OverlayManager;\n\t\tvar overlay_directive_1 = __webpack_require__(7);\n\t\texports.OverlayDirective = overlay_directive_1.OverlayDirective;\n\t\tvar Ng2OverlayModule = (function () {\n\t\t    function Ng2OverlayModule() {\n\t\t    }\n\t\t    Ng2OverlayModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [overlay_directive_1.OverlayDirective],\n\t\t            providers: [overlay_manager_1.OverlayManager],\n\t\t            exports: [overlay_directive_1.OverlayDirective]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2OverlayModule);\n\t\t    return Ng2OverlayModule;\n\t\t}());\n\t\texports.Ng2OverlayModule = Ng2OverlayModule;\n\t\t;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar util_1 = __webpack_require__(5);\n\t\tvar Overlay = (function () {\n\t\t    function Overlay(el, options) {\n\t\t        options = options || {};\n\t\t        this.id = options.id;\n\t\t        this.type = options.type;\n\t\t        if (!this.id) {\n\t\t            throw \"Invalid overlay id\";\n\t\t        }\n\t\t        this.element = el; // overlay wrapper element with table dsplay\n\t\t        this.windowOverlay = options.windowOverlay;\n\t\t        this.position = this.getPositionProperty(options.position || 'center center');\n\t\t    }\n\t\t    Overlay.prototype.positionIt = function (event) {\n\t\t        if (this.position.inside) {\n\t\t            this.positionItInside(this.position);\n\t\t        }\n\t\t        else {\n\t\t            this.positionItOutside(this.position, event);\n\t\t        }\n\t\t    };\n\t\t    Overlay.prototype.getPositionProperty = function (positionStr) {\n\t\t        var position = {}, inside;\n\t\t        var _a = positionStr.split(' '), vertical = _a[0], horizontal = _a[1], insideStr = _a[2];\n\t\t        horizontal = horizontal || 'center';\n\t\t        vertical = vertical || 'center';\n\t\t        inside = (insideStr !== 'outside' || this.windowOverlay);\n\t\t        position.horizontal = Overlay[horizontal.toUpperCase()];\n\t\t        position.vertical = Overlay[vertical.toUpperCase()];\n\t\t        position.inside = inside;\n\t\t        return position;\n\t\t    };\n\t\t    Overlay.prototype.positionItInside = function (position) {\n\t\t        this.element.style.display = 'flex';\n\t\t        //top / left positioning\n\t\t        if (this.windowOverlay) {\n\t\t            this.element.style.position = 'fixed';\n\t\t            //works as blocker\n\t\t            Object.assign(this.element.style, {\n\t\t                backgroundColor: 'rgba(0,0,0,0.2)',\n\t\t                top: '0', left: '0', bottom: '0', right: '0',\n\t\t                width: '100%', height: '100%'\n\t\t            });\n\t\t        }\n\t\t        else {\n\t\t            //adjust top/left to match to parentElement\n\t\t            var parentEl = this.element.parentElement;\n\t\t            //works as a blocker\n\t\t            Object.assign(this.element.style, {\n\t\t                position: 'absolute',\n\t\t                // backgroundColor: 'transparent',\n\t\t                backgroundColor: 'rgba(0,0,0,0.2)',\n\t\t                top: parentEl.offsetTop + 'px',\n\t\t                left: parentEl.offsetLeft + 'px',\n\t\t                width: parentEl.offsetWidth + 'px',\n\t\t                height: parentEl.offsetHeight + 'px'\n\t\t            });\n\t\t        }\n\t\t        ;\n\t\t        //horizontal position\n\t\t        switch (position.horizontal) {\n\t\t            case Overlay.LEFT:\n\t\t                this.element.style.justifyContent = 'flex-start';\n\t\t                break;\n\t\t            case Overlay.CENTER:\n\t\t                this.element.style.justifyContent = 'center';\n\t\t                break;\n\t\t            case Overlay.RIGHT:\n\t\t                this.element.style.justifyContent = 'flex-end';\n\t\t                break;\n\t\t        }\n\t\t        //vertical position\n\t\t        switch (position.vertical) {\n\t\t            case Overlay.LEFT:\n\t\t                this.element.style.alignItems = 'flex-start';\n\t\t                break;\n\t\t            case Overlay.CENTER:\n\t\t            case Overlay.MIDDLE:\n\t\t                this.element.style.alignItems = 'center';\n\t\t                break;\n\t\t            case Overlay.RIGHT:\n\t\t                this.element.style.alignItems = 'flex-end';\n\t\t                break;\n\t\t        }\n\t\t    };\n\t\t    Overlay.prototype.positionItOutside = function (position, event) {\n\t\t        //adjust top/left to match to parentElement\n\t\t        var parentEl = this.element.parentElement;\n\t\t        //works as guide line?\n\t\t        Object.assign(this.element.style, {\n\t\t            position: 'absolute',\n\t\t            pointerEvents: 'none',\n\t\t            top: parentEl.offsetTop + 'px',\n\t\t            left: parentEl.offsetLeft + 'px',\n\t\t            width: parentEl.offsetWidth + 'px',\n\t\t            height: parentEl.offsetHeight + 'px'\n\t\t        });\n\t\t        this.element.style.display = 'block';\n\t\t        var elToPosition = (this.element.children[0]);\n\t\t        elToPosition.style.position = 'absolute';\n\t\t        elToPosition.style.pointerEvents = 'auto';\n\t\t        switch (position.vertical) {\n\t\t            case Overlay.TOP:\n\t\t                elToPosition.style.bottom = this.element.offsetHeight + 'px';\n\t\t                break;\n\t\t            case Overlay.BOTTOM:\n\t\t                elToPosition.style.top = this.element.offsetHeight + 'px';\n\t\t                break;\n\t\t            case Overlay.LEFT:\n\t\t                elToPosition.style.right = this.element.offsetWidth + 'px';\n\t\t                break;\n\t\t            case Overlay.RIGHT:\n\t\t                elToPosition.style.left = this.element.offsetWidth + 'px';\n\t\t                break;\n\t\t        }\n\t\t        switch (position.horizontal) {\n\t\t            case Overlay.CENTER:\n\t\t                elToPosition.style.left = (this.element.offsetWidth - elToPosition.offsetWidth) / 2 + 'px';\n\t\t                break;\n\t\t            case Overlay.LEFT:\n\t\t                elToPosition.style.left = '0';\n\t\t                break;\n\t\t            case Overlay.RIGHT:\n\t\t                elToPosition.style.right = '0';\n\t\t                break;\n\t\t            case Overlay.TOP:\n\t\t                elToPosition.style.top = '0';\n\t\t                break;\n\t\t            case Overlay.BOTTOM:\n\t\t                elToPosition.style.bottom = '0';\n\t\t                break;\n\t\t            case Overlay.CURSOR:\n\t\t                var mousePos = util_1.Util.getMousePositionInElement(event, this.element);\n\t\t                if ((mousePos.x + elToPosition.offsetWidth) > this.element.offsetWidth) {\n\t\t                    elToPosition.style.left = (this.element.offsetWidth - elToPosition.offsetWidth - 5) + 'px';\n\t\t                }\n\t\t                else if (mousePos.x < elToPosition.offsetWidth / 2) {\n\t\t                    elToPosition.style.left = '0px';\n\t\t                }\n\t\t                else {\n\t\t                    elToPosition.style.left = mousePos.x - elToPosition.offsetWidth / 2 + 'px';\n\t\t                }\n\t\t                break;\n\t\t        }\n\t\t    };\n\t\t    Overlay.TOP = 11;\n\t\t    Overlay.MIDDLE = 12;\n\t\t    Overlay.BOTTOM = 13;\n\t\t    Overlay.LEFT = 21;\n\t\t    Overlay.CENTER = 22;\n\t\t    Overlay.RIGHT = 23;\n\t\t    Overlay.CURSOR = 31;\n\t\t    return Overlay;\n\t\t}());\n\t\texports.Overlay = Overlay;\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\tvar Util = (function () {\n\t\t    function Util() {\n\t\t    }\n\t\t    Util.getDocumentPosition = function (oElement) {\n\t\t        var posX = 0, posY = 0;\n\t\t        if (oElement.offsetParent) {\n\t\t            for (; oElement; oElement = oElement.offsetParent) {\n\t\t                posX += oElement.offsetLeft;\n\t\t                posY += oElement.offsetTop;\n\t\t            }\n\t\t            return { x: posX, y: posY };\n\t\t        }\n\t\t        else {\n\t\t            return { x: oElement['x'], y: oElement['y'] };\n\t\t        }\n\t\t    };\n\t\t    Util.getMousePositionInElement = function (evt, element) {\n\t\t        evt = evt || window.event;\n\t\t        var posX = 0, posY = 0;\n\t\t        var elPos = this.getDocumentPosition(element);\n\t\t        if (evt.pageX || evt.pageY) {\n\t\t            posX = evt.pageX;\n\t\t            posY = evt.pageY;\n\t\t        }\n\t\t        else if (evt.clientX || evt.clientY) {\n\t\t            posX = evt.clientX +\n\t\t                document.body.scrollLeft +\n\t\t                document.documentElement.scrollLeft;\n\t\t            posY = evt.clientY +\n\t\t                document.body.scrollTop +\n\t\t                document.documentElement.scrollTop;\n\t\t        }\n\t\t        return {\n\t\t            x: posX - elPos.x,\n\t\t            y: posY - elPos.y\n\t\t        };\n\t\t    };\n\t\t    return Util;\n\t\t}());\n\t\texports.Util = Util;\n\t\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar OverlayManager = (function () {\n\t\t    function OverlayManager() {\n\t\t    }\n\t\t    OverlayManager.prototype.register = function (overlay) {\n\t\t        OverlayManager.overlays[overlay.id] = overlay;\n\t\t        // console.log('overlay.register, OverlayManager.overlays', OverlayManager.overlays);\n\t\t    };\n\t\t    OverlayManager.prototype.open = function (arg, event) {\n\t\t        var overlay = typeof arg === 'string' ? OverlayManager.overlays[arg] : arg;\n\t\t        if (!overlay.opened) {\n\t\t            overlay.positionIt(event);\n\t\t            overlay.opened = true;\n\t\t        }\n\t\t    };\n\t\t    OverlayManager.prototype.close = function (arg) {\n\t\t        var overlay = typeof arg === 'string' ? OverlayManager.overlays[arg] : arg;\n\t\t        overlay.element.style.display = 'none';\n\t\t        overlay.opened = false;\n\t\t    };\n\t\t    //list of overlay objects\n\t\t    OverlayManager.overlays = {};\n\t\t    OverlayManager = __decorate([\n\t\t        core_1.Injectable(), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], OverlayManager);\n\t\t    return OverlayManager;\n\t\t}());\n\t\texports.OverlayManager = OverlayManager;\n\t\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar overlay_manager_1 = __webpack_require__(6);\n\t\tvar overlay_1 = __webpack_require__(4);\n\t\tvar OverlayDirective = (function () {\n\t\t    function OverlayDirective(viewContainerRef, overlayManager) {\n\t\t        this.viewContainerRef = viewContainerRef;\n\t\t        this.overlayManager = overlayManager;\n\t\t        this.el = this.viewContainerRef.element.nativeElement;\n\t\t    }\n\t\t    OverlayDirective.prototype.ngAfterViewInit = function () {\n\t\t        this.wrapItWithOverlayTag();\n\t\t        this.registerToOverlayManager();\n\t\t    };\n\t\t    OverlayDirective.prototype.wrapItWithOverlayTag = function () {\n\t\t        //console.log('wrapped overlay directive element with <ng2-overlay>');\n\t\t        this.overlayEl = document.createElement('ng2-overlay');\n\t\t        this.overlayEl.style.display = 'none';\n\t\t        this.el.parentElement.insertBefore(this.overlayEl, this.el.nextSibling);\n\t\t        this.overlayEl.appendChild(this.el);\n\t\t    };\n\t\t    //create Overlay object,  then register this element to overlayManager\n\t\t    OverlayDirective.prototype.registerToOverlayManager = function () {\n\t\t        var positionStr = this.overlayPosition;\n\t\t        var overlay = new overlay_1.Overlay(this.overlayEl, {\n\t\t            id: this.el.id,\n\t\t            windowOverlay: this.overlayOf == \"window\",\n\t\t            position: positionStr\n\t\t        });\n\t\t        //console.log('registering overlay', overlay);\n\t\t        this.overlayManager.register(overlay);\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input('ng2-overlay-of'), \n\t\t        __metadata('design:type', String)\n\t\t    ], OverlayDirective.prototype, \"overlayOf\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input('ng2-overlay-position'), \n\t\t        __metadata('design:type', String)\n\t\t    ], OverlayDirective.prototype, \"overlayPosition\", void 0);\n\t\t    OverlayDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: '[ng2-overlay], [ng2-overlay-of], [ng2-overlay-position]',\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef, overlay_manager_1.OverlayManager])\n\t\t    ], OverlayDirective);\n\t\t    return OverlayDirective;\n\t\t}());\n\t\texports.OverlayDirective = OverlayDirective;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-overlay.umd.js.map\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(6), __webpack_require__(7), __webpack_require__(8), __webpack_require__(9));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/common\", \"@angular/http\", \"rxjs/Rx\", \"rxjs/Subject\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-auto-complete\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/common\"), require(\"@angular/http\"), require(\"rxjs/Rx\"), require(\"rxjs/Subject\"));\n\t\telse\n\t\t\troot[\"ng2-auto-complete\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/common\"], root[\"@angular/http\"], root[\"rxjs/Rx\"], root[\"rxjs/Subject\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__, __WEBPACK_EXTERNAL_MODULE_5__, __WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_8__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar auto_complete_1 = __webpack_require__(4);\n\t\texports.AutoComplete = auto_complete_1.AutoComplete;\n\t\tvar auto_complete_component_1 = __webpack_require__(7);\n\t\texports.AutoCompleteComponent = auto_complete_component_1.AutoCompleteComponent;\n\t\tvar auto_complete_directive_1 = __webpack_require__(9);\n\t\texports.AutoCompleteDirective = auto_complete_directive_1.AutoCompleteDirective;\n\t\tvar Ng2AutoCompleteModule = (function () {\n\t\t    function Ng2AutoCompleteModule() {\n\t\t    }\n\t\t    Ng2AutoCompleteModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [common_1.CommonModule, forms_1.FormsModule],\n\t\t            declarations: [auto_complete_component_1.AutoCompleteComponent, auto_complete_directive_1.AutoCompleteDirective],\n\t\t            exports: [auto_complete_component_1.AutoCompleteComponent, auto_complete_directive_1.AutoCompleteDirective],\n\t\t            entryComponents: [auto_complete_component_1.AutoCompleteComponent],\n\t\t            providers: [auto_complete_1.AutoComplete]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2AutoCompleteModule);\n\t\t    return Ng2AutoCompleteModule;\n\t\t}());\n\t\texports.Ng2AutoCompleteModule = Ng2AutoCompleteModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar http_1 = __webpack_require__(5);\n\t\t__webpack_require__(6);\n\t\t/**\n\t\t * provides auto-complete related utility functions\n\t\t */\n\t\tvar AutoComplete = (function () {\n\t\t    function AutoComplete(http) {\n\t\t        this.http = http;\n\t\t        // ...\n\t\t    }\n\t\t    AutoComplete.prototype.filter = function (list, keyword) {\n\t\t        return list.filter(function (el) {\n\t\t            return !!JSON.stringify(el).match(new RegExp(keyword, \"i\"));\n\t\t        });\n\t\t    };\n\t\t    /**\n\t\t     * return remote data from the given source and options, and data path\n\t\t     *\n\t\t     * @param {*} options is an object containing the query paramters for the GET call\n\t\t     * @returns {Observable<Response>}\n\t\t     *\n\t\t     * @memberOf AutoComplete\n\t\t     */\n\t\t    AutoComplete.prototype.getRemoteData = function (options) {\n\t\t        var _this = this;\n\t\t        var keyValues = [];\n\t\t        var url = \"\";\n\t\t        for (var key in options) {\n\t\t            if (options.hasOwnProperty(key)) {\n\t\t                // replace all keyword to value\n\t\t                var regexp = new RegExp(\":\" + key, \"g\");\n\t\t                url = this.source;\n\t\t                if (url.match(regexp)) {\n\t\t                    url = url.replace(regexp, options[key]);\n\t\t                }\n\t\t                else {\n\t\t                    keyValues.push(key + \"=\" + options[key]);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        if (keyValues.length) {\n\t\t            var qs = keyValues.join(\"&\");\n\t\t            url += url.match(/\\?[a-z]/i) ? qs : (\"?\" + qs);\n\t\t        }\n\t\t        return this.http.get(url)\n\t\t            .map(function (resp) { return resp.json(); })\n\t\t            .map(function (resp) {\n\t\t            var list = resp.data || resp;\n\t\t            if (_this.pathToData) {\n\t\t                var paths = _this.pathToData.split(\".\");\n\t\t                paths.forEach(function (prop) { return list = list[prop]; });\n\t\t            }\n\t\t            return list;\n\t\t        });\n\t\t    };\n\t\t    ;\n\t\t    AutoComplete = __decorate([\n\t\t        core_1.Injectable(), \n\t\t        __metadata('design:paramtypes', [http_1.Http])\n\t\t    ], AutoComplete);\n\t\t    return AutoComplete;\n\t\t}());\n\t\texports.AutoComplete = AutoComplete;\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_5__;\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Subject_1 = __webpack_require__(8);\n\t\tvar auto_complete_1 = __webpack_require__(4);\n\t\t/**\n\t\t * show a selected date in monthly calendar\n\t\t * Each filteredList item has the following property in addition to data itself\n\t\t *   1. displayValue as string e.g. Allen Kim\n\t\t *   2. dataValue as any e.g.\n\t\t */\n\t\tvar AutoCompleteComponent = (function () {\n\t\t    /**\n\t\t     * constructor\n\t\t     */\n\t\t    function AutoCompleteComponent(elementRef, autoComplete) {\n\t\t        this.autoComplete = autoComplete;\n\t\t        this.minChars = 0;\n\t\t        this.valuePropertyName = \"id\";\n\t\t        this.displayPropertyName = \"value\";\n\t\t        this.dropdownVisible = false;\n\t\t        this.isLoading = false;\n\t\t        this.filteredList = [];\n\t\t        this.itemIndex = 0;\n\t\t        this.valueSelected = new Subject_1.Subject();\n\t\t        this.delay = (function () {\n\t\t            var timer = 0;\n\t\t            return function (callback, ms) {\n\t\t                clearTimeout(timer);\n\t\t                timer = setTimeout(callback, ms);\n\t\t            };\n\t\t        })();\n\t\t        this.el = elementRef.nativeElement;\n\t\t    }\n\t\t    AutoCompleteComponent.prototype.isSrcArr = function () {\n\t\t        return (this.source.constructor.name === \"Array\");\n\t\t    };\n\t\t    /**\n\t\t     * user enters into input el, shows list to select, then select one\n\t\t     */\n\t\t    AutoCompleteComponent.prototype.ngOnInit = function () {\n\t\t        this.inputEl = (this.el.querySelector(\"input\"));\n\t\t        this.autoComplete.source = this.source;\n\t\t        this.autoComplete.pathToData = this.pathToData;\n\t\t    };\n\t\t    AutoCompleteComponent.prototype.reloadListInDelay = function () {\n\t\t        var _this = this;\n\t\t        var delayMs = this.isSrcArr() ? 10 : 500;\n\t\t        // executing after user stopped typing\n\t\t        this.delay(function () { return _this.reloadList(); }, delayMs);\n\t\t    };\n\t\t    AutoCompleteComponent.prototype.showDropdownList = function () {\n\t\t        this.keyword = \"\";\n\t\t        this.inputEl.focus();\n\t\t        this.reloadList();\n\t\t    };\n\t\t    AutoCompleteComponent.prototype.hideDropdownList = function () {\n\t\t        this.dropdownVisible = false;\n\t\t    };\n\t\t    AutoCompleteComponent.prototype.reloadList = function () {\n\t\t        var _this = this;\n\t\t        var keyword = this.inputEl.value;\n\t\t        this.hideDropdownList();\n\t\t        this.dropdownVisible = true;\n\t\t        if (this.isSrcArr()) {\n\t\t            // local source \n\t\t            this.filteredList = this.autoComplete.filter(this.source, this.keyword);\n\t\t        }\n\t\t        else {\n\t\t            this.isLoading = true;\n\t\t            if (keyword.length >= this.minChars) {\n\t\t                if (typeof this.source === \"function\") {\n\t\t                    // custom function that returns observable \n\t\t                    this.source(keyword).subscribe(function (resp) {\n\t\t                        if (_this.pathToData) {\n\t\t                            var paths = _this.pathToData.split(\".\");\n\t\t                            paths.forEach(function (prop) { return resp = resp[prop]; });\n\t\t                        }\n\t\t                        _this.filteredList = resp;\n\t\t                    }, function (error) { return null; }, function () { return _this.isLoading = false; } // complete\n\t\t                    );\n\t\t                }\n\t\t                else {\n\t\t                    // remote source  \n\t\t                    var query = { keyword: keyword };\n\t\t                    this.autoComplete.getRemoteData(query)\n\t\t                        .subscribe(function (resp) {\n\t\t                        _this.filteredList = resp;\n\t\t                    }, function (error) { return null; }, function () { return _this.isLoading = false; } // complete\n\t\t                    );\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t    };\n\t\t    AutoCompleteComponent.prototype.selectOne = function (data) {\n\t\t        this.hideDropdownList();\n\t\t        this.valueSelected.next(data);\n\t\t    };\n\t\t    ;\n\t\t    AutoCompleteComponent.prototype.inputElKeyHandler = function (evt) {\n\t\t        var totalNumItem = this.filteredList.length;\n\t\t        switch (evt.keyCode) {\n\t\t            case 27:\n\t\t                this.hideDropdownList();\n\t\t                break;\n\t\t            case 38:\n\t\t                this.itemIndex = (totalNumItem + this.itemIndex - 1) % totalNumItem;\n\t\t                break;\n\t\t            case 40:\n\t\t                this.dropdownVisible = true;\n\t\t                this.itemIndex = (totalNumItem + this.itemIndex + 1) % totalNumItem;\n\t\t                break;\n\t\t            case 13:\n\t\t                if (this.filteredList.length > 0) {\n\t\t                    this.selectOne(this.filteredList[this.itemIndex]);\n\t\t                }\n\t\t                evt.preventDefault();\n\t\t                break;\n\t\t        }\n\t\t    };\n\t\t    ;\n\t\t    AutoCompleteComponent.prototype.getFormattedList = function (data) {\n\t\t        var formatter = this.listFormatter || this.defaultListFormatter;\n\t\t        return formatter.apply(this, [data]);\n\t\t    };\n\t\t    AutoCompleteComponent.prototype.defaultListFormatter = function (data) {\n\t\t        var html = \"\";\n\t\t        html += data[this.valuePropertyName] ? \"<b>(\" + data[this.valuePropertyName] + \")</b>\" : \"\";\n\t\t        html += data[this.displayPropertyName] ? \"<span>\" + data[this.displayPropertyName] + \"</span>\" : data;\n\t\t        return html;\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input(\"list-formatter\"), \n\t\t        __metadata('design:type', Function)\n\t\t    ], AutoCompleteComponent.prototype, \"listFormatter\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"source\"), \n\t\t        __metadata('design:type', Object)\n\t\t    ], AutoCompleteComponent.prototype, \"source\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"path-to-data\"), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteComponent.prototype, \"pathToData\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"min-chars\"), \n\t\t        __metadata('design:type', Number)\n\t\t    ], AutoCompleteComponent.prototype, \"minChars\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"value-property-name\"), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteComponent.prototype, \"valuePropertyName\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"display-property-name\"), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteComponent.prototype, \"displayPropertyName\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"placeholder\"), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteComponent.prototype, \"placeholder\", void 0);\n\t\t    AutoCompleteComponent = __decorate([\n\t\t        core_1.Component({\n\t\t            selector: \"auto-complete\",\n\t\t            template: \"\\n  <div class=\\\"auto-complete\\\">\\n\\n    <!-- keyword input -->\\n    <input class=\\\"keyword\\\"\\n           placeholder=\\\"{{placeholder}}\\\"\\n           (focus)=\\\"showDropdownList()\\\"\\n           (blur)=\\\"dropdownVisible=false\\\"\\n           (keydown)=\\\"inputElKeyHandler($event)\\\"\\n           (input)=\\\"reloadListInDelay()\\\"\\n           [(ngModel)]=\\\"keyword\\\" />\\n\\n    <!-- dropdown that user can select -->\\n    <ul *ngIf=\\\"dropdownVisible\\\">\\n      <li *ngIf=\\\"isLoading\\\" class=\\\"loading\\\">Loading</li>\\n      <li class=\\\"item\\\"\\n          *ngFor=\\\"let item of filteredList; let i=index\\\"\\n          (mousedown)=\\\"selectOne(item)\\\"\\n          [ngClass]=\\\"{selected: i === itemIndex}\\\"\\n          [innerHtml]=\\\"getFormattedList(item)\\\">\\n      </li>\\n    </ul>\\n\\n  </div>\",\n\t\t            providers: [auto_complete_1.AutoComplete],\n\t\t            styles: [\"\\n  @keyframes slideDown {\\n    0% {\\n      transform:  translateY(-10px);\\n    }\\n    100% {\\n      transform: translateY(0px);\\n    }\\n  }\\n  .auto-complete input {\\n    outline: none;\\n    border: 2px solid transparent;\\n    border-width: 3px 2px;\\n    margin: 0;\\n    box-sizing: border-box;\\n    background-clip: content-box;\\n  }\\n\\n  .auto-complete ul {\\n    background-color: #fff;\\n    margin: 0;\\n    width : 100%;\\n    overflow-y: auto;\\n    list-style-type: none;\\n    padding: 0;\\n    border: 1px solid #ccc;\\n    box-sizing: border-box;\\n    animation: slideDown 0.1s;\\n  }\\n\\n  .auto-complete ul li {\\n    padding: 2px 5px;\\n    border-bottom: 1px solid #eee;\\n  }\\n\\n  .auto-complete ul li.selected {\\n    background-color: #ccc;\\n  }\\n\\n  .auto-complete ul li:last-child {\\n    border-bottom: none;\\n  }\\n\\n  .auto-complete ul li:hover {\\n    background-color: #ccc;\\n  }\"\n\t\t            ],\n\t\t            encapsulation: core_1.ViewEncapsulation.None\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ElementRef, auto_complete_1.AutoComplete])\n\t\t    ], AutoCompleteComponent);\n\t\t    return AutoCompleteComponent;\n\t\t}());\n\t\texports.AutoCompleteComponent = AutoCompleteComponent;\n\t\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\t__webpack_require__(6);\n\t\tvar auto_complete_component_1 = __webpack_require__(7);\n\t\t/**\n\t\t * display auto-complete section with input and dropdown list when it is clicked\n\t\t */\n\t\tvar AutoCompleteDirective = (function () {\n\t\t    function AutoCompleteDirective(resolver, viewContainerRef) {\n\t\t        var _this = this;\n\t\t        this.resolver = resolver;\n\t\t        this.viewContainerRef = viewContainerRef;\n\t\t        this.ngModelChange = new core_1.EventEmitter();\n\t\t        this.valueChanged = new core_1.EventEmitter();\n\t\t        this.hideAutoCompleteDropdown = function (event) {\n\t\t            if (_this.componentRef) {\n\t\t                if (event && event.type === \"click\" &&\n\t\t                    event.target.tagName !== \"INPUT\" &&\n\t\t                    !_this.elementIn(event.target, _this.acDropdownEl)) {\n\t\t                    _this.componentRef.destroy();\n\t\t                    _this.componentRef = undefined;\n\t\t                }\n\t\t                else if (!event) {\n\t\t                    _this.componentRef.destroy();\n\t\t                    _this.componentRef = undefined;\n\t\t                }\n\t\t            }\n\t\t        };\n\t\t        this.styleAutoCompleteDropdown = function () {\n\t\t            var component = _this.componentRef.instance;\n\t\t            /* setting width/height auto complete */\n\t\t            var thisElBCR = _this.el.getBoundingClientRect();\n\t\t            _this.acDropdownEl.style.width = thisElBCR.width + \"px\";\n\t\t            _this.acDropdownEl.style.position = \"absolute\";\n\t\t            _this.acDropdownEl.style.zIndex = \"1\";\n\t\t            _this.acDropdownEl.style.top = \"0\";\n\t\t            _this.acDropdownEl.style.left = \"0\";\n\t\t            _this.acDropdownEl.style.display = \"inline-block\";\n\t\t            var thisInputElBCR = _this.inputEl.getBoundingClientRect();\n\t\t            component.inputEl.style.width = (thisInputElBCR.width - 30) + \"px\";\n\t\t            component.inputEl.style.height = thisInputElBCR.height + \"px\";\n\t\t            component.inputEl.focus();\n\t\t        };\n\t\t        this.selectNewValue = function (val) {\n\t\t            /* modify toString function of value if value is an object */\n\t\t            if (val && typeof val === \"object\") {\n\t\t                var displayVal_1 = val[_this.displayPropertyName || \"value\"];\n\t\t                val.toString = function () { return displayVal_1; };\n\t\t            }\n\t\t            /* emit ngModelChange and valueChanged */\n\t\t            if (val !== _this.ngModel) {\n\t\t                _this.ngModelChange.emit(val);\n\t\t            }\n\t\t            if (val) {\n\t\t                _this.valueChanged.emit(val);\n\t\t            }\n\t\t            /* hide dropdown */\n\t\t            _this.hideAutoCompleteDropdown();\n\t\t        };\n\t\t        this.el = this.viewContainerRef.element.nativeElement;\n\t\t    }\n\t\t    AutoCompleteDirective.prototype.ngOnInit = function () {\n\t\t        // wrap this element with <div class=\"ng2-auto-complete\">\n\t\t        var divEl = document.createElement(\"div\");\n\t\t        divEl.className = \"ng2-auto-complete\";\n\t\t        divEl.style.display = \"inline-block\";\n\t\t        divEl.style.position = \"relative\";\n\t\t        this.el.parentElement.insertBefore(divEl, this.el.nextSibling);\n\t\t        divEl.appendChild(this.el);\n\t\t        // apply toString() method for the object\n\t\t        this.selectNewValue(this.ngModel);\n\t\t        // when somewhere else clicked, hide this autocomplete\n\t\t        document.addEventListener(\"click\", this.hideAutoCompleteDropdown);\n\t\t    };\n\t\t    AutoCompleteDirective.prototype.ngOnDestroy = function () {\n\t\t        if (this.componentRef) {\n\t\t            this.componentRef.instance.valueSelected.unsubscribe();\n\t\t        }\n\t\t        document.removeEventListener(\"click\", this.hideAutoCompleteDropdown);\n\t\t    };\n\t\t    //show auto-complete list below the current element\n\t\t    AutoCompleteDirective.prototype.showAutoCompleteDropdown = function () {\n\t\t        this.hideAutoCompleteDropdown();\n\t\t        var factory = this.resolver.resolveComponentFactory(auto_complete_component_1.AutoCompleteComponent);\n\t\t        this.componentRef = this.viewContainerRef.createComponent(factory);\n\t\t        var component = this.componentRef.instance;\n\t\t        component.listFormatter = this.listFormatter;\n\t\t        //component.prefillFunc = this.prefillFunc;\n\t\t        component.pathToData = this.pathToData;\n\t\t        component.minChars = this.minChars;\n\t\t        component.valuePropertyName = this.valuePropertyName || \"id\";\n\t\t        component.displayPropertyName = this.displayPropertyName || \"value\";\n\t\t        component.source = this.source;\n\t\t        component.placeholder = this.autoCompletePlaceholder;\n\t\t        component.valueSelected.subscribe(this.selectNewValue);\n\t\t        this.acDropdownEl = this.componentRef.location.nativeElement;\n\t\t        this.acDropdownEl.style.display = \"none\";\n\t\t        // if this element is not an input tag, move dropdown after input tag\n\t\t        // so that it displays correctly\n\t\t        this.moveAutocompleteDropDownAfterInputEl();\n\t\t        setTimeout(this.styleAutoCompleteDropdown);\n\t\t    };\n\t\t    AutoCompleteDirective.prototype.moveAutocompleteDropDownAfterInputEl = function () {\n\t\t        this.inputEl = this.el;\n\t\t        if (this.el.tagName !== \"INPUT\" && this.acDropdownEl) {\n\t\t            this.inputEl = this.el.querySelector(\"input\");\n\t\t            this.inputEl.parentElement.insertBefore(this.acDropdownEl, this.inputEl.nextSibling);\n\t\t        }\n\t\t    };\n\t\t    AutoCompleteDirective.prototype.elementIn = function (el, containerEl) {\n\t\t        while (el = el.parentNode) {\n\t\t            if (el === containerEl) {\n\t\t                return true;\n\t\t            }\n\t\t            ;\n\t\t        }\n\t\t        return false;\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input(\"auto-complete-placeholder\"), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteDirective.prototype, \"autoCompletePlaceholder\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"list-formatter\"), \n\t\t        __metadata('design:type', Function)\n\t\t    ], AutoCompleteDirective.prototype, \"listFormatter\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"source\"), \n\t\t        __metadata('design:type', Object)\n\t\t    ], AutoCompleteDirective.prototype, \"source\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"path-to-data\"), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteDirective.prototype, \"pathToData\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"min-chars\"), \n\t\t        __metadata('design:type', Number)\n\t\t    ], AutoCompleteDirective.prototype, \"minChars\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"value-property-name\"), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteDirective.prototype, \"valuePropertyName\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(\"display-property-name\"), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteDirective.prototype, \"displayPropertyName\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(), \n\t\t        __metadata('design:type', String)\n\t\t    ], AutoCompleteDirective.prototype, \"ngModel\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Output(), \n\t\t        __metadata('design:type', Object)\n\t\t    ], AutoCompleteDirective.prototype, \"ngModelChange\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Output(\"value-changed\"), \n\t\t        __metadata('design:type', Object)\n\t\t    ], AutoCompleteDirective.prototype, \"valueChanged\", void 0);\n\t\t    AutoCompleteDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: \"[auto-complete], [ng2-auto-complete]\",\n\t\t            host: {\n\t\t                \"(click)\": \"showAutoCompleteDropdown()\"\n\t\t            }\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ComponentFactoryResolver, core_1.ViewContainerRef])\n\t\t    ], AutoCompleteDirective);\n\t\t    return AutoCompleteDirective;\n\t\t}());\n\t\texports.AutoCompleteDirective = AutoCompleteDirective;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-auto-complete.umd.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_9__;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(6));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/common\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-datetime-picker\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/common\"));\n\t\telse\n\t\t\troot[\"ng2-datetime-picker\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/common\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar common_1 = __webpack_require__(3);\n\t\tvar datetime_1 = __webpack_require__(4);\n\t\texports.DateTime = datetime_1.DateTime;\n\t\tvar datetime_picker_component_1 = __webpack_require__(5);\n\t\texports.DateTimePickerComponent = datetime_picker_component_1.DateTimePickerComponent;\n\t\tvar datetime_picker_directive_1 = __webpack_require__(6);\n\t\texports.DateTimePickerDirective = datetime_picker_directive_1.DateTimePickerDirective;\n\t\tvar Ng2DatetimePickerModule = (function () {\n\t\t    function Ng2DatetimePickerModule() {\n\t\t    }\n\t\t    Ng2DatetimePickerModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [common_1.CommonModule, forms_1.FormsModule],\n\t\t            declarations: [datetime_picker_component_1.DateTimePickerComponent, datetime_picker_directive_1.DateTimePickerDirective],\n\t\t            exports: [datetime_picker_component_1.DateTimePickerComponent, datetime_picker_directive_1.DateTimePickerDirective],\n\t\t            entryComponents: [datetime_picker_component_1.DateTimePickerComponent],\n\t\t            providers: [datetime_1.DateTime]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2DatetimePickerModule);\n\t\t    return Ng2DatetimePickerModule;\n\t\t}());\n\t\texports.Ng2DatetimePickerModule = Ng2DatetimePickerModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar DateTime = (function () {\n\t\t    function DateTime() {\n\t\t        this.initialize();\n\t\t    }\n\t\t    DateTime.prototype.initialize = function () {\n\t\t        this.months = [\n\t\t            { fullName: 'January', shortName: 'Jan' },\n\t\t            { fullName: 'February', shortName: 'Feb' },\n\t\t            { fullName: 'March', shortName: 'Mar' },\n\t\t            { fullName: 'April', shortName: 'Apr' },\n\t\t            { fullName: 'May', shortName: 'May' },\n\t\t            { fullName: 'June', shortName: 'Jun' },\n\t\t            { fullName: 'July', shortName: 'Jul' },\n\t\t            { fullName: 'August', shortName: 'Aug' },\n\t\t            { fullName: 'September', shortName: 'Sep' },\n\t\t            { fullName: 'October', shortName: 'Oct' },\n\t\t            { fullName: 'November', shortName: 'Nov' },\n\t\t            { fullName: 'December', shortName: 'Dec' }\n\t\t        ];\n\t\t        this.days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n\t\t        /**\n\t\t         * According to International Standard ISO 8601, Monday is the first day of the week\n\t\t         * followed by Tuesday, Wednesday, Thursday, Friday, Saturday,\n\t\t         * and with Sunday as the seventh and final day.\n\t\t         * However, in Javascript Sunday is 0, Monday is 1.. and so on\n\t\t         */\n\t\t        this.daysOfWeek = [\n\t\t            { fullName: 'Sunday', shortName: 'Su', weekend: true },\n\t\t            { fullName: 'Monday', shortName: 'Mo' },\n\t\t            { fullName: 'Tuesday', shortName: 'Tu' },\n\t\t            { fullName: 'Wednesday', shortName: 'We' },\n\t\t            { fullName: 'Thursday', shortName: 'Th' },\n\t\t            { fullName: 'Friday', shortName: 'Fr' },\n\t\t            { fullName: 'Saturday', shortName: 'Sa', weekend: true }\n\t\t        ];\n\t\t        /**\n\t\t         * if momentjs is available, use momentjs localized months, week, etc.\n\t\t         */\n\t\t        if (typeof moment !== 'undefined') {\n\t\t            this.months = this.months.map(function (el, index) {\n\t\t                el.fullName = moment.months()[index];\n\t\t                el.shortName = moment.monthsShort()[index];\n\t\t                return el;\n\t\t            });\n\t\t            this.daysOfWeek = this.daysOfWeek.map(function (el, index) {\n\t\t                el.fullName = moment.weekdays()[index];\n\t\t                el.shortName = moment.weekdaysShort()[index].substr(0, 2);\n\t\t                return el;\n\t\t            });\n\t\t            this.firstDayOfWeek = moment.localeData().firstDayOfWeek();\n\t\t        }\n\t\t        this.firstDayOfWeek = this.firstDayOfWeek || 0;\n\t\t        this.localizedDaysOfWeek = this.daysOfWeek\n\t\t            .concat(this.daysOfWeek)\n\t\t            .splice(this.firstDayOfWeek, 7);\n\t\t    };\n\t\t    DateTime.prototype.getMonthData = function (year, month) {\n\t\t        year = month > 11 ? year + 1 :\n\t\t            month < 0 ? year - 1 : year;\n\t\t        month = (month + 12) % 12;\n\t\t        var firstDayOfMonth = new Date(year, month, 1);\n\t\t        var lastDayOfMonth = new Date(year, month + 1, 0);\n\t\t        var lastDayOfPreviousMonth = new Date(year, month, 0);\n\t\t        var daysInMonth = lastDayOfMonth.getDate();\n\t\t        var daysInLastMonth = lastDayOfPreviousMonth.getDate();\n\t\t        var dayOfWeek = firstDayOfMonth.getDay();\n\t\t        // Ensure there are always leading days to give context\n\t\t        var leadingDays = (dayOfWeek - this.firstDayOfWeek + 7) % 7 || 7;\n\t\t        var trailingDays = this.days.slice(0, 6 * 7 - (leadingDays + daysInMonth));\n\t\t        if (trailingDays.length > 7) {\n\t\t            trailingDays = trailingDays.slice(0, trailingDays.length - 7);\n\t\t        }\n\t\t        var monthData = {\n\t\t            year: year,\n\t\t            month: month,\n\t\t            days: this.days.slice(0, daysInMonth),\n\t\t            leadingDays: this.days.slice(-leadingDays - (31 - daysInLastMonth), daysInLastMonth),\n\t\t            trailingDays: trailingDays\n\t\t        };\n\t\t        return monthData;\n\t\t    };\n\t\t    ;\n\t\t    DateTime.momentFormatDate = function (d, dateFormat) {\n\t\t        if (typeof moment === 'undefined') {\n\t\t            console.error(\"momentjs is required with dateFormat.\\n        please add <script src=\\\"moment.min.js\\\"></script>\\\"> in your html.\");\n\t\t        }\n\t\t        return moment(d).format(dateFormat);\n\t\t    };\n\t\t    DateTime.momentParse = function (dateStr) {\n\t\t        if (typeof moment === 'undefined') {\n\t\t            console.error(\"momentjs is required with dateFormat.\\n        please add <script src=\\\"moment.min.js\\\"></script>\\\"> in your html.\");\n\t\t        }\n\t\t        return moment(dateStr).toDate();\n\t\t    };\n\t\t    DateTime.formatDate = function (d, dateOnly) {\n\t\t        // return d.toLocaleString('en-us', hash); // IE11 does not understand this\n\t\t        var pad0 = function (number) {\n\t\t            return (\"0\" + number).slice(-2);\n\t\t        };\n\t\t        var ret = d.getFullYear() + '-' + pad0(d.getMonth() + 1) + '-' + pad0(d.getDate());\n\t\t        if (!dateOnly) {\n\t\t            ret += ' ' + pad0(d.getHours()) + ':' + pad0(d.getMinutes());\n\t\t        }\n\t\t        return ret;\n\t\t    };\n\t\t    //return date as given from given string\n\t\t    // without considering timezone and day light saving time considered\n\t\t    DateTime.parse = function (dateStr) {\n\t\t        dateStr = DateTime.removeTimezone(dateStr);\n\t\t        dateStr = dateStr + DateTime.addDSTOffset(dateStr);\n\t\t        return DateTime.getDateFromString(dateStr);\n\t\t    };\n\t\t    //remove timezone\n\t\t    DateTime.removeTimezone = function (dateStr) {\n\t\t        // if no time is given, add 00:00:00 at the end\n\t\t        var matches = dateStr.match(/[0-9]{2}:/);\n\t\t        dateStr += matches ? '' : ' 00:00:00';\n\t\t        return dateStr.replace(/([0-9]{2}-[0-9]{2})-([0-9]{4})/, '$2-$1') //mm-dd-yyyy to yyyy-mm-dd\n\t\t            .replace(/([\\/-][0-9]{2,4})\\ ([0-9]{2}\\:[0-9]{2}\\:)/, '$1T$2') //reformat for FF\n\t\t            .replace(/EDT|EST|CDT|CST|MDT|PDT|PST|UT|GMT/g, '') //remove timezone\n\t\t            .replace(/\\s*\\(\\)\\s*/, '') //remove timezone\n\t\t            .replace(/[\\-\\+][0-9]{2}:?[0-9]{2}$/, '') //remove timezone\n\t\t            .replace(/000Z$/, '00'); //remove timezone\n\t\t    };\n\t\t    DateTime.addDSTOffset = function (dateStr) {\n\t\t        var date = DateTime.getDateFromString(dateStr);\n\t\t        var jan = new Date(date.getFullYear(), 0, 1);\n\t\t        var jul = new Date(date.getFullYear(), 6, 1);\n\t\t        var stdTimezoneOffset = Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());\n\t\t        var isDST = date.getTimezoneOffset() < stdTimezoneOffset;\n\t\t        var offset = isDST ? stdTimezoneOffset - 60 : stdTimezoneOffset;\n\t\t        var diff = offset >= 0 ? '-' : '+';\n\t\t        offset = Math.abs(offset);\n\t\t        return diff +\n\t\t            ('0' + (offset / 60)).slice(-2) + ':' +\n\t\t            ('0' + (offset % 60)).slice(-2);\n\t\t    };\n\t\t    ;\n\t\t    DateTime.getDateFromString = function (dateStr) {\n\t\t        var tmp = dateStr.split(/[\\+\\-:\\ T]/); // split by dash, colon or space\n\t\t        return new Date(parseInt(tmp[0], 10), parseInt(tmp[1], 10) - 1, parseInt(tmp[2], 10), parseInt(tmp[3] || '0', 10), parseInt(tmp[4] || '0', 10), parseInt(tmp[5] || '0', 10));\n\t\t    };\n\t\t    DateTime = __decorate([\n\t\t        core_1.Injectable(), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], DateTime);\n\t\t    return DateTime;\n\t\t}());\n\t\texports.DateTime = DateTime;\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar datetime_1 = __webpack_require__(4);\n\t\t//@TODO\n\t\t// . display currently selected day\n\t\t/**\n\t\t * show a selected date in monthly calendar\n\t\t */\n\t\tvar DateTimePickerComponent = (function () {\n\t\t    function DateTimePickerComponent(elementRef, dateTime, cdRef) {\n\t\t        this.dateTime = dateTime;\n\t\t        this.cdRef = cdRef;\n\t\t        this.changes = new core_1.EventEmitter();\n\t\t        this.closing = new core_1.EventEmitter();\n\t\t        this.el = elementRef.nativeElement;\n\t\t    }\n\t\t    DateTimePickerComponent.prototype.ngAfterViewInit = function () {\n\t\t        if (!this.dateOnly) {\n\t\t            this._hours.nativeElement.addEventListener('keyup', function (e) {\n\t\t                e.stopPropagation();\n\t\t            });\n\t\t            this._hours.nativeElement.addEventListener('mousedown', function (e) {\n\t\t                e.stopPropagation();\n\t\t            });\n\t\t            this._minutes.nativeElement.addEventListener('keyup', function (e) {\n\t\t                e.stopPropagation();\n\t\t            });\n\t\t            this._minutes.nativeElement.addEventListener('mousedown', function (e) {\n\t\t                e.stopPropagation();\n\t\t            });\n\t\t        }\n\t\t    };\n\t\t    Object.defineProperty(DateTimePickerComponent.prototype, \"year\", {\n\t\t        get: function () {\n\t\t            return this.selectedDate.getFullYear();\n\t\t        },\n\t\t        enumerable: true,\n\t\t        configurable: true\n\t\t    });\n\t\t    Object.defineProperty(DateTimePickerComponent.prototype, \"month\", {\n\t\t        get: function () {\n\t\t            return this.selectedDate.getMonth();\n\t\t        },\n\t\t        enumerable: true,\n\t\t        configurable: true\n\t\t    });\n\t\t    Object.defineProperty(DateTimePickerComponent.prototype, \"day\", {\n\t\t        get: function () {\n\t\t            return this.selectedDate.getDate();\n\t\t        },\n\t\t        enumerable: true,\n\t\t        configurable: true\n\t\t    });\n\t\t    Object.defineProperty(DateTimePickerComponent.prototype, \"today\", {\n\t\t        get: function () {\n\t\t            var dt = new Date();\n\t\t            dt.setHours(0);\n\t\t            dt.setMinutes(0);\n\t\t            dt.setSeconds(0);\n\t\t            dt.setMilliseconds(0);\n\t\t            return dt;\n\t\t        },\n\t\t        enumerable: true,\n\t\t        configurable: true\n\t\t    });\n\t\t    DateTimePickerComponent.prototype.initDateTime = function (date) {\n\t\t        this.selectedDate = date;\n\t\t        this.hour = this.selectedDate.getHours();\n\t\t        this.minute = this.selectedDate.getMinutes();\n\t\t        this.monthData = this.dateTime.getMonthData(this.year, this.month);\n\t\t    };\n\t\t    DateTimePickerComponent.prototype.toDate = function (year, month, day) {\n\t\t        return new Date(year, month, day);\n\t\t    };\n\t\t    DateTimePickerComponent.prototype.toDateOnly = function (date) {\n\t\t        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);\n\t\t    };\n\t\t    /**\n\t\t     * set the selected date and close it when closeOnSelect is true\n\t\t     * @param date {Date}\n\t\t     */\n\t\t    DateTimePickerComponent.prototype.selectDate = function (dayNum) {\n\t\t        if (dayNum) {\n\t\t            this.selectedDate = new Date(this.monthData.year, this.monthData.month, dayNum);\n\t\t        }\n\t\t        this.changes.emit({\n\t\t            selectedDate: this.selectedDate,\n\t\t            hour: this.hour,\n\t\t            minute: this.minute\n\t\t        });\n\t\t        this.closing.emit(true);\n\t\t    };\n\t\t    ;\n\t\t    /**\n\t\t     * show prev/next month calendar\n\t\t     */\n\t\t    DateTimePickerComponent.prototype.updateMonthData = function (num) {\n\t\t        this.monthData = this.dateTime.getMonthData(this.monthData.year, this.monthData.month + num);\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.ViewChild('hours'), \n\t\t        __metadata('design:type', core_1.ElementRef)\n\t\t    ], DateTimePickerComponent.prototype, \"_hours\", void 0);\n\t\t    __decorate([\n\t\t        core_1.ViewChild('minutes'), \n\t\t        __metadata('design:type', core_1.ElementRef)\n\t\t    ], DateTimePickerComponent.prototype, \"_minutes\", void 0);\n\t\t    DateTimePickerComponent = __decorate([\n\t\t        core_1.Component({\n\t\t            providers: [datetime_1.DateTime],\n\t\t            selector: 'datetime-picker',\n\t\t            template: \"\\n<div class=\\\"datetime-picker\\\" tabindex=\\\"0\\\">\\n\\n  <!-- Month - Year  -->\\n  <div class=\\\"month\\\">\\n    <button type=\\\"button\\\" class=\\\"prev\\\" (click)=\\\"updateMonthData(-1)\\\">&laquo;</button>\\n     <span title=\\\"{{dateTime.months[monthData.month].fullName}}\\\">\\n           {{dateTime.months[monthData.month].shortName}}\\n     </span>\\n    {{monthData.year}}\\n    <button type=\\\"button\\\" class=\\\"next\\\" (click)=\\\"updateMonthData(+1)\\\">&raquo;</button>\\n  </div>\\n\\n  <div class=\\\"days\\\">\\n\\n    <!-- Su Mo Tu We Th Fr Sa -->\\n    <div class=\\\"day-of-week\\\"\\n         *ngFor=\\\"let dayOfWeek of dateTime.localizedDaysOfWeek\\\"\\n         [ngClass]=\\\"{weekend: dayOfWeek.weekend}\\\"\\n         title=\\\"{{dayOfWeek.fullName}}\\\">\\n      {{dayOfWeek.shortName}}\\n    </div>\\n\\n    <!-- Fill up blank days for this month -->\\n    <div *ngIf=\\\"monthData.leadingDays.length < 7\\\">\\n      <div class=\\\"day\\\" *ngFor=\\\"let dayNum of monthData.leadingDays\\\"\\n           [ngClass]=\\\"{weekend: [0,6].indexOf(toDate(monthData.year, monthData.month-1, dayNum).getDay()) !== -1}\\\">\\n        {{dayNum}}\\n      </div>\\n    </div>\\n\\n    <div class=\\\"day selectable\\\"\\n         *ngFor=\\\"let dayNum of monthData.days\\\"\\n         (click)=\\\"selectDate(dayNum)\\\"\\n         title=\\\"{{monthData.year}}-{{monthData.month+1}}-{{dayNum}}\\\"\\n         [ngClass]=\\\"{\\n           selected:\\n             toDate(monthData.year, monthData.month, dayNum).getTime() === toDateOnly(selectedDate).getTime(),\\n           today:\\n             toDate(monthData.year, monthData.month, dayNum).getTime() === today.getTime(),\\n           weekend:\\n             [0,6].indexOf(toDate(monthData.year, monthData.month, dayNum).getDay()) !== -1\\n         }\\\">\\n      {{dayNum}}\\n    </div>\\n\\n    <!-- Fill up blank days for this month -->\\n    <div *ngIf=\\\"monthData.trailingDays.length < 7\\\">\\n      <div class=\\\"day\\\"\\n           *ngFor=\\\"let dayNum of monthData.trailingDays\\\"\\n           [ngClass]=\\\"{weekend: [0,6].indexOf(toDate(monthData.year, monthData.month+1, dayNum).getDay()) !== -1}\\\">\\n        {{dayNum}}\\n      </div>\\n    </div>\\n  </div>\\n\\n  <!-- Time -->\\n  <div class=\\\"days\\\" id=\\\"time\\\" *ngIf=\\\"!dateOnly\\\">\\n    <label class=\\\"timeLabel\\\">Time:</label>\\n    <span class=\\\"timeValue\\\">\\n      {{(\\\"0\\\"+hour).slice(-2)}} : {{(\\\"0\\\"+minute).slice(-2)}}\\n    </span><br/>\\n    <label class=\\\"hourLabel\\\">Hour:</label>\\n    <input #hours class=\\\"hourInput\\\"\\n           (change)=\\\"selectDate()\\\"\\n           type=\\\"range\\\" min=\\\"0\\\" max=\\\"23\\\" [(ngModel)]=\\\"hour\\\" />\\n    <label class=\\\"minutesLabel\\\">Min:</label>\\n    <input #minutes class=\\\"minutesInput\\\"\\n           (change)=\\\"selectDate()\\\"\\n           type=\\\"range\\\" min=\\\"0\\\" max=\\\"59\\\" range=\\\"10\\\" [(ngModel)]=\\\"minute\\\"/>\\n  </div>\\n</div>\\n\\n<!--<hr/>-->\\n<!--Date: {{selectedDate}}<br/>-->\\n<!--Hour: {{hour}} Minute: {{minute}}<br/>-->\\n  \",\n\t\t            styles: [\n\t\t                \"\\n @keyframes slideDown {\\n  0% {\\n    transform:  translateY(-10px);\\n  }\\n  100% {\\n    transform: translateY(0px);\\n  }\\n}\\n\\n.datetime-picker {\\n    color: #333;\\n    outline-width: 0;\\n    font: normal 14px sans-serif;\\n    border: 1px solid #ddd;\\n    display: inline-block;\\n    background: #fff;\\n    animation: slideDown 0.1s ease-in-out;\\n    animation-fill-mode: both;\\n}\\n.datetime-picker > .month {\\n    text-align: center;\\n    line-height: 22px;\\n    padding: 10px;\\n    background: #fcfcfc;\\n    text-transform: uppercase;\\n    font-weight: bold;\\n    border-bottom: 1px solid #ddd;\\n    position: relative;\\n}\\n.datetime-picker > .month > button {\\n    color: #555;\\n    font: normal 14px sans-serif;\\n    outline: none;\\n    position: absolute;\\n    background: transparent;\\n    border: none;\\n    cursor: pointer;\\n}\\n.datetime-picker > .month > button:hover {\\n    color: #333;\\n}\\n.datetime-picker > .month > button.prev {\\n    left: 10px;\\n}\\n.datetime-picker > .month > button.next {\\n    right: 10px;\\n}\\n.datetime-picker > .days {\\n    width: 210px; /* 30 x 7 */\\n    margin: 10px;\\n    text-align: center;\\n}\\n.datetime-picker > .days .day-of-week,\\n.datetime-picker > .days .day {\\n    box-sizing: border-box;\\n    -moz-box-sizing: border-box;\\n    border: 1px solid transparent;\\n    width: 30px;\\n    line-height: 28px;\\n    float: left;\\n}\\n.datetime-picker > .days .day-of-week {\\n    font-weight: bold;\\n}\\n.datetime-picker > .days .day-of-week.weekend {\\n    color: #ccc;\\n    background-color: inherit;\\n}\\n.datetime-picker > .days .day:not(.selectable) {\\n    color: #ccc;\\n    cursor: default;\\n}\\n.datetime-picker > .days .weekend {\\n    color: #ccc;\\n    background-color: #eee;\\n}\\n.datetime-picker > .days .day.selectable  {\\n    cursor: pointer;\\n}\\n.datetime-picker > .days .day.selected {\\n    background: gray;\\n    color: #fff;\\n}\\n.datetime-picker > .days .day:not(.selected).selectable:hover {\\n    background: #eee;\\n}\\n.datetime-picker > .days:after {\\n    content: '';\\n    display: block;\\n    clear: left;\\n    height: 0;\\n}\\n.datetime-picker .hourLabel,\\n.datetime-picker .minutesLabel {\\n    display: inline-block;\\n    width: 40px;\\n    text-align: right;\\n}\\n.datetime-picker input[type=range] {\\n    width: 150px;\\n}\\n  \"\n\t\t            ],\n\t\t            encapsulation: core_1.ViewEncapsulation.None\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ElementRef, datetime_1.DateTime, core_1.ChangeDetectorRef])\n\t\t    ], DateTimePickerComponent);\n\t\t    return DateTimePickerComponent;\n\t\t}());\n\t\texports.DateTimePickerComponent = DateTimePickerComponent;\n\t\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar datetime_picker_component_1 = __webpack_require__(5);\n\t\tvar datetime_1 = __webpack_require__(4);\n\t\t/**\n\t\t * To simplify the implementation, it limits the type if value to string only, not a date\n\t\t * If the given string is not a valid date, it defaults back to today\n\t\t */\n\t\tvar DateTimePickerDirective = (function () {\n\t\t    function DateTimePickerDirective(_resolver, _viewContainerRef) {\n\t\t        var _this = this;\n\t\t        this._resolver = _resolver;\n\t\t        this._viewContainerRef = _viewContainerRef;\n\t\t        /**\n\t\t         * @deprecated\n\t\t         */\n\t\t        this.ngModelChange = new core_1.EventEmitter();\n\t\t        this.valueChange = new core_1.EventEmitter();\n\t\t        this._keyEventListener = function (e) {\n\t\t            if (e.keyCode === 27) {\n\t\t                _this.hideDatetimePicker();\n\t\t            }\n\t\t        };\n\t\t        this.hideDatetimePicker = function (event) {\n\t\t            if (_this._componentRef) {\n\t\t                if (event && event.type === 'click' &&\n\t\t                    event.target !== _this._el && !_this._elementIn(event.target, _this._datetimePicker)) {\n\t\t                    _this._componentRef.destroy();\n\t\t                    _this._componentRef = undefined;\n\t\t                }\n\t\t                else if (!event) {\n\t\t                    _this._componentRef.destroy();\n\t\t                    _this._componentRef = undefined;\n\t\t                }\n\t\t            }\n\t\t        };\n\t\t        this._el = this._viewContainerRef.element.nativeElement;\n\t\t    }\n\t\t    DateTimePickerDirective.prototype.ngOnInit = function () {\n\t\t        //wrap this element with a <div> tag, so that we can position dynamic elememnt correctly\n\t\t        var wrapper = document.createElement(\"div\");\n\t\t        wrapper.className = 'ng2-datetime-picker';\n\t\t        wrapper.style.display = 'inline-block';\n\t\t        wrapper.style.position = 'relative';\n\t\t        this._el.parentElement.insertBefore(wrapper, this._el.nextSibling);\n\t\t        wrapper.appendChild(this._el);\n\t\t        this._registerEventListeners();\n\t\t    };\n\t\t    DateTimePickerDirective.prototype.ngOnChanges = function (changes) {\n\t\t        var _this = this;\n\t\t        if (changes['value'] !== undefined || changes['ngModel'] !== undefined) {\n\t\t            if (changes['ngModel'] !== undefined) {\n\t\t                this.value = this.ngModel;\n\t\t            }\n\t\t            var dateNgModel_1;\n\t\t            if (typeof this.value === 'string') {\n\t\t                //remove timezone and respect day light saving time\n\t\t                dateNgModel_1 = this.dateFormat ?\n\t\t                    datetime_1.DateTime.momentParse('' + this.value) :\n\t\t                    datetime_1.DateTime.parse('' + this.value);\n\t\t            }\n\t\t            else if (this.value instanceof Date) {\n\t\t                dateNgModel_1 = this.value;\n\t\t            }\n\t\t            else {\n\t\t                dateNgModel_1 = new Date();\n\t\t            }\n\t\t            var formatted = void 0;\n\t\t            if (this.dateFormat) {\n\t\t                formatted = datetime_1.DateTime.momentFormatDate(dateNgModel_1, this.dateFormat);\n\t\t            }\n\t\t            else {\n\t\t                formatted = datetime_1.DateTime.formatDate(dateNgModel_1, this.dateOnly);\n\t\t            }\n\t\t            this._el['value'] = formatted;\n\t\t            this._value = dateNgModel_1;\n\t\t            // @deprecated\n\t\t            if (this.dateFormat) {\n\t\t                dateNgModel_1.toString = function () {\n\t\t                    return datetime_1.DateTime.momentFormatDate(dateNgModel_1, _this.dateFormat);\n\t\t                };\n\t\t            }\n\t\t            else {\n\t\t                dateNgModel_1.toString = function () {\n\t\t                    return datetime_1.DateTime.formatDate(dateNgModel_1, _this.dateOnly);\n\t\t                };\n\t\t            }\n\t\t            setTimeout(function () {\n\t\t                _this.ngModelChange.emit(dateNgModel_1);\n\t\t            });\n\t\t            this._initDate();\n\t\t        }\n\t\t    };\n\t\t    DateTimePickerDirective.prototype.ngOnDestroy = function () {\n\t\t        // add a click listener to document, so that it can hide when others clicked\n\t\t        document.body.removeEventListener('click', this.hideDatetimePicker);\n\t\t        this._el.removeEventListener('keyup', this._keyEventListener);\n\t\t        if (this._datetimePicker) {\n\t\t            this._datetimePicker.removeEventListener('keyup', this._keyEventListener);\n\t\t        }\n\t\t    };\n\t\t    //show datetimePicker below the current element\n\t\t    DateTimePickerDirective.prototype.showDatetimePicker = function () {\n\t\t        var _this = this;\n\t\t        if (this._componentRef) {\n\t\t            return;\n\t\t        }\n\t\t        var factory = this._resolver.resolveComponentFactory(datetime_picker_component_1.DateTimePickerComponent);\n\t\t        this._componentRef = this._viewContainerRef.createComponent(factory);\n\t\t        this._datetimePicker = this._componentRef.location.nativeElement;\n\t\t        this._datetimePicker.addEventListener('keyup', this._keyEventListener);\n\t\t        this._initDate();\n\t\t        this._styleDatetimePicker();\n\t\t        var component = this._componentRef.instance;\n\t\t        component.changes.subscribe(function (changes) {\n\t\t            var newNgModel = new Date(changes.selectedDate);\n\t\t            newNgModel.setHours(parseInt(changes.hour, 10));\n\t\t            newNgModel.setMinutes(parseInt(changes.minute, 10));\n\t\t            var formatted;\n\t\t            if (_this.dateFormat) {\n\t\t                formatted = datetime_1.DateTime.momentFormatDate(newNgModel, _this.dateFormat);\n\t\t            }\n\t\t            else {\n\t\t                formatted = datetime_1.DateTime.formatDate(newNgModel, _this.dateOnly);\n\t\t            }\n\t\t            _this._el['value'] = formatted;\n\t\t            _this._value = newNgModel;\n\t\t            _this.valueChange.emit(newNgModel);\n\t\t            // @deprecated\n\t\t            if (_this.dateFormat) {\n\t\t                newNgModel.toString = function () {\n\t\t                    return datetime_1.DateTime.momentFormatDate(newNgModel, _this.dateFormat);\n\t\t                };\n\t\t            }\n\t\t            else {\n\t\t                newNgModel.toString = function () {\n\t\t                    return datetime_1.DateTime.formatDate(newNgModel, _this.dateOnly);\n\t\t                };\n\t\t            }\n\t\t            _this.ngModelChange.emit(newNgModel);\n\t\t        });\n\t\t        component.closing.subscribe(function () {\n\t\t            if (_this.closeOnSelect !== \"false\") {\n\t\t                _this.hideDatetimePicker();\n\t\t            }\n\t\t        });\n\t\t    };\n\t\t    DateTimePickerDirective.prototype._elementIn = function (el, containerEl) {\n\t\t        while (el = el.parentNode) {\n\t\t            if (el === containerEl)\n\t\t                return true;\n\t\t        }\n\t\t        return false;\n\t\t    };\n\t\t    DateTimePickerDirective.prototype._initDate = function () {\n\t\t        if (this._componentRef) {\n\t\t            var component = this._componentRef.instance;\n\t\t            component.initDateTime(this._value);\n\t\t            component.dateOnly = this.dateOnly;\n\t\t        }\n\t\t    };\n\t\t    DateTimePickerDirective.prototype._registerEventListeners = function () {\n\t\t        // add a click listener to document, so that it can hide when others clicked\n\t\t        document.body.addEventListener('click', this.hideDatetimePicker);\n\t\t        this._el.addEventListener('keyup', this._keyEventListener);\n\t\t    };\n\t\t    DateTimePickerDirective.prototype._styleDatetimePicker = function () {\n\t\t        var _this = this;\n\t\t        // setting width/height auto complete\n\t\t        var thisElBCR = this._el.getBoundingClientRect();\n\t\t        this._datetimePicker.style.width = thisElBCR.width + 'px';\n\t\t        this._datetimePicker.style.position = 'absolute';\n\t\t        this._datetimePicker.style.zIndex = '1000';\n\t\t        this._datetimePicker.style.left = '0';\n\t\t        this._datetimePicker.style.transition = 'height 0.3s ease-in';\n\t\t        this._datetimePicker.style.visibility = 'hidden';\n\t\t        setTimeout(function () {\n\t\t            var thisElBcr = _this._el.getBoundingClientRect();\n\t\t            var datetimePickerElBcr = _this._datetimePicker.getBoundingClientRect();\n\t\t            if (thisElBcr.bottom + datetimePickerElBcr.height > window.innerHeight) {\n\t\t                // if not enough space to show on below, show above\n\t\t                _this._datetimePicker.style.bottom = '0';\n\t\t            }\n\t\t            else {\n\t\t                // otherwise, show below\n\t\t                _this._datetimePicker.style.top = thisElBcr.height + 'px';\n\t\t            }\n\t\t            _this._datetimePicker.style.visibility = 'visible';\n\t\t        });\n\t\t    };\n\t\t    ;\n\t\t    __decorate([\n\t\t        core_1.Input('date-format'), \n\t\t        __metadata('design:type', String)\n\t\t    ], DateTimePickerDirective.prototype, \"dateFormat\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input('date-only'), \n\t\t        __metadata('design:type', Boolean)\n\t\t    ], DateTimePickerDirective.prototype, \"dateOnly\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input('close-on-select'), \n\t\t        __metadata('design:type', String)\n\t\t    ], DateTimePickerDirective.prototype, \"closeOnSelect\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input(), \n\t\t        __metadata('design:type', Date)\n\t\t    ], DateTimePickerDirective.prototype, \"ngModel\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Output(), \n\t\t        __metadata('design:type', core_1.EventEmitter)\n\t\t    ], DateTimePickerDirective.prototype, \"ngModelChange\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input('value'), \n\t\t        __metadata('design:type', Object)\n\t\t    ], DateTimePickerDirective.prototype, \"value\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Output('valueChange'), \n\t\t        __metadata('design:type', core_1.EventEmitter)\n\t\t    ], DateTimePickerDirective.prototype, \"valueChange\", void 0);\n\t\t    DateTimePickerDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: '[datetime-picker], [ng2-datetime-picker]',\n\t\t            providers: [datetime_1.DateTime],\n\t\t            host: {\n\t\t                '(click)': 'showDatetimePicker()'\n\t\t            }\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ComponentFactoryResolver, core_1.ViewContainerRef])\n\t\t    ], DateTimePickerDirective);\n\t\t    return DateTimePickerDirective;\n\t\t}());\n\t\texports.DateTimePickerDirective = DateTimePickerDirective;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-datetime-picker.umd.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-collapsable\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-collapsable\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_collapsable_component_1 = __webpack_require__(4);\n\t\texports.Ng2CollapsableComponent = ng2_collapsable_component_1.Ng2CollapsableComponent;\n\t\tvar Ng2CollapsableModule = (function () {\n\t\t    function Ng2CollapsableModule() {\n\t\t    }\n\t\t    Ng2CollapsableModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [ng2_collapsable_component_1.Ng2CollapsableComponent],\n\t\t            exports: [ng2_collapsable_component_1.Ng2CollapsableComponent]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2CollapsableModule);\n\t\t    return Ng2CollapsableModule;\n\t\t}());\n\t\texports.Ng2CollapsableModule = Ng2CollapsableModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Ng2CollapsableComponent = (function () {\n\t\t    function Ng2CollapsableComponent(viewContainer) {\n\t\t        this.viewContainer = viewContainer;\n\t\t        this.selectedIndexClass = 'selected';\n\t\t        this.selectedContentsClass = 'selected';\n\t\t        this.el = this.viewContainer.element.nativeElement;\n\t\t    }\n\t\t    Ng2CollapsableComponent.prototype.ngAfterViewInit = function () {\n\t\t        var _this = this;\n\t\t        this.indexEls = [].slice.call(this.el.querySelectorAll('[index]'));\n\t\t        this.contentsEls = [].slice.call(this.el.querySelectorAll('[contents]'));\n\t\t        this.selectTab(this.selectedIndex);\n\t\t        this.indexEls.forEach(function (el) {\n\t\t            el.addEventListener('click', function () {\n\t\t                _this.selectTab(el.getAttribute('index'));\n\t\t            });\n\t\t        });\n\t\t    };\n\t\t    Ng2CollapsableComponent.prototype.selectTab = function (id) {\n\t\t        var _this = this;\n\t\t        id = id || this.indexEls[0].getAttribute('index');\n\t\t        this.indexEls.forEach(function (el) {\n\t\t            _this.removeClass(el, _this.selectedIndexClass);\n\t\t            if (el.getAttribute('index') == id) {\n\t\t                _this.addClass(el, _this.selectedIndexClass);\n\t\t            }\n\t\t        });\n\t\t        this.contentsEls.forEach(function (el) {\n\t\t            _this.removeClass(el, _this.selectedContentsClass);\n\t\t            if (el.getAttribute('contents') == id) {\n\t\t                _this.addClass(el, _this.selectedContentsClass);\n\t\t            }\n\t\t        });\n\t\t    };\n\t\t    Ng2CollapsableComponent.prototype.addClass = function (el, str) {\n\t\t        var classNames = (el.className || '').split(' ');\n\t\t        classNames.push(str);\n\t\t        el.className = classNames.join(' ');\n\t\t    };\n\t\t    Ng2CollapsableComponent.prototype.removeClass = function (el, str) {\n\t\t        el.className = (el.className || '').replace(new RegExp('[ ]*' + str), '');\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input('selected'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2CollapsableComponent.prototype, \"selectedIndex\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input('selected-index-class'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2CollapsableComponent.prototype, \"selectedIndexClass\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input('selected-contents-class'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2CollapsableComponent.prototype, \"selectedContentsClass\", void 0);\n\t\t    Ng2CollapsableComponent = __decorate([\n\t\t        core_1.Component({\n\t\t            selector: 'ng2-collapsable, [ng2-collapsable]',\n\t\t            encapsulation: core_1.ViewEncapsulation.None,\n\t\t            template: \"<ng-content></ng-content>\",\n\t\t            styles: [\"\\n    [ng2-collapsable] [index] {\\n      display: block;\\n      cursor: pointer;\\n      position: relative;\\n      margin: 2px 0 0 0;\\n      padding: .5em .5em .5em .7em;\\n      border: 1px solid #cccccc;\\n      background: #ededed;\\n      font-weight: normal;\\n      border-radius: 2px; \\n      color: #2b2b2b;\\n    }\\n    [ng2-collapsable] [index].selected {\\n      border: 1px solid #003eff;\\n      background: #007fff;\\n      color: #ffffff;\\n      border-radius: 2px 2px 0 0;\\n    }\\n    [ng2-collapsable] [contents] {\\n      border-top: 0;\\n      background: #ffffff;\\n      color: #333333;\\n      padding: 0px;\\n      border-radius: 0 0 2px 2px;\\n      height: 0;\\n      border: 0;\\n      font-size: 0;\\n    }\\n    [ng2-collapsable] [contents].selected {\\n      height: 50px;\\n      padding: 10px;\\n      border: 1px solid #dddddd;\\n      transition: font-size 0.3s ease-in, height 0.3s ease-in;\\n      font-size: inherit;\\n    }\\n  \"],\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef])\n\t\t    ], Ng2CollapsableComponent);\n\t\t    return Ng2CollapsableComponent;\n\t\t}());\n\t\texports.Ng2CollapsableComponent = Ng2CollapsableComponent;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-collapsable.umd.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-infinite-list\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-infinite-list\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_infinite_list_directive_1 = __webpack_require__(4);\n\t\texports.Ng2InfiniteListDirective = ng2_infinite_list_directive_1.Ng2InfiniteListDirective;\n\t\tvar Ng2InfiniteListModule = (function () {\n\t\t    function Ng2InfiniteListModule() {\n\t\t    }\n\t\t    Ng2InfiniteListModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [ng2_infinite_list_directive_1.Ng2InfiniteListDirective],\n\t\t            exports: [ng2_infinite_list_directive_1.Ng2InfiniteListDirective]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2InfiniteListModule);\n\t\t    return Ng2InfiniteListModule;\n\t\t}());\n\t\texports.Ng2InfiniteListModule = Ng2InfiniteListModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar ng2_utils_1 = __webpack_require__(5);\n\t\tvar Ng2InfiniteListDirective = (function () {\n\t\t    function Ng2InfiniteListDirective(el) {\n\t\t        var _this = this;\n\t\t        this.endVisible = new core_1.EventEmitter();\n\t\t        this.elementVisible = ng2_utils_1.elementVisible;\n\t\t        this.scrollListener = function () {\n\t\t            var visible = _this.elementVisible(_this.endEl, _this.el);\n\t\t            if (_this.horizontal && (visible.left || visible.right)) {\n\t\t                _this.endVisible.emit(true);\n\t\t            }\n\t\t            else if (!_this.horizontal && (visible.top || visible.bottom)) {\n\t\t                _this.endVisible.emit(true);\n\t\t            }\n\t\t        };\n\t\t        this.el = el.nativeElement;\n\t\t    }\n\t\t    // setup list of sections\n\t\t    Ng2InfiniteListDirective.prototype.ngOnInit = function () {\n\t\t        this.endEl = this.el.querySelector('[ng2-infinite-list-end]');\n\t\t        if (!this.endEl) {\n\t\t            throw \"Invalid 'ng2-infinite-list-end\";\n\t\t        }\n\t\t        this.scrollListener();\n\t\t        this.el.addEventListener('scroll', this.scrollListener);\n\t\t        window.addEventListener('resize', this.scrollListener);\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input(), \n\t\t        __metadata('design:type', Boolean)\n\t\t    ], Ng2InfiniteListDirective.prototype, \"horizontal\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Output(), \n\t\t        __metadata('design:type', Object)\n\t\t    ], Ng2InfiniteListDirective.prototype, \"endVisible\", void 0);\n\t\t    Ng2InfiniteListDirective = __decorate([\n\t\t        core_1.Directive({ selector: '[ng2-infinite-list]' }), \n\t\t        __metadata('design:paramtypes', [core_1.ElementRef])\n\t\t    ], Ng2InfiniteListDirective);\n\t\t    return Ng2InfiniteListDirective;\n\t\t}());\n\t\texports.Ng2InfiniteListDirective = Ng2InfiniteListDirective;\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\t\tif(true)\n\t\t\t\tmodule.exports = factory(__webpack_require__(1));\n\t\t\telse if(typeof define === 'function' && define.amd)\n\t\t\t\tdefine([\"@angular/core\"], factory);\n\t\t\telse if(typeof exports === 'object')\n\t\t\t\texports[\"ng2-utils\"] = factory(require(\"@angular/core\"));\n\t\t\telse\n\t\t\t\troot[\"ng2-utils\"] = factory(root[\"@angular/core\"]);\n\t\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\n\t\treturn /******/ (function(modules) { // webpackBootstrap\n\t\t/******/ \t// The module cache\n\t\t/******/ \tvar installedModules = {};\n\t\t/******/\n\t\t/******/ \t// The require function\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\t/******/\n\t\t/******/ \t\t// Check if module is in cache\n\t\t/******/ \t\tif(installedModules[moduleId])\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\t/******/\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t\t/******/ \t\t\texports: {},\n\t\t/******/ \t\t\tid: moduleId,\n\t\t/******/ \t\t\tloaded: false\n\t\t/******/ \t\t};\n\t\t/******/\n\t\t/******/ \t\t// Execute the module function\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t/******/\n\t\t/******/ \t\t// Flag the module as loaded\n\t\t/******/ \t\tmodule.loaded = true;\n\t\t/******/\n\t\t/******/ \t\t// Return the exports of the module\n\t\t/******/ \t\treturn module.exports;\n\t\t/******/ \t}\n\t\t/******/\n\t\t/******/\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\n\t\t/******/ \t__webpack_require__.m = modules;\n\t\t/******/\n\t\t/******/ \t// expose the module cache\n\t\t/******/ \t__webpack_require__.c = installedModules;\n\t\t/******/\n\t\t/******/ \t// __webpack_public_path__\n\t\t/******/ \t__webpack_require__.p = \"\";\n\t\t/******/\n\t\t/******/ \t// Load entry module and return exports\n\t\t/******/ \treturn __webpack_require__(0);\n\t\t/******/ })\n\t\t/************************************************************************/\n\t\t/******/ ([\n\t\t/* 0 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar scroll_to_1 = __webpack_require__(2);\n\t\t\texports.scrollTo = scroll_to_1.scrollTo;\n\t\t\tvar element_visible_1 = __webpack_require__(3);\n\t\t\texports.elementVisible = element_visible_1.elementVisible;\n\t\t\tvar computed_style_1 = __webpack_require__(4);\n\t\t\texports.computedStyle = computed_style_1.computedStyle;\n\t\t\tvar outer_width_1 = __webpack_require__(5);\n\t\t\texports.outerWidth = outer_width_1.outerWidth;\n\t\t\tvar outer_height_1 = __webpack_require__(6);\n\t\t\texports.outerHeight = outer_height_1.outerHeight;\n\t\t\tvar Ng2UtilsModule = (function () {\n\t\t\t    function Ng2UtilsModule() {\n\t\t\t    }\n\t\t\t    Ng2UtilsModule = __decorate([\n\t\t\t        core_1.NgModule({\n\t\t\t            declarations: [\n\t\t\t                scroll_to_1.scrollTo,\n\t\t\t                element_visible_1.elementVisible,\n\t\t\t                computed_style_1.computedStyle,\n\t\t\t                outer_width_1.outerWidth,\n\t\t\t                outer_height_1.outerHeight\n\t\t\t            ],\n\t\t\t            exports: [\n\t\t\t                scroll_to_1.scrollTo,\n\t\t\t                element_visible_1.elementVisible,\n\t\t\t                computed_style_1.computedStyle,\n\t\t\t                outer_width_1.outerWidth,\n\t\t\t                outer_height_1.outerHeight\n\t\t\t            ]\n\t\t\t        }), \n\t\t\t        __metadata('design:paramtypes', [])\n\t\t\t    ], Ng2UtilsModule);\n\t\t\t    return Ng2UtilsModule;\n\t\t\t}());\n\t\t\texports.Ng2UtilsModule = Ng2UtilsModule;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 1 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\t\n\t\t/***/ },\n\t\t/* 2 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * scroll to the selector within the parent selector by scrolling 10 times within 500ms\n\t\t\t * @param selector\n\t\t\t * @param parentSelector\n\t\t\t */\n\t\t\tfunction scrollTo(selector, parentSelector) {\n\t\t\t    console.log('selector', selector, 'parentSelector', parentSelector);\n\t\t\t    var parentEl, targetEl;\n\t\t\t    targetEl = document.querySelector(selector);\n\t\t\t    if (!targetEl) {\n\t\t\t        throw \"Invalid selector \" + selector;\n\t\t\t    }\n\t\t\t    parentEl = document.querySelector(parentSelector);\n\t\t\t    if (!parentEl) {\n\t\t\t        throw \"Invalid parent selector \" + parentSelector;\n\t\t\t    }\n\t\t\t    var parentElStyle = window.getComputedStyle(parentEl);\n\t\t\t    parentEl = parentElStyle['overflow'] === 'auto' ? parentEl : document.body;\n\t\t\t    var currentScrollTop = parentEl.scrollTop;\n\t\t\t    var targetOffsetTop = targetEl.offsetTop;\n\t\t\t    if (parentEl === document.body) {\n\t\t\t        var bodyRect = document.body.getBoundingClientRect();\n\t\t\t        var targetRect = targetEl.getBoundingClientRect();\n\t\t\t        targetOffsetTop = targetRect.top - bodyRect.top;\n\t\t\t    }\n\t\t\t    var step = Math.ceil((targetOffsetTop - currentScrollTop) / 10);\n\t\t\t    (function loop(i) {\n\t\t\t        setTimeout(function main() {\n\t\t\t            parentEl.scrollTop += step;\n\t\t\t            i > 1 && loop(i - 1);\n\t\t\t        }, 50);\n\t\t\t    }(10));\n\t\t\t}\n\t\t\texports.scrollTo = scrollTo;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 3 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * Returns an element is visible within outer element\n\t\t\t * @param innerEl\n\t\t\t * @param outerEl\n\t\t\t * @param adjustment\n\t\t\t * @returns {{top: boolean, bottom: boolean, left: boolean, right: boolean}}\n\t\t\t */\n\t\t\tfunction elementVisible(innerEl, outerEl, adjustment) {\n\t\t\t    var innerRect = innerEl.getBoundingClientRect();\n\t\t\t    var bottomAdjustment = (adjustment && adjustment.bottom || 0);\n\t\t\t    if (outerEl === window) {\n\t\t\t        return {\n\t\t\t            top: innerRect.bottom - bottomAdjustment > window.innerHeight\n\t\t\t                && innerRect.top < window.innerHeight,\n\t\t\t            bottom: innerRect.bottom - bottomAdjustment > 0\n\t\t\t                && innerRect.bottom < window.innerHeight,\n\t\t\t            left: innerRect.right > window.innerWidth\n\t\t\t                && innerRect.left < window.innerWidth,\n\t\t\t            right: innerRect.right > 0\n\t\t\t                && innerRect.right < window.innerWidth\n\t\t\t        };\n\t\t\t    }\n\t\t\t    else {\n\t\t\t        var outerRect = outerEl.getBoundingClientRect();\n\t\t\t        var defaultView = (innerEl.ownerDocument || document).defaultView;\n\t\t\t        var computedStyle = defaultView.getComputedStyle(outerEl, null);\n\t\t\t        var outerRectBorderTopWidth = parseInt(computedStyle.getPropertyValue('border-top-width'), 10);\n\t\t\t        var outerRectBorderLeftWidth = parseInt(computedStyle.getPropertyValue('border-left-width'), 10);\n\t\t\t        /* top is visible or bottom is visible */\n\t\t\t        var topVisible = (innerRect.top >= outerRect.top\n\t\t\t            && innerRect.top < outerRect.bottom);\n\t\t\t        var bottomVisible = (innerRect.bottom > (outerRect.top + outerRectBorderTopWidth)\n\t\t\t            && innerRect.bottom < outerRect.bottom);\n\t\t\t        var leftVisible = (innerRect.left >= outerRect.left\n\t\t\t            && innerRect.left < outerRect.right);\n\t\t\t        var rightVisible = (innerRect.right > (outerRect.left + outerRectBorderLeftWidth)\n\t\t\t            && innerRect.right < outerRect.right);\n\t\t\t        return {\n\t\t\t            top: topVisible,\n\t\t\t            bottom: bottomVisible,\n\t\t\t            left: leftVisible,\n\t\t\t            right: rightVisible\n\t\t\t        };\n\t\t\t    }\n\t\t\t}\n\t\t\texports.elementVisible = elementVisible;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 4 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * returns coumputed style of given element\n\t\t\t * @param el\n\t\t\t * @param styleProp\n\t\t\t * @returns {any}\n\t\t\t */\n\t\t\tfunction computedStyle(el, styleProp) {\n\t\t\t    var value, defaultView = (el.ownerDocument || document).defaultView;\n\t\t\t    // W3C standard way:\n\t\t\t    if (defaultView && defaultView.getComputedStyle) {\n\t\t\t        // sanitize property name to css notation\n\t\t\t        // (hypen separated words eg. font-Size)\n\t\t\t        styleProp = styleProp.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n\t\t\t        return defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);\n\t\t\t    }\n\t\t\t    else if (el['currentStyle']) {\n\t\t\t        // sanitize property name to camelCase\n\t\t\t        styleProp = styleProp.replace(/\\-(\\w)/g, function (str, letter) {\n\t\t\t            return letter.toUpperCase();\n\t\t\t        });\n\t\t\t        value = el['currentStyle'][styleProp];\n\t\t\t        // convert other units to pixels on IE\n\t\t\t        if (/^\\d+(em|pt|%|ex)?$/i.test(value)) {\n\t\t\t            return (function (value) {\n\t\t\t                var oldLeft = el.style.left, oldRsLeft = el['runtimeStyle'].left;\n\t\t\t                el['runtimeStyle'].left = el['currentStyle'].left;\n\t\t\t                el.style.left = value || 0;\n\t\t\t                value = el.style['pixelLeft'] + \"px\";\n\t\t\t                el.style.left = oldLeft;\n\t\t\t                el['runtimeStyle'].left = oldRsLeft;\n\t\t\t                return value;\n\t\t\t            })(value);\n\t\t\t        }\n\t\t\t        return value;\n\t\t\t    }\n\t\t\t}\n\t\t\texports.computedStyle = computedStyle;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 5 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tfunction outerWidth(el) {\n\t\t\t    var style = getComputedStyle(el);\n\t\t\t    return el.offsetWidth +\n\t\t\t        parseInt(style.getPropertyValue('margin-left')) +\n\t\t\t        parseInt(style.getPropertyValue('margin-right'));\n\t\t\t}\n\t\t\texports.outerWidth = outerWidth;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 6 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tfunction outerHeight(el) {\n\t\t\t    var style = getComputedStyle(el);\n\t\t\t    return el.offsetHeight +\n\t\t\t        parseInt(style.getPropertyValue('margin-top')) +\n\t\t\t        parseInt(style.getPropertyValue('margin-bottom'));\n\t\t\t}\n\t\t\texports.outerHeight = outerHeight;\n\t\t\n\t\t\n\t\t/***/ }\n\t\t/******/ ])\n\t\t});\n\t\t;\n\t\t//# sourceMappingURL=ng2-utils.umd.js.map\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-infinite-list.umd.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(6), __webpack_require__(8));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/common\", \"rxjs/Rx\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-map\"] = factory(require(\"@angular/core\"), require(\"@angular/common\"), require(\"rxjs/Rx\"));\n\t\telse\n\t\t\troot[\"ng2-map\"] = factory(root[\"@angular/core\"], root[\"@angular/common\"], root[\"rxjs/Rx\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_6__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar common_1 = __webpack_require__(2);\n\t\tvar option_builder_1 = __webpack_require__(3);\n\t\texports.OptionBuilder = option_builder_1.OptionBuilder;\n\t\tvar geo_coder_1 = __webpack_require__(5);\n\t\texports.GeoCoder = geo_coder_1.GeoCoder;\n\t\tvar navigator_geolocation_1 = __webpack_require__(7);\n\t\texports.NavigatorGeolocation = navigator_geolocation_1.NavigatorGeolocation;\n\t\tvar ng2_map_1 = __webpack_require__(8);\n\t\texports.Ng2Map = ng2_map_1.Ng2Map;\n\t\tvar ng2_map_component_1 = __webpack_require__(9);\n\t\texports.Ng2MapComponent = ng2_map_component_1.Ng2MapComponent;\n\t\tvar marker_1 = __webpack_require__(10);\n\t\texports.Marker = marker_1.Marker;\n\t\tvar info_window_1 = __webpack_require__(11);\n\t\texports.InfoWindow = info_window_1.InfoWindow;\n\t\tvar Ng2MapModule = (function () {\n\t\t    function Ng2MapModule() {\n\t\t    }\n\t\t    Ng2MapModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [common_1.CommonModule],\n\t\t            declarations: [ng2_map_component_1.Ng2MapComponent, marker_1.Marker, info_window_1.InfoWindow],\n\t\t            providers: [geo_coder_1.GeoCoder, navigator_geolocation_1.NavigatorGeolocation, ng2_map_1.Ng2Map, option_builder_1.OptionBuilder],\n\t\t            exports: [ng2_map_component_1.Ng2MapComponent, marker_1.Marker, info_window_1.InfoWindow]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2MapModule);\n\t\t    return Ng2MapModule;\n\t\t}());\n\t\texports.Ng2MapModule = Ng2MapModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar util_1 = __webpack_require__(4);\n\t\tvar geo_coder_1 = __webpack_require__(5);\n\t\t/**\n\t\t * change any object to google object options\n\t\t * e.g. [1,2] -> new google.maps.LatLng(1,2);\n\t\t */\n\t\tvar OptionBuilder = (function () {\n\t\t    function OptionBuilder(geoCoder) {\n\t\t        this.geoCoder = geoCoder;\n\t\t    }\n\t\t    OptionBuilder.prototype.googlizeAllInputs = function (definedInputs, userInputs) {\n\t\t        var _this = this;\n\t\t        var options = {};\n\t\t        definedInputs.forEach(function (input) {\n\t\t            if (userInputs[input] !== undefined) {\n\t\t                options[input] = _this.googlize(userInputs[input], { key: input });\n\t\t            }\n\t\t        });\n\t\t        return options;\n\t\t    };\n\t\t    OptionBuilder.prototype.googlizeMultiple = function (inputs, options) {\n\t\t        options = options || {};\n\t\t        for (var key in inputs) {\n\t\t            var val = inputs[key];\n\t\t            // (non-strings are fully converted)\n\t\t            if (typeof val !== 'string') {\n\t\t                options[key] = val;\n\t\t            } // sometimes '0' needed to stay as it is\n\t\t            else if (!(options['doNotConverStringToNumber'] && val.match(/^[0-9]+$/))) {\n\t\t                options[key] = this.googlize(val, { key: key });\n\t\t            }\n\t\t        } // for(var key in attrs)\n\t\t        return options;\n\t\t    };\n\t\t    OptionBuilder.prototype.googlize = function (input, options) {\n\t\t        options = options || {};\n\t\t        var output;\n\t\t        if (input === 'false' || input === false) {\n\t\t            output = false;\n\t\t        }\n\t\t        else if (input === '0' || input === 0) {\n\t\t            output = 0;\n\t\t        }\n\t\t        else {\n\t\t            output =\n\t\t                // -> googlize -> getJsonParsed -> googlizeMultiple -> googlize until all elements are parsed\n\t\t                this.getJSONParsed(input, options)\n\t\t                    || this.getAnyMapObject(input)\n\t\t                    || this.getAnyMapConstant(input, options)\n\t\t                    || this.getDateObject(input);\n\t\t        }\n\t\t        if (output instanceof Array) {\n\t\t            if (options['key'] === \"bounds\") {\n\t\t                output = new google.maps.LatLngBounds(output[0], output[1]);\n\t\t            }\n\t\t            else if (options['key'] === \"icons\") {\n\t\t                output = this.getMapIcons(output);\n\t\t            }\n\t\t        }\n\t\t        if (options['key'] && output instanceof Object) {\n\t\t            if (options['key'] === 'icon') {\n\t\t                output = this.getMarkerIcon(output);\n\t\t            }\n\t\t            else if (options['key'].match(/ControlOptions$/)) {\n\t\t                output = this.getMapControlOption(output);\n\t\t            }\n\t\t        }\n\t\t        return output;\n\t\t    };\n\t\t    OptionBuilder.prototype.getLatLng = function (input) {\n\t\t        var output;\n\t\t        if (input[0].constructor == Array) {\n\t\t            output = input.map(function (el) { return new google.maps.LatLng(el[0], el[1]); });\n\t\t        }\n\t\t        else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {\n\t\t            output = new google.maps.LatLng(input[0], input[1]);\n\t\t        }\n\t\t        return output;\n\t\t    };\n\t\t    OptionBuilder.prototype.getJSONParsed = function (input, options) {\n\t\t        var output;\n\t\t        try {\n\t\t            output = util_1.getJSON(input);\n\t\t            if (output instanceof Array) {\n\t\t                // [{a:1}] : not lat/lng ones\n\t\t                if (output[0].constructor !== Object) {\n\t\t                    output = this.getLatLng(output);\n\t\t                }\n\t\t            }\n\t\t            else if (output === Object(output)) {\n\t\t                // check for nested hashes and convert to Google API options\n\t\t                var newOptions = options;\n\t\t                newOptions['doNotConverStringToNumber'] = true;\n\t\t                output = this.googlizeMultiple(output, newOptions);\n\t\t            }\n\t\t        }\n\t\t        catch (e) {\n\t\t        }\n\t\t        return output;\n\t\t    };\n\t\t    OptionBuilder.prototype.getAnyMapObject = function (input) {\n\t\t        var output;\n\t\t        if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n\t\t            try {\n\t\t                var exp = \"new google.maps.\" + input;\n\t\t                output = eval(exp);\n\t\t            }\n\t\t            catch (e) { }\n\t\t        }\n\t\t        return output;\n\t\t    };\n\t\t    OptionBuilder.prototype.getAnyMapConstant = function (input, options) {\n\t\t        var output;\n\t\t        if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) {\n\t\t            try {\n\t\t                var matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n\t\t                output = google.maps[matches[1]][matches[2]];\n\t\t            }\n\t\t            catch (e) { }\n\t\t        }\n\t\t        else if (input.match(/^[A-Z]+$/)) {\n\t\t            try {\n\t\t                var capitalizedKey = options['key'].charAt(0).toUpperCase() +\n\t\t                    options['key'].slice(1);\n\t\t                output = google.maps[capitalizedKey][input];\n\t\t            }\n\t\t            catch (e) { }\n\t\t        }\n\t\t        return output;\n\t\t    };\n\t\t    /**\n\t\t     * streetviewControl, panControl, etc, not a general control\n\t\t     */\n\t\t    OptionBuilder.prototype.getMapControlOption = function (controlOptions) {\n\t\t        var newControlOptions = controlOptions;\n\t\t        for (var key in newControlOptions) {\n\t\t            if (newControlOptions[key]) {\n\t\t                var value = newControlOptions[key];\n\t\t                if (typeof value === 'string') {\n\t\t                    value = value.toUpperCase();\n\t\t                }\n\t\t                else if (key === \"mapTypeIds\") {\n\t\t                    value = value.map(function (str) {\n\t\t                        if (str.match(/^[A-Z]+$/)) {\n\t\t                            return google.maps.MapTypeId[str.toUpperCase()];\n\t\t                        }\n\t\t                        else {\n\t\t                            return str;\n\t\t                        }\n\t\t                    });\n\t\t                }\n\t\t                if (key === \"style\") {\n\t\t                    var objName = key.replace(/Options$/, '') + \"Style\";\n\t\t                    newControlOptions[key] = google.maps[objName][value];\n\t\t                }\n\t\t                else if (key === \"position\") {\n\t\t                    newControlOptions[key] = google.maps.ControlPosition[value];\n\t\t                }\n\t\t                else {\n\t\t                    newControlOptions[key] = value;\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        return newControlOptions;\n\t\t    };\n\t\t    OptionBuilder.prototype.getDateObject = function (input) {\n\t\t        var output;\n\t\t        if (input.match(/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/)) {\n\t\t            try {\n\t\t                output = new Date(input);\n\t\t            }\n\t\t            catch (e) { }\n\t\t        }\n\t\t        return output;\n\t\t    };\n\t\t    OptionBuilder.prototype.getMapIcons = function (input) {\n\t\t        return input.map(function (el) {\n\t\t            if (el.icon.path.match(/^[A-Z_]+$/)) {\n\t\t                el.icon.path = google.maps.SymbolPath[el.icon.path];\n\t\t            }\n\t\t            return el;\n\t\t        });\n\t\t    };\n\t\t    OptionBuilder.prototype.getMarkerIcon = function (input) {\n\t\t        var output = input;\n\t\t        if ((\"\" + output.path).match(/^[A-Z_]+$/)) {\n\t\t            output.path = google.maps.SymbolPath[output.path];\n\t\t        }\n\t\t        for (var key in output) {\n\t\t            var arr = output[key];\n\t\t            if (key == \"anchor\" || key == \"origin\" || key == \"labelOrigin\") {\n\t\t                output[key] = new google.maps.Point(arr[0], arr[1]);\n\t\t            }\n\t\t            else if (key == \"size\" || key == \"scaledSize\") {\n\t\t                output[key] = new google.maps.Size(arr[0], arr[1]);\n\t\t            }\n\t\t        }\n\t\t        return output;\n\t\t    };\n\t\t    OptionBuilder = __decorate([\n\t\t        core_1.Injectable(), \n\t\t        __metadata('design:paramtypes', [geo_coder_1.GeoCoder])\n\t\t    ], OptionBuilder);\n\t\t    return OptionBuilder;\n\t\t}());\n\t\texports.OptionBuilder = OptionBuilder;\n\t\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports) {\n\t\n\t\t\"use strict\";\n\t\t/**\n\t\t * return json string from json-like string\n\t\t */\n\t\tvar jsonize = function (str) {\n\t\t    try {\n\t\t        JSON.parse(str);\n\t\t        return str;\n\t\t    }\n\t\t    catch (e) {\n\t\t        return str\n\t\t            .replace(/([\\$\\w]+)\\s*:/g, // wrap keys without double quote\n\t\t        function (_, $1) {\n\t\t            return '\"' + $1 + '\":';\n\t\t        })\n\t\t            .replace(/'([^']+)'/g, // replacing single quote to double quote\n\t\t        function (_, $1) {\n\t\t            return '\"' + $1 + '\"';\n\t\t        });\n\t\t    }\n\t\t};\n\t\texports.jsonize = jsonize;\n\t\t/**\n\t\t * Returns string to an object by using JSON.parse()\n\t\t */\n\t\tvar getJSON = function (input) {\n\t\t    if (typeof input === 'string') {\n\t\t        var re = /^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/; //lat,lng\n\t\t        if (input.match(re)) {\n\t\t            input = \"[\" + input + \"]\";\n\t\t        }\n\t\t        return JSON.parse(jsonize(input));\n\t\t    }\n\t\t    else {\n\t\t        return input;\n\t\t    }\n\t\t};\n\t\texports.getJSON = getJSON;\n\t\t/* tslint:enable */\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Rx_1 = __webpack_require__(6);\n\t\t/**\n\t\t *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n\t\t *   service for Google Geocoder service\n\t\t */\n\t\tvar GeoCoder = (function () {\n\t\t    function GeoCoder() {\n\t\t    }\n\t\t    GeoCoder.prototype.geocode = function (options) {\n\t\t        var geocode$ = new Rx_1.Subject();\n\t\t        var geocoder = new google.maps.Geocoder();\n\t\t        geocoder.geocode(options, function (results, status) {\n\t\t            if (status == google.maps.GeocoderStatus.OK) {\n\t\t                geocode$.next(results);\n\t\t            }\n\t\t            else {\n\t\t                geocode$.error(results);\n\t\t            }\n\t\t        });\n\t\t        return geocode$;\n\t\t    };\n\t\t    ;\n\t\t    GeoCoder = __decorate([\n\t\t        core_1.Injectable(), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], GeoCoder);\n\t\t    return GeoCoder;\n\t\t}());\n\t\texports.GeoCoder = GeoCoder;\n\t\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\t\n\t/***/ },\n\t/* 7 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Rx_1 = __webpack_require__(6);\n\t\t/**\n\t\t *  service for navigator.geolocation methods\n\t\t */\n\t\tvar NavigatorGeolocation = (function () {\n\t\t    function NavigatorGeolocation() {\n\t\t    }\n\t\t    NavigatorGeolocation.prototype.getCurrentPosition = function (geoLocationOptions) {\n\t\t        geoLocationOptions = geoLocationOptions || { timeout: 5000 };\n\t\t        var getCurrentPosition$ = new Rx_1.Subject();\n\t\t        if (navigator.geolocation) {\n\t\t            navigator.geolocation.getCurrentPosition(function (position) {\n\t\t                getCurrentPosition$.next(position);\n\t\t            }, function (evt) {\n\t\t                getCurrentPosition$.error(evt);\n\t\t            }, geoLocationOptions);\n\t\t        }\n\t\t        else {\n\t\t            getCurrentPosition$.error(\"Browser Geolocation service failed.\");\n\t\t        }\n\t\t        return getCurrentPosition$;\n\t\t    };\n\t\t    ;\n\t\t    NavigatorGeolocation = __decorate([\n\t\t        core_1.Injectable(), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], NavigatorGeolocation);\n\t\t    return NavigatorGeolocation;\n\t\t}());\n\t\texports.NavigatorGeolocation = NavigatorGeolocation;\n\t\n\t\n\t/***/ },\n\t/* 8 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Rx_1 = __webpack_require__(6);\n\t\tvar option_builder_1 = __webpack_require__(3);\n\t\tvar geo_coder_1 = __webpack_require__(5);\n\t\t/**\n\t\t * collection of map instance-related properties and methods\n\t\t */\n\t\tvar Ng2Map = (function () {\n\t\t    function Ng2Map(geoCoder, optionBuilder) {\n\t\t        this.geoCoder = geoCoder;\n\t\t        this.optionBuilder = optionBuilder;\n\t\t        this.mapReady$ = new Rx_1.Subject();\n\t\t    }\n\t\t    Ng2Map.prototype.setObjectEvents = function (definedEvents, thisObj, prefix) {\n\t\t        definedEvents.forEach(function (definedEvent) {\n\t\t            var eventName = definedEvent\n\t\t                .toLowerCase()\n\t\t                .replace(new RegExp(\"^\" + prefix), '');\n\t\t            thisObj[prefix].addListener(eventName, function (event) {\n\t\t                thisObj[definedEvent].emit(this);\n\t\t            });\n\t\t        });\n\t\t    };\n\t\t    Ng2Map.prototype.updateGoogleObject = function (object, changes) {\n\t\t        var val, currentValue, setMethodName;\n\t\t        if (object) {\n\t\t            for (var key in changes) {\n\t\t                setMethodName = \"set\" + key.replace(/^[a-z]/, function (x) { return x.toUpperCase(); });\n\t\t                currentValue = changes[key].currentValue;\n\t\t                if (['position', 'center'].indexOf(key) !== -1 && typeof currentValue === 'string') {\n\t\t                    this.geoCoder.geocode({ address: currentValue }).subscribe(function (results) {\n\t\t                        object[setMethodName](results[0].geometry.location);\n\t\t                    });\n\t\t                }\n\t\t                else {\n\t\t                    val = this.optionBuilder.googlize(currentValue);\n\t\t                    object[setMethodName](val);\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t    };\n\t\t    Ng2Map.prototype.updateProperty = function (object, key, currentValue) {\n\t\t        var val, setMethodName;\n\t\t        setMethodName = \"set\" + key.replace(/^[a-z]/, function (x) { return x.toUpperCase(); });\n\t\t        if (['position', 'center'].indexOf(key) !== -1 && typeof currentValue === 'string') {\n\t\t            this.geoCoder.geocode({ address: currentValue }).subscribe(function (results) {\n\t\t                object[setMethodName](results[0].geometry.location);\n\t\t            });\n\t\t        }\n\t\t        else {\n\t\t            val = this.optionBuilder.googlize(currentValue);\n\t\t            object[setMethodName](val);\n\t\t        }\n\t\t    };\n\t\t    Ng2Map = __decorate([\n\t\t        core_1.Injectable(), \n\t\t        __metadata('design:paramtypes', [geo_coder_1.GeoCoder, option_builder_1.OptionBuilder])\n\t\t    ], Ng2Map);\n\t\t    return Ng2Map;\n\t\t}());\n\t\texports.Ng2Map = Ng2Map;\n\t\n\t\n\t/***/ },\n\t/* 9 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar option_builder_1 = __webpack_require__(3);\n\t\tvar navigator_geolocation_1 = __webpack_require__(7);\n\t\tvar geo_coder_1 = __webpack_require__(5);\n\t\tvar ng2_map_1 = __webpack_require__(8);\n\t\tvar Rx_1 = __webpack_require__(6);\n\t\tvar INPUTS = \"\\n  backgroundColor, center, disableDefaultUI, disableDoubleClickZoom, draggable, draggableCursor,\\n  draggingCursor, heading, keyboardShortcuts, mapMaker, mapTypeControl, mapTypeId, maxZoom, minZoom,\\n  noClear, overviewMapControl, panControl, panControlOptions, rotateControl, scaleControl, scrollwheel,\\n  streetView, styles, tilt, zoom, streetViewControl, zoomControl, mapTypeControlOptions,\\n  overviewMapControlOptions, rotateControlOptions, scaleControlOptions, streetViewControlOptions,\\n  zoomControlOptions\".split(',').map(function (el) { return el.trim(); });\n\t\tvar OUTPUTS = \"\\n  bounds_changed, center_changed, click, dblclick, drag, dragend, dragstart, heading_changed, idle\\n  maptypeid_changed, mousemove, mouseout, mouseover, projection_changed, resize, rightclick, \\n  tilesloaded, tile_changed, zoom_changed\"\n\t\t    .split(',').map(function (el) { return (\"map\" + el.trim().replace(/^[a-z]/, function (x) { return x.toUpperCase(); })); });\n\t\tvar Ng2MapComponent = (function () {\n\t\t    function Ng2MapComponent(optionBuilder, elementRef, zone, geolocation, geoCoder, ng2Map) {\n\t\t        var _this = this;\n\t\t        this.optionBuilder = optionBuilder;\n\t\t        this.elementRef = elementRef;\n\t\t        this.zone = zone;\n\t\t        this.geolocation = geolocation;\n\t\t        this.geoCoder = geoCoder;\n\t\t        this.ng2Map = ng2Map;\n\t\t        this.mapOptions = {};\n\t\t        this.inputChanges$ = new Rx_1.Subject();\n\t\t        //map objects by group\n\t\t        this.infoWindows = {};\n\t\t        if (typeof google === 'undefined' || !google.maps.Map) {\n\t\t            this.mapInitPath = 1;\n\t\t            this.addGoogleMapsApi();\n\t\t        }\n\t\t        // all outputs needs to be initialized,\n\t\t        // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n\t\t        OUTPUTS.forEach(function (output) { return _this[output] = new core_1.EventEmitter(); });\n\t\t    }\n\t\t    Ng2MapComponent.prototype.ngAfterViewInit = function () {\n\t\t        if (this.mapInitPath !== 1) {\n\t\t            this.initializeMap();\n\t\t        }\n\t\t    };\n\t\t    Ng2MapComponent.prototype.ngOnChanges = function (changes) {\n\t\t        this.inputChanges$.next(changes);\n\t\t    };\n\t\t    Ng2MapComponent.prototype.addGoogleMapsApi = function () {\n\t\t        var _this = this;\n\t\t        window['ng2MapComponentRef'] = { zone: this.zone, componentFn: function () { return _this.initializeMap(); } };\n\t\t        window['initNg2Map'] = function () {\n\t\t            window['ng2MapComponentRef'].zone.run(function () { window['ng2MapComponentRef'].componentFn(); });\n\t\t        };\n\t\t        if (!window['google'] && !document.querySelector('#ng2-map-api')) {\n\t\t            var script = document.createElement('script');\n\t\t            script.id = \"ng2-map-api\";\n\t\t            // script.src = \"https://maps.google.com/maps/api/js?callback=initNg2Map\";\n\t\t            var apiUrl = Ng2MapComponent['apiUrl'] || \"https://maps.google.com/maps/api/js\";\n\t\t            apiUrl += apiUrl.indexOf('?') ? '&' : '?';\n\t\t            script.src = apiUrl + \"callback=initNg2Map\";\n\t\t            document.querySelector('body').appendChild(script);\n\t\t        }\n\t\t    };\n\t\t    Ng2MapComponent.prototype.initializeMap = function () {\n\t\t        var _this = this;\n\t\t        this.el = this.elementRef.nativeElement.querySelector('.google-map');\n\t\t        console.log('this.el...............', this.el);\n\t\t        this.mapOptions = this.optionBuilder.googlizeAllInputs(INPUTS, this);\n\t\t        console.log('this.mapOptions', this.mapOptions);\n\t\t        this.mapOptions.zoom = this.mapOptions.zoom || 15;\n\t\t        typeof this.mapOptions.center === 'string' && (delete this.mapOptions.center);\n\t\t        this.map = new google.maps.Map(this.el, this.mapOptions);\n\t\t        this.setCenter();\n\t\t        //set google events listeners and emits to this outputs listeners\n\t\t        this.ng2Map.setObjectEvents(OUTPUTS, this, 'map');\n\t\t        // broadcast map ready message\n\t\t        this.ng2Map.map = this.map;\n\t\t        this.ng2Map.mapComponent = this;\n\t\t        this.ng2Map.map['mapComponent'] = this;\n\t\t        // ........\n\t\t        console.log('map is ready.......');\n\t\t        this.ng2Map.mapReady$.next(this.map);\n\t\t        // update map when input changes\n\t\t        this.inputChanges$\n\t\t            .debounceTime(1000)\n\t\t            .subscribe(function (changes) { return _this.ng2Map.updateGoogleObject(_this.map, changes); });\n\t\t    };\n\t\t    Ng2MapComponent.prototype.setCenter = function () {\n\t\t        var _this = this;\n\t\t        if (!this['center']) {\n\t\t            this.geolocation.getCurrentPosition().subscribe(function (position) {\n\t\t                console.log('setting map center from current location');\n\t\t                var latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n\t\t                _this.map.setCenter(latLng);\n\t\t            });\n\t\t        }\n\t\t        else if (typeof this['center'] === 'string') {\n\t\t            this.geoCoder.geocode({ address: this['center'] }).subscribe(function (results) {\n\t\t                console.log('setting map center from address', _this['center']);\n\t\t                _this.map.setCenter(results[0].geometry.location);\n\t\t            });\n\t\t        }\n\t\t    };\n\t\t    Ng2MapComponent.prototype.openInfoWindow = function (id, anchor, data) {\n\t\t        this.infoWindows[id].open(anchor, data);\n\t\t    };\n\t\t    Ng2MapComponent.prototype.ngOnDestroy = function () {\n\t\t        var _this = this;\n\t\t        OUTPUTS.forEach(function (output) { return google.maps.event.clearListeners(_this.map, output); });\n\t\t    };\n\t\t    Ng2MapComponent = __decorate([\n\t\t        core_1.Component({\n\t\t            selector: 'ng2-map, jui-map',\n\t\t            providers: [ng2_map_1.Ng2Map, option_builder_1.OptionBuilder, geo_coder_1.GeoCoder, navigator_geolocation_1.NavigatorGeolocation],\n\t\t            styles: [\"\\n    ng2-map {display: block; height: 300px;}\\n    .google-map {width: 100%; height: 100%}\\n  \"],\n\t\t            inputs: INPUTS,\n\t\t            outputs: OUTPUTS,\n\t\t            encapsulation: core_1.ViewEncapsulation.None,\n\t\t            template: \"\\n    <div class=\\\"google-map\\\"></div>\\n    <ng-content></ng-content>\\n  \"\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [option_builder_1.OptionBuilder, core_1.ElementRef, core_1.NgZone, navigator_geolocation_1.NavigatorGeolocation, geo_coder_1.GeoCoder, ng2_map_1.Ng2Map])\n\t\t    ], Ng2MapComponent);\n\t\t    return Ng2MapComponent;\n\t\t}());\n\t\texports.Ng2MapComponent = Ng2MapComponent;\n\t\n\t\n\t/***/ },\n\t/* 10 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar option_builder_1 = __webpack_require__(3);\n\t\tvar navigator_geolocation_1 = __webpack_require__(7);\n\t\tvar geo_coder_1 = __webpack_require__(5);\n\t\tvar ng2_map_1 = __webpack_require__(8);\n\t\tvar Rx_1 = __webpack_require__(6);\n\t\tvar INPUTS = \"\\n  anchorPoint, animation, clickable, cursor, draggable, icon, label, opacity\\n  ,optimized,place, position, shape, title, visible, zIndex\".split(',').map(function (el) { return el.trim(); });\n\t\tvar OUTPUTS = \"\\n  animation_changed, click, clickable_changed, cursor_changed, dblclick, drag, dragend, draggable_changed,\\n  dragstart, flat_changed, icon_changed, mousedown, mouseout, mouseover, mouseup, position_changed, rightclick,\\n  shape_changed, title_changed, visible_changed, zindex_changed\\n  \".split(',').map(function (el) { return (\"marker\" + el.trim().replace(/^[a-z]/, function (x) { return x.toUpperCase(); })); });\n\t\tvar Marker = (function () {\n\t\t    function Marker(ng2Map, optionBuilder, geolocation, geoCoder) {\n\t\t        var _this = this;\n\t\t        this.ng2Map = ng2Map;\n\t\t        this.optionBuilder = optionBuilder;\n\t\t        this.geolocation = geolocation;\n\t\t        this.geoCoder = geoCoder;\n\t\t        this.options = {};\n\t\t        this.inputChanges$ = new Rx_1.Subject();\n\t\t        if (this.ng2Map.map) {\n\t\t            this.initialize(this.ng2Map.map);\n\t\t        }\n\t\t        else {\n\t\t            this.ng2Map.mapReady$.subscribe(function (map) { return _this.initialize(map); });\n\t\t        }\n\t\t        // all outputs needs to be initialized,\n\t\t        // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n\t\t        OUTPUTS.forEach(function (output) { return _this[output] = new core_1.EventEmitter(); });\n\t\t    }\n\t\t    Marker.prototype.ngOnChanges = function (changes) {\n\t\t        this.inputChanges$.next(changes);\n\t\t    };\n\t\t    // called when map is ready\n\t\t    Marker.prototype.initialize = function (map) {\n\t\t        var _this = this;\n\t\t        console.log('marker is being initialized');\n\t\t        this.options = this.optionBuilder.googlizeAllInputs(INPUTS, this);\n\t\t        console.log('MARKER options', this.options);\n\t\t        this.options.map = map;\n\t\t        // will be set after geocoded\n\t\t        typeof this.options.position === 'string' && (delete this.options.position);\n\t\t        this.marker = new google.maps.Marker(this.options);\n\t\t        this.setPosition();\n\t\t        //set google events listeners and emits to this outputs listeners\n\t\t        this.ng2Map.setObjectEvents(OUTPUTS, this, 'marker');\n\t\t        // update marker when input changes\n\t\t        this.inputChanges$\n\t\t            .subscribe(function (changes) {\n\t\t            console.log('marker options are changed', changes);\n\t\t            _this.ng2Map.updateGoogleObject(_this.marker, changes);\n\t\t        });\n\t\t    };\n\t\t    Marker.prototype.setPosition = function () {\n\t\t        var _this = this;\n\t\t        setTimeout(function () {\n\t\t            if (!_this['position']) {\n\t\t                _this.geolocation.getCurrentPosition().subscribe(function (position) {\n\t\t                    console.log('setting marker position from current location');\n\t\t                    var latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n\t\t                    _this.marker.setPosition(latLng);\n\t\t                });\n\t\t            }\n\t\t            else if (typeof _this['position'] === 'string') {\n\t\t                _this.geoCoder.geocode({ address: _this['position'] }).subscribe(function (results) {\n\t\t                    console.log('setting marker position from address', _this['position']);\n\t\t                    _this.marker.setPosition(results[0].geometry.location);\n\t\t                });\n\t\t            }\n\t\t        }, 500);\n\t\t    };\n\t\t    Marker.prototype.ngOnDestroy = function () {\n\t\t        var _this = this;\n\t\t        OUTPUTS.forEach(function (output) { return google.maps.event.clearListeners(_this.marker, output); });\n\t\t        delete this.marker.setMap(null);\n\t\t        delete this.marker;\n\t\t    };\n\t\t    Marker = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: 'marker',\n\t\t            inputs: INPUTS,\n\t\t            outputs: OUTPUTS\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [ng2_map_1.Ng2Map, option_builder_1.OptionBuilder, navigator_geolocation_1.NavigatorGeolocation, geo_coder_1.GeoCoder])\n\t\t    ], Marker);\n\t\t    return Marker;\n\t\t}());\n\t\texports.Marker = Marker;\n\t\n\t\n\t/***/ },\n\t/* 11 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar option_builder_1 = __webpack_require__(3);\n\t\tvar ng2_map_1 = __webpack_require__(8);\n\t\tvar Rx_1 = __webpack_require__(6);\n\t\tvar INPUTS = \"\\n  content, disableAutoPan, maxWidth, pixelOffset, position, zIndex\\n  \".split(',').map(function (el) { return el.trim(); });\n\t\tvar OUTPUTS = \"\\n  closeclick, content_changed, domready, position_changed, zindex_changed\\n  \".split(',').map(function (el) { return (\"infoWindow\" + el.trim().replace(/^[a-z]/, function (x) { return x.toUpperCase(); })); });\n\t\tvar InfoWindow = (function () {\n\t\t    function InfoWindow(optionBuilder, elementRef, ng2Map) {\n\t\t        var _this = this;\n\t\t        this.optionBuilder = optionBuilder;\n\t\t        this.elementRef = elementRef;\n\t\t        this.ng2Map = ng2Map;\n\t\t        this.options = {};\n\t\t        this.inputChanges$ = new Rx_1.Subject();\n\t\t        this.elementRef.nativeElement.style.display = 'none';\n\t\t        if (this.ng2Map.map) {\n\t\t            this.initialize(this.ng2Map.map);\n\t\t        }\n\t\t        else {\n\t\t            this.ng2Map.mapReady$.subscribe(function (map) { return _this.initialize(map); });\n\t\t        }\n\t\t        // all outputs needs to be initialized,\n\t\t        // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n\t\t        OUTPUTS.forEach(function (output) { return _this[output] = new core_1.EventEmitter(); });\n\t\t    }\n\t\t    InfoWindow.prototype.ngOnChanges = function (changes) {\n\t\t        this.inputChanges$.next(changes);\n\t\t    };\n\t\t    // called when map is ready\n\t\t    InfoWindow.prototype.initialize = function (map) {\n\t\t        var _this = this;\n\t\t        console.log('infowindow is being initialized');\n\t\t        this.template = this.elementRef.nativeElement.innerHTML;\n\t\t        this.options = this.optionBuilder.googlizeAllInputs(INPUTS, this);\n\t\t        this.infoWindow = new google.maps.InfoWindow(this.options);\n\t\t        console.log('INFOWINDOW options', this.options);\n\t\t        //register infoWindow ids to Ng2Map, so that it can be opened by id\n\t\t        this.el = this.elementRef.nativeElement;\n\t\t        if (this.el.id) {\n\t\t            this.ng2Map.mapComponent.infoWindows[this.el.id] = this;\n\t\t        }\n\t\t        else {\n\t\t            console.error('An InfoWindow must have an id. e.g. id=\"detail\"');\n\t\t        }\n\t\t        //set google events listeners and emits to this outputs listeners\n\t\t        this.ng2Map.setObjectEvents(OUTPUTS, this, 'infoWindow');\n\t\t        // update object when input changes\n\t\t        this.inputChanges$\n\t\t            .debounceTime(1000)\n\t\t            .subscribe(function (changes) { return _this.ng2Map.updateGoogleObject(_this.infoWindow, changes); });\n\t\t    };\n\t\t    InfoWindow.prototype.open = function (anchor, data) {\n\t\t        var html = this.template;\n\t\t        for (var key in data) {\n\t\t            this[key] = data[key];\n\t\t            html = html.replace(\"[[\" + key + \"]]\", data[key]);\n\t\t        }\n\t\t        //set content and open it\n\t\t        this.infoWindow.setContent(html);\n\t\t        this.infoWindow.open(this.ng2Map.map, anchor);\n\t\t    };\n\t\t    InfoWindow.prototype.ngOnDestroy = function () {\n\t\t        var _this = this;\n\t\t        OUTPUTS.forEach(function (output) { return google.maps.event.clearListeners(_this.infoWindow, output); });\n\t\t        delete this.infoWindow;\n\t\t    };\n\t\t    InfoWindow = __decorate([\n\t\t        core_1.Component({\n\t\t            selector: 'info-window',\n\t\t            inputs: INPUTS,\n\t\t            outputs: OUTPUTS,\n\t\t            template: \"<ng-content></ng-content>\"\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [option_builder_1.OptionBuilder, core_1.ElementRef, ng2_map_1.Ng2Map])\n\t\t    ], InfoWindow);\n\t\t    return InfoWindow;\n\t\t}());\n\t\texports.InfoWindow = InfoWindow;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-map.umd.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-menu\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-menu\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_menu_directive_1 = __webpack_require__(4);\n\t\texports.Ng2MenuDirective = ng2_menu_directive_1.Ng2MenuDirective;\n\t\tvar Ng2MenuModule = (function () {\n\t\t    function Ng2MenuModule() {\n\t\t    }\n\t\t    Ng2MenuModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [ng2_menu_directive_1.Ng2MenuDirective],\n\t\t            exports: [ng2_menu_directive_1.Ng2MenuDirective]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2MenuModule);\n\t\t    return Ng2MenuModule;\n\t\t}());\n\t\texports.Ng2MenuModule = Ng2MenuModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Ng2MenuDirective = (function () {\n\t\t    function Ng2MenuDirective(viewContainerRef) {\n\t\t        this.viewContainerRef = viewContainerRef;\n\t\t        this.el = this.viewContainerRef.element.nativeElement;\n\t\t        this.el.parentElement.style.position = 'relative';\n\t\t        this.el.parentElement.className += ' has-ng2-menu';\n\t\t    }\n\t\t    Ng2MenuDirective.prototype.ngAfterViewInit = function () {\n\t\t        var _this = this;\n\t\t        this.el.parentElement.addEventListener('mouseover', function (event) {\n\t\t            _this.el.parentElement.className += \" active\";\n\t\t            _this.el.style.position = \"absolute\";\n\t\t            if (_this.el.parentElement.offsetWidth) {\n\t\t                _this.setPosition();\n\t\t            }\n\t\t            else {\n\t\t                setTimeout(function () { return _this.setPosition(); });\n\t\t            }\n\t\t        });\n\t\t        this.el.parentElement.addEventListener('mouseout', function (event) {\n\t\t            _this.el.parentElement.className = _this.el.parentElement.className.replace(/\\s?active/, '');\n\t\t        });\n\t\t    };\n\t\t    Ng2MenuDirective.prototype.setPosition = function () {\n\t\t        if (this.position === \"bottom\") {\n\t\t            this.el.style.left = \"0\";\n\t\t            this.el.style.top = this.el.parentElement.offsetHeight - 1 + 'px';\n\t\t        }\n\t\t        else if (this.position === \"top\") {\n\t\t            this.el.style.left = \"0\";\n\t\t            this.el.style.bottom = this.el.parentElement.offsetHeight - 1 + 'px';\n\t\t        }\n\t\t        else if (this.position === \"right\") {\n\t\t            this.el.style.left = this.el.parentElement.offsetWidth - 1 + 'px';\n\t\t            this.el.style.top = \"0\";\n\t\t        }\n\t\t        else if (this.position === \"left\") {\n\t\t            this.el.style.right = this.el.parentElement.offsetWidth - 1 + 'px';\n\t\t            this.el.style.top = \"0\";\n\t\t        }\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input('ng2-menu'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2MenuDirective.prototype, \"position\", void 0);\n\t\t    Ng2MenuDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: '[ng2-menu]'\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef])\n\t\t    ], Ng2MenuDirective);\n\t\t    return Ng2MenuDirective;\n\t\t}());\n\t\texports.Ng2MenuDirective = Ng2MenuDirective;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-menu.umd.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-parallax-scroll\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-parallax-scroll\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_parallax_scroll_directive_1 = __webpack_require__(4);\n\t\texports.Ng2ParallaxScrollDirective = ng2_parallax_scroll_directive_1.Ng2ParallaxScrollDirective;\n\t\tvar Ng2ParallaxScrollModule = (function () {\n\t\t    function Ng2ParallaxScrollModule() {\n\t\t    }\n\t\t    Ng2ParallaxScrollModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [ng2_parallax_scroll_directive_1.Ng2ParallaxScrollDirective],\n\t\t            exports: [ng2_parallax_scroll_directive_1.Ng2ParallaxScrollDirective]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2ParallaxScrollModule);\n\t\t    return Ng2ParallaxScrollModule;\n\t\t}());\n\t\texports.Ng2ParallaxScrollModule = Ng2ParallaxScrollModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Ng2ParallaxScrollDirective = (function () {\n\t\t    function Ng2ParallaxScrollDirective(viewContainer) {\n\t\t        this.viewContainer = viewContainer;\n\t\t        this.el = this.viewContainer.element.nativeElement;\n\t\t    }\n\t\t    Ng2ParallaxScrollDirective.prototype.ngAfterViewInit = function () {\n\t\t        var _this = this;\n\t\t        this.img = this.el.querySelector(\"img\");\n\t\t        this.img.onload = function () {\n\t\t            _this.imgOrgWidth = _this.imgOrgWidth || _this.img.offsetWidth;\n\t\t            _this.imgOrgHeight = _this.imgOrgHeight || _this.img.offsetHeight;\n\t\t            console.log(_this.img.offsetWidth, _this.img.offsetHeight, _this.img.width, _this.img.height);\n\t\t            _this.setParallaxImage();\n\t\t            _this.updateParallaxImage();\n\t\t            window.addEventListener('scroll', function () {\n\t\t                _this.updateParallaxImage();\n\t\t            });\n\t\t            window.addEventListener('resize', function () {\n\t\t                _this.setParallaxImage();\n\t\t                _this.updateParallaxImage();\n\t\t            });\n\t\t        };\n\t\t    };\n\t\t    Ng2ParallaxScrollDirective.prototype.setParallaxImage = function () {\n\t\t        //set img style\n\t\t        var imgSize = this.imgOrgWidth > this.el.offsetWidth ?\n\t\t            { width: this.el.offsetWidth + 'px' } : { height: this.el.offsetHeight * 1.5 + 'px' };\n\t\t        Object.assign(this.img.style, {\n\t\t            display: 'block', position: 'absolute', bottom: 0, left: 0\n\t\t        }, imgSize);\n\t\t        // set container style\n\t\t        Object.assign(this.el.style, {\n\t\t            position: 'relative', overflow: 'hidden'\n\t\t        });\n\t\t        // wrap image with a div, then set style\n\t\t        var imgWrapperEl = this.el.querySelector('.parallax-img-wrapper');\n\t\t        if (!imgWrapperEl) {\n\t\t            imgWrapperEl = document.createElement('div');\n\t\t            imgWrapperEl.className = 'parallax-img-wrapper';\n\t\t            imgWrapperEl.appendChild(this.img);\n\t\t            this.el.appendChild(imgWrapperEl);\n\t\t        }\n\t\t        Object.assign(imgWrapperEl.style, {\n\t\t            position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, zIndex: -1\n\t\t        });\n\t\t    };\n\t\t    Ng2ParallaxScrollDirective.prototype.updateParallaxImage = function () {\n\t\t        var elRect = this.el.getBoundingClientRect();\n\t\t        var imgRect = this.img.getBoundingClientRect();\n\t\t        var imgDist = imgRect.height - elRect.height;\n\t\t        var bottom = this.el.offsetTop + elRect.height;\n\t\t        var top = this.el.offsetTop;\n\t\t        var scrollTop = document.body.scrollTop;\n\t\t        var windowBottom = scrollTop + window.innerHeight;\n\t\t        var percentScrolled = (windowBottom - top) / (elRect.height + window.innerHeight);\n\t\t        //console.log(imgDist, percentScrolled, imgDist * percentScrolled);\n\t\t        var parallax = Math.round((imgDist * percentScrolled));\n\t\t        if ((bottom > scrollTop) && (top < (scrollTop + window.innerHeight))) {\n\t\t            this.img.style.bottom = parallax * -1 + 'px';\n\t\t        }\n\t\t    };\n\t\t    Ng2ParallaxScrollDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: '[ng2-parallax], ng2-parallax'\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef])\n\t\t    ], Ng2ParallaxScrollDirective);\n\t\t    return Ng2ParallaxScrollDirective;\n\t\t}());\n\t\texports.Ng2ParallaxScrollDirective = Ng2ParallaxScrollDirective;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-parallax-scroll.umd.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-popup\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-popup\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_overlay_1 = __webpack_require__(4);\n\t\tvar ng2_popup_component_1 = __webpack_require__(5);\n\t\texports.Ng2PopupComponent = ng2_popup_component_1.Ng2PopupComponent;\n\t\tvar ng2_message_popup_component_1 = __webpack_require__(6);\n\t\texports.Ng2MessagePopupComponent = ng2_message_popup_component_1.Ng2MessagePopupComponent;\n\t\tvar Ng2PopupModule = (function () {\n\t\t    function Ng2PopupModule() {\n\t\t    }\n\t\t    Ng2PopupModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule, ng2_overlay_1.Ng2OverlayModule],\n\t\t            declarations: [ng2_message_popup_component_1.Ng2MessagePopupComponent, ng2_popup_component_1.Ng2PopupComponent],\n\t\t            exports: [ng2_message_popup_component_1.Ng2MessagePopupComponent, ng2_popup_component_1.Ng2PopupComponent],\n\t\t            entryComponents: [ng2_message_popup_component_1.Ng2MessagePopupComponent]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2PopupModule);\n\t\t    return Ng2PopupModule;\n\t\t}());\n\t\texports.Ng2PopupModule = Ng2PopupModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\t\tif(true)\n\t\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\t\telse if(typeof define === 'function' && define.amd)\n\t\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\t\telse if(typeof exports === 'object')\n\t\t\t\texports[\"ng2-overlay\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\t\telse\n\t\t\t\troot[\"ng2-overlay\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\t\treturn /******/ (function(modules) { // webpackBootstrap\n\t\t/******/ \t// The module cache\n\t\t/******/ \tvar installedModules = {};\n\t\t/******/\n\t\t/******/ \t// The require function\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\t/******/\n\t\t/******/ \t\t// Check if module is in cache\n\t\t/******/ \t\tif(installedModules[moduleId])\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\t/******/\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t\t/******/ \t\t\texports: {},\n\t\t/******/ \t\t\tid: moduleId,\n\t\t/******/ \t\t\tloaded: false\n\t\t/******/ \t\t};\n\t\t/******/\n\t\t/******/ \t\t// Execute the module function\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t/******/\n\t\t/******/ \t\t// Flag the module as loaded\n\t\t/******/ \t\tmodule.loaded = true;\n\t\t/******/\n\t\t/******/ \t\t// Return the exports of the module\n\t\t/******/ \t\treturn module.exports;\n\t\t/******/ \t}\n\t\t/******/\n\t\t/******/\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\n\t\t/******/ \t__webpack_require__.m = modules;\n\t\t/******/\n\t\t/******/ \t// expose the module cache\n\t\t/******/ \t__webpack_require__.c = installedModules;\n\t\t/******/\n\t\t/******/ \t// __webpack_public_path__\n\t\t/******/ \t__webpack_require__.p = \"\";\n\t\t/******/\n\t\t/******/ \t// Load entry module and return exports\n\t\t/******/ \treturn __webpack_require__(0);\n\t\t/******/ })\n\t\t/************************************************************************/\n\t\t/******/ ([\n\t\t/* 0 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar forms_1 = __webpack_require__(2);\n\t\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\t\tvar overlay_1 = __webpack_require__(4);\n\t\t\texports.Overlay = overlay_1.Overlay;\n\t\t\tvar overlay_manager_1 = __webpack_require__(6);\n\t\t\texports.OverlayManager = overlay_manager_1.OverlayManager;\n\t\t\tvar overlay_directive_1 = __webpack_require__(7);\n\t\t\texports.OverlayDirective = overlay_directive_1.OverlayDirective;\n\t\t\tvar Ng2OverlayModule = (function () {\n\t\t\t    function Ng2OverlayModule() {\n\t\t\t    }\n\t\t\t    Ng2OverlayModule = __decorate([\n\t\t\t        core_1.NgModule({\n\t\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t\t            declarations: [overlay_directive_1.OverlayDirective],\n\t\t\t            providers: [overlay_manager_1.OverlayManager],\n\t\t\t            exports: [overlay_directive_1.OverlayDirective]\n\t\t\t        }), \n\t\t\t        __metadata('design:paramtypes', [])\n\t\t\t    ], Ng2OverlayModule);\n\t\t\t    return Ng2OverlayModule;\n\t\t\t}());\n\t\t\texports.Ng2OverlayModule = Ng2OverlayModule;\n\t\t\t;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 1 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\t\n\t\t/***/ },\n\t\t/* 2 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\t\n\t\t/***/ },\n\t\t/* 3 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\t\n\t\t/***/ },\n\t\t/* 4 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar util_1 = __webpack_require__(5);\n\t\t\tvar Overlay = (function () {\n\t\t\t    function Overlay(el, options) {\n\t\t\t        options = options || {};\n\t\t\t        this.id = options.id;\n\t\t\t        this.type = options.type;\n\t\t\t        if (!this.id) {\n\t\t\t            throw \"Invalid overlay id\";\n\t\t\t        }\n\t\t\t        this.element = el; // overlay wrapper element with table dsplay\n\t\t\t        this.windowOverlay = options.windowOverlay;\n\t\t\t        this.position = this.getPositionProperty(options.position || 'center center');\n\t\t\t    }\n\t\t\t    Overlay.prototype.positionIt = function (event) {\n\t\t\t        if (this.position.inside) {\n\t\t\t            this.positionItInside(this.position);\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            this.positionItOutside(this.position, event);\n\t\t\t        }\n\t\t\t    };\n\t\t\t    Overlay.prototype.getPositionProperty = function (positionStr) {\n\t\t\t        var position = {}, inside;\n\t\t\t        var _a = positionStr.split(' '), vertical = _a[0], horizontal = _a[1], insideStr = _a[2];\n\t\t\t        horizontal = horizontal || 'center';\n\t\t\t        vertical = vertical || 'center';\n\t\t\t        inside = (insideStr !== 'outside' || this.windowOverlay);\n\t\t\t        position.horizontal = Overlay[horizontal.toUpperCase()];\n\t\t\t        position.vertical = Overlay[vertical.toUpperCase()];\n\t\t\t        position.inside = inside;\n\t\t\t        return position;\n\t\t\t    };\n\t\t\t    Overlay.prototype.positionItInside = function (position) {\n\t\t\t        this.element.style.display = 'flex';\n\t\t\t        //top / left positioning\n\t\t\t        if (this.windowOverlay) {\n\t\t\t            this.element.style.position = 'fixed';\n\t\t\t            //works as blocker\n\t\t\t            Object.assign(this.element.style, {\n\t\t\t                backgroundColor: 'rgba(0,0,0,0.2)',\n\t\t\t                top: '0', left: '0', bottom: '0', right: '0',\n\t\t\t                width: '100%', height: '100%'\n\t\t\t            });\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            //adjust top/left to match to parentElement\n\t\t\t            var parentEl = this.element.parentElement;\n\t\t\t            //works as a blocker\n\t\t\t            Object.assign(this.element.style, {\n\t\t\t                position: 'absolute',\n\t\t\t                // backgroundColor: 'transparent',\n\t\t\t                backgroundColor: 'rgba(0,0,0,0.2)',\n\t\t\t                top: parentEl.offsetTop + 'px',\n\t\t\t                left: parentEl.offsetLeft + 'px',\n\t\t\t                width: parentEl.offsetWidth + 'px',\n\t\t\t                height: parentEl.offsetHeight + 'px'\n\t\t\t            });\n\t\t\t        }\n\t\t\t        ;\n\t\t\t        //horizontal position\n\t\t\t        switch (position.horizontal) {\n\t\t\t            case Overlay.LEFT:\n\t\t\t                this.element.style.justifyContent = 'flex-start';\n\t\t\t                break;\n\t\t\t            case Overlay.CENTER:\n\t\t\t                this.element.style.justifyContent = 'center';\n\t\t\t                break;\n\t\t\t            case Overlay.RIGHT:\n\t\t\t                this.element.style.justifyContent = 'flex-end';\n\t\t\t                break;\n\t\t\t        }\n\t\t\t        //vertical position\n\t\t\t        switch (position.vertical) {\n\t\t\t            case Overlay.LEFT:\n\t\t\t                this.element.style.alignItems = 'flex-start';\n\t\t\t                break;\n\t\t\t            case Overlay.CENTER:\n\t\t\t            case Overlay.MIDDLE:\n\t\t\t                this.element.style.alignItems = 'center';\n\t\t\t                break;\n\t\t\t            case Overlay.RIGHT:\n\t\t\t                this.element.style.alignItems = 'flex-end';\n\t\t\t                break;\n\t\t\t        }\n\t\t\t    };\n\t\t\t    Overlay.prototype.positionItOutside = function (position, event) {\n\t\t\t        //adjust top/left to match to parentElement\n\t\t\t        var parentEl = this.element.parentElement;\n\t\t\t        //works as guide line?\n\t\t\t        Object.assign(this.element.style, {\n\t\t\t            position: 'absolute',\n\t\t\t            pointerEvents: 'none',\n\t\t\t            top: parentEl.offsetTop + 'px',\n\t\t\t            left: parentEl.offsetLeft + 'px',\n\t\t\t            width: parentEl.offsetWidth + 'px',\n\t\t\t            height: parentEl.offsetHeight + 'px'\n\t\t\t        });\n\t\t\t        this.element.style.display = 'block';\n\t\t\t        var elToPosition = (this.element.children[0]);\n\t\t\t        elToPosition.style.position = 'absolute';\n\t\t\t        elToPosition.style.pointerEvents = 'auto';\n\t\t\t        switch (position.vertical) {\n\t\t\t            case Overlay.TOP:\n\t\t\t                elToPosition.style.bottom = this.element.offsetHeight + 'px';\n\t\t\t                break;\n\t\t\t            case Overlay.BOTTOM:\n\t\t\t                elToPosition.style.top = this.element.offsetHeight + 'px';\n\t\t\t                break;\n\t\t\t            case Overlay.LEFT:\n\t\t\t                elToPosition.style.right = this.element.offsetWidth + 'px';\n\t\t\t                break;\n\t\t\t            case Overlay.RIGHT:\n\t\t\t                elToPosition.style.left = this.element.offsetWidth + 'px';\n\t\t\t                break;\n\t\t\t        }\n\t\t\t        switch (position.horizontal) {\n\t\t\t            case Overlay.CENTER:\n\t\t\t                elToPosition.style.left = (this.element.offsetWidth - elToPosition.offsetWidth) / 2 + 'px';\n\t\t\t                break;\n\t\t\t            case Overlay.LEFT:\n\t\t\t                elToPosition.style.left = '0';\n\t\t\t                break;\n\t\t\t            case Overlay.RIGHT:\n\t\t\t                elToPosition.style.right = '0';\n\t\t\t                break;\n\t\t\t            case Overlay.TOP:\n\t\t\t                elToPosition.style.top = '0';\n\t\t\t                break;\n\t\t\t            case Overlay.BOTTOM:\n\t\t\t                elToPosition.style.bottom = '0';\n\t\t\t                break;\n\t\t\t            case Overlay.CURSOR:\n\t\t\t                var mousePos = util_1.Util.getMousePositionInElement(event, this.element);\n\t\t\t                if ((mousePos.x + elToPosition.offsetWidth) > this.element.offsetWidth) {\n\t\t\t                    elToPosition.style.left = (this.element.offsetWidth - elToPosition.offsetWidth - 5) + 'px';\n\t\t\t                }\n\t\t\t                else if (mousePos.x < elToPosition.offsetWidth / 2) {\n\t\t\t                    elToPosition.style.left = '0px';\n\t\t\t                }\n\t\t\t                else {\n\t\t\t                    elToPosition.style.left = mousePos.x - elToPosition.offsetWidth / 2 + 'px';\n\t\t\t                }\n\t\t\t                break;\n\t\t\t        }\n\t\t\t    };\n\t\t\t    Overlay.TOP = 11;\n\t\t\t    Overlay.MIDDLE = 12;\n\t\t\t    Overlay.BOTTOM = 13;\n\t\t\t    Overlay.LEFT = 21;\n\t\t\t    Overlay.CENTER = 22;\n\t\t\t    Overlay.RIGHT = 23;\n\t\t\t    Overlay.CURSOR = 31;\n\t\t\t    return Overlay;\n\t\t\t}());\n\t\t\texports.Overlay = Overlay;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 5 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar Util = (function () {\n\t\t\t    function Util() {\n\t\t\t    }\n\t\t\t    Util.getDocumentPosition = function (oElement) {\n\t\t\t        var posX = 0, posY = 0;\n\t\t\t        if (oElement.offsetParent) {\n\t\t\t            for (; oElement; oElement = oElement.offsetParent) {\n\t\t\t                posX += oElement.offsetLeft;\n\t\t\t                posY += oElement.offsetTop;\n\t\t\t            }\n\t\t\t            return { x: posX, y: posY };\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            return { x: oElement['x'], y: oElement['y'] };\n\t\t\t        }\n\t\t\t    };\n\t\t\t    Util.getMousePositionInElement = function (evt, element) {\n\t\t\t        evt = evt || window.event;\n\t\t\t        var posX = 0, posY = 0;\n\t\t\t        var elPos = this.getDocumentPosition(element);\n\t\t\t        if (evt.pageX || evt.pageY) {\n\t\t\t            posX = evt.pageX;\n\t\t\t            posY = evt.pageY;\n\t\t\t        }\n\t\t\t        else if (evt.clientX || evt.clientY) {\n\t\t\t            posX = evt.clientX +\n\t\t\t                document.body.scrollLeft +\n\t\t\t                document.documentElement.scrollLeft;\n\t\t\t            posY = evt.clientY +\n\t\t\t                document.body.scrollTop +\n\t\t\t                document.documentElement.scrollTop;\n\t\t\t        }\n\t\t\t        return {\n\t\t\t            x: posX - elPos.x,\n\t\t\t            y: posY - elPos.y\n\t\t\t        };\n\t\t\t    };\n\t\t\t    return Util;\n\t\t\t}());\n\t\t\texports.Util = Util;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 6 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar OverlayManager = (function () {\n\t\t\t    function OverlayManager() {\n\t\t\t    }\n\t\t\t    OverlayManager.prototype.register = function (overlay) {\n\t\t\t        OverlayManager.overlays[overlay.id] = overlay;\n\t\t\t        // console.log('overlay.register, OverlayManager.overlays', OverlayManager.overlays);\n\t\t\t    };\n\t\t\t    OverlayManager.prototype.open = function (arg, event) {\n\t\t\t        var overlay = typeof arg === 'string' ? OverlayManager.overlays[arg] : arg;\n\t\t\t        if (!overlay.opened) {\n\t\t\t            overlay.positionIt(event);\n\t\t\t            overlay.opened = true;\n\t\t\t        }\n\t\t\t    };\n\t\t\t    OverlayManager.prototype.close = function (arg) {\n\t\t\t        var overlay = typeof arg === 'string' ? OverlayManager.overlays[arg] : arg;\n\t\t\t        overlay.element.style.display = 'none';\n\t\t\t        overlay.opened = false;\n\t\t\t    };\n\t\t\t    //list of overlay objects\n\t\t\t    OverlayManager.overlays = {};\n\t\t\t    OverlayManager = __decorate([\n\t\t\t        core_1.Injectable(), \n\t\t\t        __metadata('design:paramtypes', [])\n\t\t\t    ], OverlayManager);\n\t\t\t    return OverlayManager;\n\t\t\t}());\n\t\t\texports.OverlayManager = OverlayManager;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 7 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar overlay_manager_1 = __webpack_require__(6);\n\t\t\tvar overlay_1 = __webpack_require__(4);\n\t\t\tvar OverlayDirective = (function () {\n\t\t\t    function OverlayDirective(viewContainerRef, overlayManager) {\n\t\t\t        this.viewContainerRef = viewContainerRef;\n\t\t\t        this.overlayManager = overlayManager;\n\t\t\t        this.el = this.viewContainerRef.element.nativeElement;\n\t\t\t    }\n\t\t\t    OverlayDirective.prototype.ngAfterViewInit = function () {\n\t\t\t        this.wrapItWithOverlayTag();\n\t\t\t        this.registerToOverlayManager();\n\t\t\t    };\n\t\t\t    OverlayDirective.prototype.wrapItWithOverlayTag = function () {\n\t\t\t        //console.log('wrapped overlay directive element with <ng2-overlay>');\n\t\t\t        this.overlayEl = document.createElement('ng2-overlay');\n\t\t\t        this.overlayEl.style.display = 'none';\n\t\t\t        this.el.parentElement.insertBefore(this.overlayEl, this.el.nextSibling);\n\t\t\t        this.overlayEl.appendChild(this.el);\n\t\t\t    };\n\t\t\t    //create Overlay object,  then register this element to overlayManager\n\t\t\t    OverlayDirective.prototype.registerToOverlayManager = function () {\n\t\t\t        var positionStr = this.overlayPosition;\n\t\t\t        var overlay = new overlay_1.Overlay(this.overlayEl, {\n\t\t\t            id: this.el.id,\n\t\t\t            windowOverlay: this.overlayOf == \"window\",\n\t\t\t            position: positionStr\n\t\t\t        });\n\t\t\t        //console.log('registering overlay', overlay);\n\t\t\t        this.overlayManager.register(overlay);\n\t\t\t    };\n\t\t\t    __decorate([\n\t\t\t        core_1.Input('ng2-overlay-of'), \n\t\t\t        __metadata('design:type', String)\n\t\t\t    ], OverlayDirective.prototype, \"overlayOf\", void 0);\n\t\t\t    __decorate([\n\t\t\t        core_1.Input('ng2-overlay-position'), \n\t\t\t        __metadata('design:type', String)\n\t\t\t    ], OverlayDirective.prototype, \"overlayPosition\", void 0);\n\t\t\t    OverlayDirective = __decorate([\n\t\t\t        core_1.Directive({\n\t\t\t            selector: '[ng2-overlay], [ng2-overlay-of], [ng2-overlay-position]',\n\t\t\t        }), \n\t\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef, overlay_manager_1.OverlayManager])\n\t\t\t    ], OverlayDirective);\n\t\t\t    return OverlayDirective;\n\t\t\t}());\n\t\t\texports.OverlayDirective = OverlayDirective;\n\t\t\n\t\t\n\t\t/***/ }\n\t\t/******/ ])\n\t\t});\n\t\t;\n\t\t//# sourceMappingURL=ng2-overlay.umd.js.map\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar ng2_overlay_1 = __webpack_require__(4);\n\t\tvar Ng2PopupComponent = (function () {\n\t\t    function Ng2PopupComponent(componentResolver, overlayManager) {\n\t\t        this.componentResolver = componentResolver;\n\t\t        this.overlayManager = overlayManager;\n\t\t    }\n\t\t    Ng2PopupComponent.prototype.ngAfterViewInit = function () {\n\t\t        var overlayEl = this.marker.element.nativeElement.parentElement.parentElement;\n\t\t        var overlay = new ng2_overlay_1.Overlay(overlayEl, {\n\t\t            id: 'ng2-popup-overlay',\n\t\t            windowOverlay: true,\n\t\t            position: 'center center'\n\t\t        });\n\t\t        this.overlayManager.register(overlay);\n\t\t    };\n\t\t    Ng2PopupComponent.prototype.open = function (component, options) {\n\t\t        this.close();\n\t\t        this.opened = true;\n\t\t        this.classNames = options.classNames;\n\t\t        this.closeButton = options.closeButton;\n\t\t        var factory = this.componentResolver.resolveComponentFactory(component);\n\t\t        var componentRef = this.marker.createComponent(factory);\n\t\t        componentRef.instance.popupOptions = options;\n\t\t        componentRef.instance.popup = this;\n\t\t        this.overlayManager.open('ng2-popup-overlay', null); //(id, event)\n\t\t    };\n\t\t    Ng2PopupComponent.prototype.close = function () {\n\t\t        this.opened = false;\n\t\t        this.overlayManager.close('ng2-popup-overlay');\n\t\t        try {\n\t\t            this.marker.remove();\n\t\t        }\n\t\t        catch (e) { }\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.ViewChild('marker', { read: core_1.ViewContainerRef }), \n\t\t        __metadata('design:type', Object)\n\t\t    ], Ng2PopupComponent.prototype, \"marker\", void 0);\n\t\t    Ng2PopupComponent = __decorate([\n\t\t        core_1.Component({\n\t\t            selector: 'ng2-popup',\n\t\t            directives: [ng2_overlay_1.OverlayDirective],\n\t\t            providers: [ng2_overlay_1.OverlayManager],\n\t\t            template: \"\\n    <div id=\\\"ng2-popup-overlay\\\"> <!-- <-- this is overlay -->\\n      <div class=\\\"popup-container {{classNames}}\\\" [ngClass]=\\\"{opened: opened}\\\">\\n        <div *ngIf=\\\"closeButton != false\\\" class=\\\"close-popup\\\" (click)=\\\"close()\\\">x</div>\\n        <div class=\\\"marker\\\" #marker></div> <!-- to position popup component -->\\n        <!-- popup component will be here -->\\n      </div>\\n    </div>\\n  \",\n\t\t            styles: [\"\\n    .popup-container { \\n      background: #fff;\\n      border: 1px solid #ccc;\\n      box-shadow: 0 5px 15px rgba(0,0,0,.5);\\n      border-radius: 5px;\\n      width: 600px;\\n      display: none;\\n    }\\n    .popup-container.opened { \\n      display: block;\\n    }\\n    .close-popup {\\n      font-family: \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\\n      float: right; \\n      cursor: pointer; \\n      font-size: 21px;\\n      line-height: 1;\\n      text-shadow: 0 1px 0 #fff;\\n      opacity: 0.2;\\n      padding: 10px;\\n    }\\n    /*.marker ~ * { display:block; background: #fff}*/\\n    .popup-container.small { width: 300px}\\n    .popup-container.large { width: 900px}\\n  \"],\n\t\t            encapsulation: core_1.ViewEncapsulation.None\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ComponentFactoryResolver, ng2_overlay_1.OverlayManager])\n\t\t    ], Ng2PopupComponent);\n\t\t    return Ng2PopupComponent;\n\t\t}());\n\t\texports.Ng2PopupComponent = Ng2PopupComponent;\n\t\n\t\n\t/***/ },\n\t/* 6 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Ng2MessagePopupComponent = (function () {\n\t\t    function Ng2MessagePopupComponent() {\n\t\t    }\n\t\t    Ng2MessagePopupComponent = __decorate([\n\t\t        core_1.Component({\n\t\t            selector: 'ng2-message-popup',\n\t\t            template: \"\\n    <div>\\n      <div class=\\\"popup-header\\\">{{popupOptions.title}}</div>\\n      <div class=\\\"popup-body\\\">{{popupOptions.message}}</div>\\n      <div class=\\\"popup-footer\\\" *ngIf=\\\"popupOptions.buttons\\\">\\n        <button *ngIf=\\\"popupOptions.buttons.OK\\\"\\n          (click)=\\\"popupOptions.buttons.OK()\\\">Ok</button>\\n        <button *ngIf=\\\"popupOptions.buttons.CANCEL\\\"\\n          (click)=\\\"popupOptions.buttons.CANCEL()\\\">Cancel</button>\\n      </div>\\n    </div>\\n  \",\n\t\t            encapsulation: core_1.ViewEncapsulation.None,\n\t\t            styles: [\"\\n    .popup-header, .popup-body, .popup-footer {\\n      padding: 15px;\\n      text-align: center;\\n    }\\n    .popup-header  {\\n      font-weight: bold;\\n      font-size: 18px;\\n      border-bottom: 1px solid #ccc;\\n    }\\n  \"]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2MessagePopupComponent);\n\t\t    return Ng2MessagePopupComponent;\n\t\t}());\n\t\texports.Ng2MessagePopupComponent = Ng2MessagePopupComponent;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-popup.umd.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-sticky\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-sticky\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_sticky_directive_1 = __webpack_require__(4);\n\t\texports.Ng2StickyDirective = ng2_sticky_directive_1.Ng2StickyDirective;\n\t\tvar Ng2StickyModule = (function () {\n\t\t    function Ng2StickyModule() {\n\t\t    }\n\t\t    Ng2StickyModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [ng2_sticky_directive_1.Ng2StickyDirective],\n\t\t            exports: [ng2_sticky_directive_1.Ng2StickyDirective]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2StickyModule);\n\t\t    return Ng2StickyModule;\n\t\t}());\n\t\texports.Ng2StickyModule = Ng2StickyModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar ng2_utils_1 = __webpack_require__(5);\n\t\tvar Ng2StickyDirective = (function () {\n\t\t    function Ng2StickyDirective(el) {\n\t\t        var _this = this;\n\t\t        this.stickyOffsetTop = 0;\n\t\t        this.scrollHandler = function () {\n\t\t            // let elRect: ClientRect = this.el.getBoundingClientRect();\n\t\t            var parentRect = _this.el.parentElement.getBoundingClientRect();\n\t\t            var bodyRect = document.body.getBoundingClientRect();\n\t\t            var dynProps;\n\t\t            if (_this.original.float === 'right') {\n\t\t                var right = bodyRect.right - parentRect.right + _this.original.marginRight;\n\t\t                dynProps = { right: right + 'px' };\n\t\t            }\n\t\t            else if (_this.original.float === 'left') {\n\t\t                var left = parentRect.left - bodyRect.left + _this.original.marginLeft;\n\t\t                dynProps = { left: left + 'px' };\n\t\t            }\n\t\t            else {\n\t\t                //console.log('parentRect..............', parentRect.width);\n\t\t                dynProps = { width: parentRect.width + 'px' };\n\t\t            }\n\t\t            //console.log('dynProps', dynProps);\n\t\t            if (_this.original.marginTop + _this.original.marginBottom +\n\t\t                _this.original.boundingClientRect.height + _this.stickyOffsetTop >= parentRect.bottom) {\n\t\t                /**\n\t\t                 * stikcy element reached to the bottom of the container\n\t\t                 */\n\t\t                // console.log('case 1 (absolute)', parentRect.bottom, this.original.marginBottom);\n\t\t                var floatAdjustment = _this.original.float === 'right' ? { right: 0 } :\n\t\t                    _this.original.float === 'left' ? { left: 0 } : {};\n\t\t                Object.assign(_this.el.style, {\n\t\t                    position: 'absolute',\n\t\t                    float: 'none',\n\t\t                    top: 'inherit',\n\t\t                    bottom: 0\n\t\t                }, dynProps, floatAdjustment);\n\t\t            }\n\t\t            else if (parentRect.top * -1 + _this.original.marginTop + _this.stickyOffsetTop > _this.original.offsetTop) {\n\t\t                /**\n\t\t                 * stikcy element is in the middle of container\n\t\t                 */\n\t\t                //console.log('case 2 (fixed)', parentRect.top * -1, this.original.marginTop, this.original.offsetTop);\n\t\t                // if not floating, add an empty filler element, since the original elements becames 'fixed'\n\t\t                if (_this.original.float !== 'left' && _this.original.float !== 'right' && !_this.fillerEl) {\n\t\t                    _this.fillerEl = document.createElement('div');\n\t\t                    _this.fillerEl.style.height = _this.el.offsetHeight + 'px';\n\t\t                    _this.parentEl.insertBefore(_this.fillerEl, _this.el);\n\t\t                }\n\t\t                Object.assign(_this.el.style, {\n\t\t                    position: 'fixed',\n\t\t                    float: 'none',\n\t\t                    top: _this.stickyOffsetTop + 'px',\n\t\t                    bottom: 'inherit'\n\t\t                }, dynProps);\n\t\t            }\n\t\t            else {\n\t\t                /**\n\t\t                 * stikcy element is in the original position\n\t\t                 */\n\t\t                // console.log('case 3 (original)');\n\t\t                if (_this.fillerEl) {\n\t\t                    _this.parentEl.removeChild(_this.fillerEl); //IE11 does not work with el.remove()\n\t\t                    _this.fillerEl = undefined;\n\t\t                }\n\t\t                Object.assign(_this.el.style, {\n\t\t                    position: _this.original.position,\n\t\t                    float: _this.original.float,\n\t\t                    top: _this.original.top,\n\t\t                    bottom: _this.original.bottom,\n\t\t                    width: _this.original.width,\n\t\t                    left: _this.original.left\n\t\t                }, dynProps);\n\t\t            }\n\t\t        };\n\t\t        this.el = this.el = el.nativeElement;\n\t\t        this.parentEl = this.el.parentElement;\n\t\t    }\n\t\t    Ng2StickyDirective.prototype.ngAfterViewInit = function () {\n\t\t        this.el.style.boxSizing = 'border-box';\n\t\t        if (this.stickyAfter) {\n\t\t            var cetStickyAfterEl = document.querySelector(this.stickyAfter);\n\t\t            if (cetStickyAfterEl) {\n\t\t                this.stickyOffsetTop = cetStickyAfterEl.getBoundingClientRect().bottom;\n\t\t            }\n\t\t        }\n\t\t        // set the parent relatively positioned\n\t\t        var allowedPositions = ['absolute', 'fixed', 'relative'];\n\t\t        var parentElPosition = ng2_utils_1.computedStyle(this.parentEl, 'position');\n\t\t        if (allowedPositions.indexOf(parentElPosition) === -1) {\n\t\t            this.parentEl.style.position = 'relative';\n\t\t        }\n\t\t        this.diff = {\n\t\t            top: this.el.offsetTop - this.parentEl.offsetTop,\n\t\t            left: this.el.offsetLeft - this.parentEl.offsetLeft\n\t\t        };\n\t\t        var elRect = this.el.getBoundingClientRect();\n\t\t        this.original = {\n\t\t            boundingClientRect: elRect,\n\t\t            position: ng2_utils_1.computedStyle(this.el, 'position'),\n\t\t            float: ng2_utils_1.computedStyle(this.el, 'float'),\n\t\t            top: ng2_utils_1.computedStyle(this.el, 'top'),\n\t\t            bottom: ng2_utils_1.computedStyle(this.el, 'bottom'),\n\t\t            left: ng2_utils_1.computedStyle(this.el, 'left'),\n\t\t            width: ng2_utils_1.computedStyle(this.el, 'width'),\n\t\t            offsetTop: this.el.offsetTop,\n\t\t            offsetLeft: this.el.offsetLeft,\n\t\t            marginTop: parseInt(ng2_utils_1.computedStyle(this.el, 'marginTop')),\n\t\t            marginBottom: parseInt(ng2_utils_1.computedStyle(this.el, 'marginBottom')),\n\t\t            marginLeft: parseInt(ng2_utils_1.computedStyle(this.el, 'marginLeft')),\n\t\t            marginRight: parseInt(ng2_utils_1.computedStyle(this.el, 'marginLeft'))\n\t\t        };\n\t\t        this.attach();\n\t\t    };\n\t\t    Ng2StickyDirective.prototype.attach = function () {\n\t\t        window.addEventListener('scroll', this.scrollHandler);\n\t\t        window.addEventListener('resize', this.scrollHandler);\n\t\t    };\n\t\t    Ng2StickyDirective.prototype.detach = function () {\n\t\t        window.removeEventListener('scroll', this.scrollHandler);\n\t\t        window.removeEventListener('resize', this.scrollHandler);\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input('sticky-after'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2StickyDirective.prototype, \"stickyAfter\", void 0);\n\t\t    Ng2StickyDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: '[ng2-sticky]'\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ElementRef])\n\t\t    ], Ng2StickyDirective);\n\t\t    return Ng2StickyDirective;\n\t\t}());\n\t\texports.Ng2StickyDirective = Ng2StickyDirective;\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\t\tif(true)\n\t\t\t\tmodule.exports = factory(__webpack_require__(1));\n\t\t\telse if(typeof define === 'function' && define.amd)\n\t\t\t\tdefine([\"@angular/core\"], factory);\n\t\t\telse if(typeof exports === 'object')\n\t\t\t\texports[\"ng2-utils\"] = factory(require(\"@angular/core\"));\n\t\t\telse\n\t\t\t\troot[\"ng2-utils\"] = factory(root[\"@angular/core\"]);\n\t\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\n\t\treturn /******/ (function(modules) { // webpackBootstrap\n\t\t/******/ \t// The module cache\n\t\t/******/ \tvar installedModules = {};\n\t\t/******/\n\t\t/******/ \t// The require function\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\t/******/\n\t\t/******/ \t\t// Check if module is in cache\n\t\t/******/ \t\tif(installedModules[moduleId])\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\t/******/\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t\t/******/ \t\t\texports: {},\n\t\t/******/ \t\t\tid: moduleId,\n\t\t/******/ \t\t\tloaded: false\n\t\t/******/ \t\t};\n\t\t/******/\n\t\t/******/ \t\t// Execute the module function\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t/******/\n\t\t/******/ \t\t// Flag the module as loaded\n\t\t/******/ \t\tmodule.loaded = true;\n\t\t/******/\n\t\t/******/ \t\t// Return the exports of the module\n\t\t/******/ \t\treturn module.exports;\n\t\t/******/ \t}\n\t\t/******/\n\t\t/******/\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\n\t\t/******/ \t__webpack_require__.m = modules;\n\t\t/******/\n\t\t/******/ \t// expose the module cache\n\t\t/******/ \t__webpack_require__.c = installedModules;\n\t\t/******/\n\t\t/******/ \t// __webpack_public_path__\n\t\t/******/ \t__webpack_require__.p = \"\";\n\t\t/******/\n\t\t/******/ \t// Load entry module and return exports\n\t\t/******/ \treturn __webpack_require__(0);\n\t\t/******/ })\n\t\t/************************************************************************/\n\t\t/******/ ([\n\t\t/* 0 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar scroll_to_1 = __webpack_require__(2);\n\t\t\texports.scrollTo = scroll_to_1.scrollTo;\n\t\t\tvar element_visible_1 = __webpack_require__(3);\n\t\t\texports.elementVisible = element_visible_1.elementVisible;\n\t\t\tvar computed_style_1 = __webpack_require__(4);\n\t\t\texports.computedStyle = computed_style_1.computedStyle;\n\t\t\tvar outer_width_1 = __webpack_require__(5);\n\t\t\texports.outerWidth = outer_width_1.outerWidth;\n\t\t\tvar outer_height_1 = __webpack_require__(6);\n\t\t\texports.outerHeight = outer_height_1.outerHeight;\n\t\t\tvar Ng2UtilsModule = (function () {\n\t\t\t    function Ng2UtilsModule() {\n\t\t\t    }\n\t\t\t    Ng2UtilsModule = __decorate([\n\t\t\t        core_1.NgModule({\n\t\t\t            declarations: [\n\t\t\t                scroll_to_1.scrollTo,\n\t\t\t                element_visible_1.elementVisible,\n\t\t\t                computed_style_1.computedStyle,\n\t\t\t                outer_width_1.outerWidth,\n\t\t\t                outer_height_1.outerHeight\n\t\t\t            ],\n\t\t\t            exports: [\n\t\t\t                scroll_to_1.scrollTo,\n\t\t\t                element_visible_1.elementVisible,\n\t\t\t                computed_style_1.computedStyle,\n\t\t\t                outer_width_1.outerWidth,\n\t\t\t                outer_height_1.outerHeight\n\t\t\t            ]\n\t\t\t        }), \n\t\t\t        __metadata('design:paramtypes', [])\n\t\t\t    ], Ng2UtilsModule);\n\t\t\t    return Ng2UtilsModule;\n\t\t\t}());\n\t\t\texports.Ng2UtilsModule = Ng2UtilsModule;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 1 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\t\n\t\t/***/ },\n\t\t/* 2 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * scroll to the selector within the parent selector by scrolling 10 times within 500ms\n\t\t\t * @param selector\n\t\t\t * @param parentSelector\n\t\t\t */\n\t\t\tfunction scrollTo(selector, parentSelector) {\n\t\t\t    console.log('selector', selector, 'parentSelector', parentSelector);\n\t\t\t    var parentEl, targetEl;\n\t\t\t    targetEl = document.querySelector(selector);\n\t\t\t    if (!targetEl) {\n\t\t\t        throw \"Invalid selector \" + selector;\n\t\t\t    }\n\t\t\t    parentEl = document.querySelector(parentSelector);\n\t\t\t    if (!parentEl) {\n\t\t\t        throw \"Invalid parent selector \" + parentSelector;\n\t\t\t    }\n\t\t\t    var parentElStyle = window.getComputedStyle(parentEl);\n\t\t\t    parentEl = parentElStyle['overflow'] === 'auto' ? parentEl : document.body;\n\t\t\t    var currentScrollTop = parentEl.scrollTop;\n\t\t\t    var targetOffsetTop = targetEl.offsetTop;\n\t\t\t    if (parentEl === document.body) {\n\t\t\t        var bodyRect = document.body.getBoundingClientRect();\n\t\t\t        var targetRect = targetEl.getBoundingClientRect();\n\t\t\t        targetOffsetTop = targetRect.top - bodyRect.top;\n\t\t\t    }\n\t\t\t    var step = Math.ceil((targetOffsetTop - currentScrollTop) / 10);\n\t\t\t    (function loop(i) {\n\t\t\t        setTimeout(function main() {\n\t\t\t            parentEl.scrollTop += step;\n\t\t\t            i > 1 && loop(i - 1);\n\t\t\t        }, 50);\n\t\t\t    }(10));\n\t\t\t}\n\t\t\texports.scrollTo = scrollTo;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 3 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * Returns an element is visible within outer element\n\t\t\t * @param innerEl\n\t\t\t * @param outerEl\n\t\t\t * @param adjustment\n\t\t\t * @returns {{top: boolean, bottom: boolean, left: boolean, right: boolean}}\n\t\t\t */\n\t\t\tfunction elementVisible(innerEl, outerEl, adjustment) {\n\t\t\t    var innerRect = innerEl.getBoundingClientRect();\n\t\t\t    var bottomAdjustment = (adjustment && adjustment.bottom || 0);\n\t\t\t    if (outerEl === window) {\n\t\t\t        return {\n\t\t\t            top: innerRect.bottom - bottomAdjustment > window.innerHeight\n\t\t\t                && innerRect.top < window.innerHeight,\n\t\t\t            bottom: innerRect.bottom - bottomAdjustment > 0\n\t\t\t                && innerRect.bottom < window.innerHeight,\n\t\t\t            left: innerRect.right > window.innerWidth\n\t\t\t                && innerRect.left < window.innerWidth,\n\t\t\t            right: innerRect.right > 0\n\t\t\t                && innerRect.right < window.innerWidth\n\t\t\t        };\n\t\t\t    }\n\t\t\t    else {\n\t\t\t        var outerRect = outerEl.getBoundingClientRect();\n\t\t\t        var defaultView = (innerEl.ownerDocument || document).defaultView;\n\t\t\t        var computedStyle = defaultView.getComputedStyle(outerEl, null);\n\t\t\t        var outerRectBorderTopWidth = parseInt(computedStyle.getPropertyValue('border-top-width'), 10);\n\t\t\t        var outerRectBorderLeftWidth = parseInt(computedStyle.getPropertyValue('border-left-width'), 10);\n\t\t\t        /* top is visible or bottom is visible */\n\t\t\t        var topVisible = (innerRect.top >= outerRect.top\n\t\t\t            && innerRect.top < outerRect.bottom);\n\t\t\t        var bottomVisible = (innerRect.bottom > (outerRect.top + outerRectBorderTopWidth)\n\t\t\t            && innerRect.bottom < outerRect.bottom);\n\t\t\t        var leftVisible = (innerRect.left >= outerRect.left\n\t\t\t            && innerRect.left < outerRect.right);\n\t\t\t        var rightVisible = (innerRect.right > (outerRect.left + outerRectBorderLeftWidth)\n\t\t\t            && innerRect.right < outerRect.right);\n\t\t\t        return {\n\t\t\t            top: topVisible,\n\t\t\t            bottom: bottomVisible,\n\t\t\t            left: leftVisible,\n\t\t\t            right: rightVisible\n\t\t\t        };\n\t\t\t    }\n\t\t\t}\n\t\t\texports.elementVisible = elementVisible;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 4 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * returns coumputed style of given element\n\t\t\t * @param el\n\t\t\t * @param styleProp\n\t\t\t * @returns {any}\n\t\t\t */\n\t\t\tfunction computedStyle(el, styleProp) {\n\t\t\t    var value, defaultView = (el.ownerDocument || document).defaultView;\n\t\t\t    // W3C standard way:\n\t\t\t    if (defaultView && defaultView.getComputedStyle) {\n\t\t\t        // sanitize property name to css notation\n\t\t\t        // (hypen separated words eg. font-Size)\n\t\t\t        styleProp = styleProp.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n\t\t\t        return defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);\n\t\t\t    }\n\t\t\t    else if (el['currentStyle']) {\n\t\t\t        // sanitize property name to camelCase\n\t\t\t        styleProp = styleProp.replace(/\\-(\\w)/g, function (str, letter) {\n\t\t\t            return letter.toUpperCase();\n\t\t\t        });\n\t\t\t        value = el['currentStyle'][styleProp];\n\t\t\t        // convert other units to pixels on IE\n\t\t\t        if (/^\\d+(em|pt|%|ex)?$/i.test(value)) {\n\t\t\t            return (function (value) {\n\t\t\t                var oldLeft = el.style.left, oldRsLeft = el['runtimeStyle'].left;\n\t\t\t                el['runtimeStyle'].left = el['currentStyle'].left;\n\t\t\t                el.style.left = value || 0;\n\t\t\t                value = el.style['pixelLeft'] + \"px\";\n\t\t\t                el.style.left = oldLeft;\n\t\t\t                el['runtimeStyle'].left = oldRsLeft;\n\t\t\t                return value;\n\t\t\t            })(value);\n\t\t\t        }\n\t\t\t        return value;\n\t\t\t    }\n\t\t\t}\n\t\t\texports.computedStyle = computedStyle;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 5 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tfunction outerWidth(el) {\n\t\t\t    var style = getComputedStyle(el);\n\t\t\t    return el.offsetWidth +\n\t\t\t        parseInt(style.getPropertyValue('margin-left')) +\n\t\t\t        parseInt(style.getPropertyValue('margin-right'));\n\t\t\t}\n\t\t\texports.outerWidth = outerWidth;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 6 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tfunction outerHeight(el) {\n\t\t\t    var style = getComputedStyle(el);\n\t\t\t    return el.offsetHeight +\n\t\t\t        parseInt(style.getPropertyValue('margin-top')) +\n\t\t\t        parseInt(style.getPropertyValue('margin-bottom'));\n\t\t\t}\n\t\t\texports.outerHeight = outerHeight;\n\t\t\n\t\t\n\t\t/***/ }\n\t\t/******/ ])\n\t\t});\n\t\t;\n\t\t//# sourceMappingURL=ng2-utils.umd.js.map\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-sticky.umd.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-tab\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-tab\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_tab_component_1 = __webpack_require__(4);\n\t\texports.Ng2TabComponent = ng2_tab_component_1.Ng2TabComponent;\n\t\tvar Ng2TabModule = (function () {\n\t\t    function Ng2TabModule() {\n\t\t    }\n\t\t    Ng2TabModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [ng2_tab_component_1.Ng2TabComponent],\n\t\t            exports: [ng2_tab_component_1.Ng2TabComponent]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2TabModule);\n\t\t    return Ng2TabModule;\n\t\t}());\n\t\texports.Ng2TabModule = Ng2TabModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Ng2TabComponent = (function () {\n\t\t    function Ng2TabComponent(viewContainer) {\n\t\t        this.viewContainer = viewContainer;\n\t\t        this.selectedIndexClass = 'selected';\n\t\t        this.selectedContentsClass = 'selected';\n\t\t        this.el = this.viewContainer.element.nativeElement;\n\t\t    }\n\t\t    Ng2TabComponent.prototype.ngAfterViewInit = function () {\n\t\t        var _this = this;\n\t\t        this.indexEls = [].slice.call(this.el.querySelectorAll('[index]'));\n\t\t        this.contentsEls = [].slice.call(this.el.querySelectorAll('[contents]'));\n\t\t        this.selectTab(this.selectedIndex);\n\t\t        this.indexEls.forEach(function (el) {\n\t\t            el.addEventListener('click', function () {\n\t\t                _this.selectTab(el.getAttribute('index'));\n\t\t            });\n\t\t        });\n\t\t    };\n\t\t    Ng2TabComponent.prototype.selectTab = function (id) {\n\t\t        var _this = this;\n\t\t        id = id || this.indexEls[0].getAttribute('index');\n\t\t        this.indexEls.forEach(function (el) {\n\t\t            _this.removeClass(el, _this.selectedIndexClass);\n\t\t            if (el.getAttribute('index') == id) {\n\t\t                _this.addClass(el, _this.selectedIndexClass);\n\t\t            }\n\t\t        });\n\t\t        this.contentsEls.forEach(function (el) {\n\t\t            el.style.display = 'none';\n\t\t            _this.removeClass(el, _this.selectedContentsClass);\n\t\t            if (el.getAttribute('contents') == id) {\n\t\t                el.style.display = '';\n\t\t                _this.addClass(el, _this.selectedContentsClass);\n\t\t            }\n\t\t        });\n\t\t    };\n\t\t    Ng2TabComponent.prototype.addClass = function (el, str) {\n\t\t        var classNames = (el.className || '').split(' ');\n\t\t        classNames.push(str);\n\t\t        el.className = classNames.join(' ');\n\t\t    };\n\t\t    Ng2TabComponent.prototype.removeClass = function (el, str) {\n\t\t        el.className = (el.className || '').replace(new RegExp('[ ]*' + str), '');\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input('selected'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2TabComponent.prototype, \"selectedIndex\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input('selected-index-class'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2TabComponent.prototype, \"selectedIndexClass\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Input('selected-contents-class'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2TabComponent.prototype, \"selectedContentsClass\", void 0);\n\t\t    Ng2TabComponent = __decorate([\n\t\t        core_1.Component({\n\t\t            selector: 'ng2-tab, [ng2-tab]',\n\t\t            encapsulation: core_1.ViewEncapsulation.None,\n\t\t            template: \"<ng-content></ng-content>\",\n\t\t            styles: [\"\\n    .tabs {\\n      position: relative;\\n      top: 1px;\\n      background: transparent;\\n      display: block;\\n    }\\n    .tabs [index] {\\n      display: inline-block;\\n      border: 1px solid #999;\\n      padding: 5px 10px;\\n      border-radius: 2px 2px 0 0;\\n    }\\n    .tabs [index].selected {\\n      padding-top: 0;\\n      background: #f7f7f7;\\n      border-top: 5px solid #00BCD4;\\n      border-bottom: 1px solid transparent;\\n    }\\n    .tab-contents {\\n      border: 1px solid #999;\\n      border-radius: 2px;\\n      min-height: 3em;\\n    }\\n  \"],\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef])\n\t\t    ], Ng2TabComponent);\n\t\t    return Ng2TabComponent;\n\t\t}());\n\t\texports.Ng2TabComponent = Ng2TabComponent;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-tab.umd.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-tooltip-overlay\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-tooltip-overlay\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_tooltip_directive_1 = __webpack_require__(4);\n\t\texports.Ng2TooltipDirective = ng2_tooltip_directive_1.Ng2TooltipDirective;\n\t\tvar ng2_overlay_1 = __webpack_require__(5);\n\t\tvar Ng2TooltipOverlayModule = (function () {\n\t\t    function Ng2TooltipOverlayModule() {\n\t\t    }\n\t\t    Ng2TooltipOverlayModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule, ng2_overlay_1.Ng2OverlayModule],\n\t\t            declarations: [ng2_tooltip_directive_1.Ng2TooltipDirective],\n\t\t            exports: [ng2_tooltip_directive_1.Ng2TooltipDirective]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2TooltipOverlayModule);\n\t\t    return Ng2TooltipOverlayModule;\n\t\t}());\n\t\texports.Ng2TooltipOverlayModule = Ng2TooltipOverlayModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar ng2_overlay_1 = __webpack_require__(5);\n\t\tvar Ng2TooltipDirective = (function () {\n\t\t    function Ng2TooltipDirective(viewContainerRef, overlayManager) {\n\t\t        this.viewContainerRef = viewContainerRef;\n\t\t        this.overlayManager = overlayManager;\n\t\t        this.el = this.viewContainerRef.element.nativeElement;\n\t\t    }\n\t\t    Ng2TooltipDirective.prototype.ngAfterViewInit = function () {\n\t\t        this.overlay = this.getTooltipOverlay(this.el, this.tooltip);\n\t\t    };\n\t\t    Ng2TooltipDirective.prototype.showTooltip = function ($event) {\n\t\t        this.overlayManager.open(this.overlay, $event);\n\t\t        $event.stopPropagation();\n\t\t    };\n\t\t    Ng2TooltipDirective.prototype.hideTooltip = function ($event) {\n\t\t        this.overlayManager.close(this.overlay);\n\t\t        $event.stopPropagation();\n\t\t    };\n\t\t    Ng2TooltipDirective.prototype.getTooltipOverlay = function (el, tooltip) {\n\t\t        var tooltipEl = document.createElement('ng2-tooltip');\n\t\t        tooltipEl.style.display = 'none';\n\t\t        var divEl = document.createElement('div');\n\t\t        divEl.innerHTML = \"\\n       <div class='tooltip-contents'>\" + tooltip + \"</div>\\n       <div class='tooltip-down-arrow'></div>\\n    \";\n\t\t        tooltipEl.appendChild(divEl);\n\t\t        //el.parentElement.insertBefore(tooltipEl, el.nextSibling);\n\t\t        el.appendChild(tooltipEl);\n\t\t        var overlay = new ng2_overlay_1.Overlay(tooltipEl, {\n\t\t            id: 'tooltip-' + (el.id || Math.floor(Math.random() * 1000000)),\n\t\t            position: 'top cursor outside'\n\t\t        });\n\t\t        this.overlayManager.register(overlay);\n\t\t        return overlay;\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input('ng2-tooltip'), \n\t\t        __metadata('design:type', String)\n\t\t    ], Ng2TooltipDirective.prototype, \"tooltip\", void 0);\n\t\t    Ng2TooltipDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: '[ng2-tooltip]',\n\t\t            host: {\n\t\t                '(mouseover)': 'showTooltip($event)',\n\t\t                '(mouseout)': 'hideTooltip($event)'\n\t\t            }\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef, ng2_overlay_1.OverlayManager])\n\t\t    ], Ng2TooltipDirective);\n\t\t    return Ng2TooltipDirective;\n\t\t}());\n\t\texports.Ng2TooltipDirective = Ng2TooltipDirective;\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\t\tif(true)\n\t\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\t\telse if(typeof define === 'function' && define.amd)\n\t\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\t\telse if(typeof exports === 'object')\n\t\t\t\texports[\"ng2-overlay\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\t\telse\n\t\t\t\troot[\"ng2-overlay\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\t\treturn /******/ (function(modules) { // webpackBootstrap\n\t\t/******/ \t// The module cache\n\t\t/******/ \tvar installedModules = {};\n\t\t/******/\n\t\t/******/ \t// The require function\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\t/******/\n\t\t/******/ \t\t// Check if module is in cache\n\t\t/******/ \t\tif(installedModules[moduleId])\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\t/******/\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t\t/******/ \t\t\texports: {},\n\t\t/******/ \t\t\tid: moduleId,\n\t\t/******/ \t\t\tloaded: false\n\t\t/******/ \t\t};\n\t\t/******/\n\t\t/******/ \t\t// Execute the module function\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t/******/\n\t\t/******/ \t\t// Flag the module as loaded\n\t\t/******/ \t\tmodule.loaded = true;\n\t\t/******/\n\t\t/******/ \t\t// Return the exports of the module\n\t\t/******/ \t\treturn module.exports;\n\t\t/******/ \t}\n\t\t/******/\n\t\t/******/\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\n\t\t/******/ \t__webpack_require__.m = modules;\n\t\t/******/\n\t\t/******/ \t// expose the module cache\n\t\t/******/ \t__webpack_require__.c = installedModules;\n\t\t/******/\n\t\t/******/ \t// __webpack_public_path__\n\t\t/******/ \t__webpack_require__.p = \"\";\n\t\t/******/\n\t\t/******/ \t// Load entry module and return exports\n\t\t/******/ \treturn __webpack_require__(0);\n\t\t/******/ })\n\t\t/************************************************************************/\n\t\t/******/ ([\n\t\t/* 0 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar forms_1 = __webpack_require__(2);\n\t\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\t\tvar overlay_1 = __webpack_require__(4);\n\t\t\texports.Overlay = overlay_1.Overlay;\n\t\t\tvar overlay_manager_1 = __webpack_require__(6);\n\t\t\texports.OverlayManager = overlay_manager_1.OverlayManager;\n\t\t\tvar overlay_directive_1 = __webpack_require__(7);\n\t\t\texports.OverlayDirective = overlay_directive_1.OverlayDirective;\n\t\t\tvar Ng2OverlayModule = (function () {\n\t\t\t    function Ng2OverlayModule() {\n\t\t\t    }\n\t\t\t    Ng2OverlayModule = __decorate([\n\t\t\t        core_1.NgModule({\n\t\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t\t            declarations: [overlay_directive_1.OverlayDirective],\n\t\t\t            providers: [overlay_manager_1.OverlayManager],\n\t\t\t            exports: [overlay_directive_1.OverlayDirective]\n\t\t\t        }), \n\t\t\t        __metadata('design:paramtypes', [])\n\t\t\t    ], Ng2OverlayModule);\n\t\t\t    return Ng2OverlayModule;\n\t\t\t}());\n\t\t\texports.Ng2OverlayModule = Ng2OverlayModule;\n\t\t\t;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 1 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\t\n\t\t/***/ },\n\t\t/* 2 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\t\n\t\t/***/ },\n\t\t/* 3 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\t\n\t\t/***/ },\n\t\t/* 4 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar util_1 = __webpack_require__(5);\n\t\t\tvar Overlay = (function () {\n\t\t\t    function Overlay(el, options) {\n\t\t\t        options = options || {};\n\t\t\t        this.id = options.id;\n\t\t\t        this.type = options.type;\n\t\t\t        if (!this.id) {\n\t\t\t            throw \"Invalid overlay id\";\n\t\t\t        }\n\t\t\t        this.element = el; // overlay wrapper element with table dsplay\n\t\t\t        this.windowOverlay = options.windowOverlay;\n\t\t\t        this.position = this.getPositionProperty(options.position || 'center center');\n\t\t\t    }\n\t\t\t    Overlay.prototype.positionIt = function (event) {\n\t\t\t        if (this.position.inside) {\n\t\t\t            this.positionItInside(this.position);\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            this.positionItOutside(this.position, event);\n\t\t\t        }\n\t\t\t    };\n\t\t\t    Overlay.prototype.getPositionProperty = function (positionStr) {\n\t\t\t        var position = {}, inside;\n\t\t\t        var _a = positionStr.split(' '), vertical = _a[0], horizontal = _a[1], insideStr = _a[2];\n\t\t\t        horizontal = horizontal || 'center';\n\t\t\t        vertical = vertical || 'center';\n\t\t\t        inside = (insideStr !== 'outside' || this.windowOverlay);\n\t\t\t        position.horizontal = Overlay[horizontal.toUpperCase()];\n\t\t\t        position.vertical = Overlay[vertical.toUpperCase()];\n\t\t\t        position.inside = inside;\n\t\t\t        return position;\n\t\t\t    };\n\t\t\t    Overlay.prototype.positionItInside = function (position) {\n\t\t\t        this.element.style.display = 'flex';\n\t\t\t        //top / left positioning\n\t\t\t        if (this.windowOverlay) {\n\t\t\t            this.element.style.position = 'fixed';\n\t\t\t            //works as blocker\n\t\t\t            Object.assign(this.element.style, {\n\t\t\t                backgroundColor: 'rgba(0,0,0,0.2)',\n\t\t\t                top: '0', left: '0', bottom: '0', right: '0',\n\t\t\t                width: '100%', height: '100%'\n\t\t\t            });\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            //adjust top/left to match to parentElement\n\t\t\t            var parentEl = this.element.parentElement;\n\t\t\t            //works as a blocker\n\t\t\t            Object.assign(this.element.style, {\n\t\t\t                position: 'absolute',\n\t\t\t                // backgroundColor: 'transparent',\n\t\t\t                backgroundColor: 'rgba(0,0,0,0.2)',\n\t\t\t                top: parentEl.offsetTop + 'px',\n\t\t\t                left: parentEl.offsetLeft + 'px',\n\t\t\t                width: parentEl.offsetWidth + 'px',\n\t\t\t                height: parentEl.offsetHeight + 'px'\n\t\t\t            });\n\t\t\t        }\n\t\t\t        ;\n\t\t\t        //horizontal position\n\t\t\t        switch (position.horizontal) {\n\t\t\t            case Overlay.LEFT:\n\t\t\t                this.element.style.justifyContent = 'flex-start';\n\t\t\t                break;\n\t\t\t            case Overlay.CENTER:\n\t\t\t                this.element.style.justifyContent = 'center';\n\t\t\t                break;\n\t\t\t            case Overlay.RIGHT:\n\t\t\t                this.element.style.justifyContent = 'flex-end';\n\t\t\t                break;\n\t\t\t        }\n\t\t\t        //vertical position\n\t\t\t        switch (position.vertical) {\n\t\t\t            case Overlay.LEFT:\n\t\t\t                this.element.style.alignItems = 'flex-start';\n\t\t\t                break;\n\t\t\t            case Overlay.CENTER:\n\t\t\t            case Overlay.MIDDLE:\n\t\t\t                this.element.style.alignItems = 'center';\n\t\t\t                break;\n\t\t\t            case Overlay.RIGHT:\n\t\t\t                this.element.style.alignItems = 'flex-end';\n\t\t\t                break;\n\t\t\t        }\n\t\t\t    };\n\t\t\t    Overlay.prototype.positionItOutside = function (position, event) {\n\t\t\t        //adjust top/left to match to parentElement\n\t\t\t        var parentEl = this.element.parentElement;\n\t\t\t        //works as guide line?\n\t\t\t        Object.assign(this.element.style, {\n\t\t\t            position: 'absolute',\n\t\t\t            pointerEvents: 'none',\n\t\t\t            top: parentEl.offsetTop + 'px',\n\t\t\t            left: parentEl.offsetLeft + 'px',\n\t\t\t            width: parentEl.offsetWidth + 'px',\n\t\t\t            height: parentEl.offsetHeight + 'px'\n\t\t\t        });\n\t\t\t        this.element.style.display = 'block';\n\t\t\t        var elToPosition = (this.element.children[0]);\n\t\t\t        elToPosition.style.position = 'absolute';\n\t\t\t        elToPosition.style.pointerEvents = 'auto';\n\t\t\t        switch (position.vertical) {\n\t\t\t            case Overlay.TOP:\n\t\t\t                elToPosition.style.bottom = this.element.offsetHeight + 'px';\n\t\t\t                break;\n\t\t\t            case Overlay.BOTTOM:\n\t\t\t                elToPosition.style.top = this.element.offsetHeight + 'px';\n\t\t\t                break;\n\t\t\t            case Overlay.LEFT:\n\t\t\t                elToPosition.style.right = this.element.offsetWidth + 'px';\n\t\t\t                break;\n\t\t\t            case Overlay.RIGHT:\n\t\t\t                elToPosition.style.left = this.element.offsetWidth + 'px';\n\t\t\t                break;\n\t\t\t        }\n\t\t\t        switch (position.horizontal) {\n\t\t\t            case Overlay.CENTER:\n\t\t\t                elToPosition.style.left = (this.element.offsetWidth - elToPosition.offsetWidth) / 2 + 'px';\n\t\t\t                break;\n\t\t\t            case Overlay.LEFT:\n\t\t\t                elToPosition.style.left = '0';\n\t\t\t                break;\n\t\t\t            case Overlay.RIGHT:\n\t\t\t                elToPosition.style.right = '0';\n\t\t\t                break;\n\t\t\t            case Overlay.TOP:\n\t\t\t                elToPosition.style.top = '0';\n\t\t\t                break;\n\t\t\t            case Overlay.BOTTOM:\n\t\t\t                elToPosition.style.bottom = '0';\n\t\t\t                break;\n\t\t\t            case Overlay.CURSOR:\n\t\t\t                var mousePos = util_1.Util.getMousePositionInElement(event, this.element);\n\t\t\t                if ((mousePos.x + elToPosition.offsetWidth) > this.element.offsetWidth) {\n\t\t\t                    elToPosition.style.left = (this.element.offsetWidth - elToPosition.offsetWidth - 5) + 'px';\n\t\t\t                }\n\t\t\t                else if (mousePos.x < elToPosition.offsetWidth / 2) {\n\t\t\t                    elToPosition.style.left = '0px';\n\t\t\t                }\n\t\t\t                else {\n\t\t\t                    elToPosition.style.left = mousePos.x - elToPosition.offsetWidth / 2 + 'px';\n\t\t\t                }\n\t\t\t                break;\n\t\t\t        }\n\t\t\t    };\n\t\t\t    Overlay.TOP = 11;\n\t\t\t    Overlay.MIDDLE = 12;\n\t\t\t    Overlay.BOTTOM = 13;\n\t\t\t    Overlay.LEFT = 21;\n\t\t\t    Overlay.CENTER = 22;\n\t\t\t    Overlay.RIGHT = 23;\n\t\t\t    Overlay.CURSOR = 31;\n\t\t\t    return Overlay;\n\t\t\t}());\n\t\t\texports.Overlay = Overlay;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 5 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar Util = (function () {\n\t\t\t    function Util() {\n\t\t\t    }\n\t\t\t    Util.getDocumentPosition = function (oElement) {\n\t\t\t        var posX = 0, posY = 0;\n\t\t\t        if (oElement.offsetParent) {\n\t\t\t            for (; oElement; oElement = oElement.offsetParent) {\n\t\t\t                posX += oElement.offsetLeft;\n\t\t\t                posY += oElement.offsetTop;\n\t\t\t            }\n\t\t\t            return { x: posX, y: posY };\n\t\t\t        }\n\t\t\t        else {\n\t\t\t            return { x: oElement['x'], y: oElement['y'] };\n\t\t\t        }\n\t\t\t    };\n\t\t\t    Util.getMousePositionInElement = function (evt, element) {\n\t\t\t        evt = evt || window.event;\n\t\t\t        var posX = 0, posY = 0;\n\t\t\t        var elPos = this.getDocumentPosition(element);\n\t\t\t        if (evt.pageX || evt.pageY) {\n\t\t\t            posX = evt.pageX;\n\t\t\t            posY = evt.pageY;\n\t\t\t        }\n\t\t\t        else if (evt.clientX || evt.clientY) {\n\t\t\t            posX = evt.clientX +\n\t\t\t                document.body.scrollLeft +\n\t\t\t                document.documentElement.scrollLeft;\n\t\t\t            posY = evt.clientY +\n\t\t\t                document.body.scrollTop +\n\t\t\t                document.documentElement.scrollTop;\n\t\t\t        }\n\t\t\t        return {\n\t\t\t            x: posX - elPos.x,\n\t\t\t            y: posY - elPos.y\n\t\t\t        };\n\t\t\t    };\n\t\t\t    return Util;\n\t\t\t}());\n\t\t\texports.Util = Util;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 6 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar OverlayManager = (function () {\n\t\t\t    function OverlayManager() {\n\t\t\t    }\n\t\t\t    OverlayManager.prototype.register = function (overlay) {\n\t\t\t        OverlayManager.overlays[overlay.id] = overlay;\n\t\t\t        // console.log('overlay.register, OverlayManager.overlays', OverlayManager.overlays);\n\t\t\t    };\n\t\t\t    OverlayManager.prototype.open = function (arg, event) {\n\t\t\t        var overlay = typeof arg === 'string' ? OverlayManager.overlays[arg] : arg;\n\t\t\t        if (!overlay.opened) {\n\t\t\t            overlay.positionIt(event);\n\t\t\t            overlay.opened = true;\n\t\t\t        }\n\t\t\t    };\n\t\t\t    OverlayManager.prototype.close = function (arg) {\n\t\t\t        var overlay = typeof arg === 'string' ? OverlayManager.overlays[arg] : arg;\n\t\t\t        overlay.element.style.display = 'none';\n\t\t\t        overlay.opened = false;\n\t\t\t    };\n\t\t\t    //list of overlay objects\n\t\t\t    OverlayManager.overlays = {};\n\t\t\t    OverlayManager = __decorate([\n\t\t\t        core_1.Injectable(), \n\t\t\t        __metadata('design:paramtypes', [])\n\t\t\t    ], OverlayManager);\n\t\t\t    return OverlayManager;\n\t\t\t}());\n\t\t\texports.OverlayManager = OverlayManager;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 7 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar overlay_manager_1 = __webpack_require__(6);\n\t\t\tvar overlay_1 = __webpack_require__(4);\n\t\t\tvar OverlayDirective = (function () {\n\t\t\t    function OverlayDirective(viewContainerRef, overlayManager) {\n\t\t\t        this.viewContainerRef = viewContainerRef;\n\t\t\t        this.overlayManager = overlayManager;\n\t\t\t        this.el = this.viewContainerRef.element.nativeElement;\n\t\t\t    }\n\t\t\t    OverlayDirective.prototype.ngAfterViewInit = function () {\n\t\t\t        this.wrapItWithOverlayTag();\n\t\t\t        this.registerToOverlayManager();\n\t\t\t    };\n\t\t\t    OverlayDirective.prototype.wrapItWithOverlayTag = function () {\n\t\t\t        //console.log('wrapped overlay directive element with <ng2-overlay>');\n\t\t\t        this.overlayEl = document.createElement('ng2-overlay');\n\t\t\t        this.overlayEl.style.display = 'none';\n\t\t\t        this.el.parentElement.insertBefore(this.overlayEl, this.el.nextSibling);\n\t\t\t        this.overlayEl.appendChild(this.el);\n\t\t\t    };\n\t\t\t    //create Overlay object,  then register this element to overlayManager\n\t\t\t    OverlayDirective.prototype.registerToOverlayManager = function () {\n\t\t\t        var positionStr = this.overlayPosition;\n\t\t\t        var overlay = new overlay_1.Overlay(this.overlayEl, {\n\t\t\t            id: this.el.id,\n\t\t\t            windowOverlay: this.overlayOf == \"window\",\n\t\t\t            position: positionStr\n\t\t\t        });\n\t\t\t        //console.log('registering overlay', overlay);\n\t\t\t        this.overlayManager.register(overlay);\n\t\t\t    };\n\t\t\t    __decorate([\n\t\t\t        core_1.Input('ng2-overlay-of'), \n\t\t\t        __metadata('design:type', String)\n\t\t\t    ], OverlayDirective.prototype, \"overlayOf\", void 0);\n\t\t\t    __decorate([\n\t\t\t        core_1.Input('ng2-overlay-position'), \n\t\t\t        __metadata('design:type', String)\n\t\t\t    ], OverlayDirective.prototype, \"overlayPosition\", void 0);\n\t\t\t    OverlayDirective = __decorate([\n\t\t\t        core_1.Directive({\n\t\t\t            selector: '[ng2-overlay], [ng2-overlay-of], [ng2-overlay-position]',\n\t\t\t        }), \n\t\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef, overlay_manager_1.OverlayManager])\n\t\t\t    ], OverlayDirective);\n\t\t\t    return OverlayDirective;\n\t\t\t}());\n\t\t\texports.OverlayDirective = OverlayDirective;\n\t\t\n\t\t\n\t\t/***/ }\n\t\t/******/ ])\n\t\t});\n\t\t;\n\t\t//# sourceMappingURL=ng2-overlay.umd.js.map\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-tooltip-overlay.umd.js.map\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-scrollable\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-scrollable\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_scrollable_directive_1 = __webpack_require__(4);\n\t\texports.Ng2ScrollableDirective = ng2_scrollable_directive_1.Ng2ScrollableDirective;\n\t\tvar Ng2ScrollableModule = (function () {\n\t\t    function Ng2ScrollableModule() {\n\t\t    }\n\t\t    Ng2ScrollableModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [ng2_scrollable_directive_1.Ng2ScrollableDirective],\n\t\t            exports: [ng2_scrollable_directive_1.Ng2ScrollableDirective]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2ScrollableModule);\n\t\t    return Ng2ScrollableModule;\n\t\t}());\n\t\texports.Ng2ScrollableModule = Ng2ScrollableModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar ng2_utils_1 = __webpack_require__(5);\n\t\tvar Ng2ScrollableDirective = (function () {\n\t\t    function Ng2ScrollableDirective(el) {\n\t\t        this.elementVisible = new core_1.EventEmitter();\n\t\t        this.sections = [];\n\t\t        this.visible = ng2_utils_1.elementVisible;\n\t\t        this.el = el.nativeElement;\n\t\t        this.el.style.position = 'relative';\n\t\t    }\n\t\t    // setup list of sections\n\t\t    Ng2ScrollableDirective.prototype.ngOnInit = function () {\n\t\t        for (var i = 0; i < this.el.children.length; i++) {\n\t\t            var childEl = this.el.children[i];\n\t\t            childEl.id && this.sections.push(childEl);\n\t\t        }\n\t\t        var thisElStyle = window.getComputedStyle(this.el);\n\t\t        var elToListenScroll = thisElStyle.overflow === 'auto' ? this.el : window;\n\t\t        this.listenScrollOn(elToListenScroll);\n\t\t    };\n\t\t    Ng2ScrollableDirective.prototype.listenScrollOn = function (el) {\n\t\t        var _this = this;\n\t\t        el.addEventListener('scroll', function () {\n\t\t            var elScrolledToVisible = null;\n\t\t            for (var i = 0; i < _this.sections.length; i++) {\n\t\t                var section = _this.sections[i];\n\t\t                var visible = _this.visible(section, el);\n\t\t                if (_this.horizontal && (visible.left || visible.right)) {\n\t\t                    elScrolledToVisible = section;\n\t\t                    break;\n\t\t                }\n\t\t                else if (!_this.horizontal && (visible.top || visible.bottom)) {\n\t\t                    elScrolledToVisible = section;\n\t\t                    break;\n\t\t                }\n\t\t            }\n\t\t            elScrolledToVisible && _this.elementVisible.emit(elScrolledToVisible);\n\t\t        });\n\t\t    };\n\t\t    Ng2ScrollableDirective.scrollTo = function (selector, parentSelector, horizontal, distance) {\n\t\t        // argument validation\n\t\t        var parentEl, targetEl;\n\t\t        parentSelector = parentSelector || 'body';\n\t\t        targetEl = document.querySelector(selector);\n\t\t        if (!targetEl) {\n\t\t            throw \"Invalid selector \" + selector;\n\t\t        }\n\t\t        parentEl = document.querySelector(parentSelector);\n\t\t        if (!parentEl) {\n\t\t            throw \"Invalid parent selector \" + parentSelector;\n\t\t        }\n\t\t        // detect the current environment\n\t\t        var parentElStyle = window.getComputedStyle(parentEl);\n\t\t        var scrollContainerEl = parentElStyle.overflow === 'auto' ?\n\t\t            parentEl : document.body;\n\t\t        var currentScrollTop = scrollContainerEl.scrollTop;\n\t\t        var currentScrollLeft = scrollContainerEl.scrollLeft;\n\t\t        // determine targetOffsetTop(or Left);\n\t\t        var targetOffsetTop;\n\t\t        var targetOffsetLeft;\n\t\t        if (scrollContainerEl === document.body) {\n\t\t            var bodyRect = document.body.getBoundingClientRect();\n\t\t            var targetRect = targetEl.getBoundingClientRect();\n\t\t            targetOffsetTop = targetRect.top - bodyRect.top;\n\t\t            targetOffsetLeft = targetRect.left - bodyRect.left;\n\t\t        }\n\t\t        else {\n\t\t            targetOffsetTop = targetEl.offsetTop;\n\t\t            targetOffsetLeft = targetEl.offsetLeft;\n\t\t        }\n\t\t        if (distance) {\n\t\t            currentScrollTop += distance;\n\t\t            currentScrollLeft += distance;\n\t\t        }\n\t\t        // start scrolling\n\t\t        var step = horizontal ?\n\t\t            Math.ceil((targetOffsetLeft - currentScrollLeft) / 10) :\n\t\t            Math.ceil((targetOffsetTop - currentScrollTop) / 10);\n\t\t        var scrollProp = horizontal ? 'scrollLeft' : 'scrollTop';\n\t\t        (function loop(i, prop) {\n\t\t            setTimeout(function main() {\n\t\t                scrollContainerEl[prop] += step;\n\t\t                i > 1 && loop(i - 1, prop);\n\t\t            }, 50);\n\t\t        }(10, scrollProp));\n\t\t    };\n\t\t    __decorate([\n\t\t        core_1.Input(), \n\t\t        __metadata('design:type', Boolean)\n\t\t    ], Ng2ScrollableDirective.prototype, \"horizontal\", void 0);\n\t\t    __decorate([\n\t\t        core_1.Output(), \n\t\t        __metadata('design:type', Object)\n\t\t    ], Ng2ScrollableDirective.prototype, \"elementVisible\", void 0);\n\t\t    Ng2ScrollableDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: '[ng2-scrollable]'\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ElementRef])\n\t\t    ], Ng2ScrollableDirective);\n\t\t    return Ng2ScrollableDirective;\n\t\t}());\n\t\texports.Ng2ScrollableDirective = Ng2ScrollableDirective;\n\t\n\t\n\t/***/ },\n\t/* 5 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\t\tif(true)\n\t\t\t\tmodule.exports = factory(__webpack_require__(1));\n\t\t\telse if(typeof define === 'function' && define.amd)\n\t\t\t\tdefine([\"@angular/core\"], factory);\n\t\t\telse if(typeof exports === 'object')\n\t\t\t\texports[\"ng2-utils\"] = factory(require(\"@angular/core\"));\n\t\t\telse\n\t\t\t\troot[\"ng2-utils\"] = factory(root[\"@angular/core\"]);\n\t\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\n\t\treturn /******/ (function(modules) { // webpackBootstrap\n\t\t/******/ \t// The module cache\n\t\t/******/ \tvar installedModules = {};\n\t\t/******/\n\t\t/******/ \t// The require function\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\t/******/\n\t\t/******/ \t\t// Check if module is in cache\n\t\t/******/ \t\tif(installedModules[moduleId])\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\t/******/\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t\t/******/ \t\t\texports: {},\n\t\t/******/ \t\t\tid: moduleId,\n\t\t/******/ \t\t\tloaded: false\n\t\t/******/ \t\t};\n\t\t/******/\n\t\t/******/ \t\t// Execute the module function\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t/******/\n\t\t/******/ \t\t// Flag the module as loaded\n\t\t/******/ \t\tmodule.loaded = true;\n\t\t/******/\n\t\t/******/ \t\t// Return the exports of the module\n\t\t/******/ \t\treturn module.exports;\n\t\t/******/ \t}\n\t\t/******/\n\t\t/******/\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\n\t\t/******/ \t__webpack_require__.m = modules;\n\t\t/******/\n\t\t/******/ \t// expose the module cache\n\t\t/******/ \t__webpack_require__.c = installedModules;\n\t\t/******/\n\t\t/******/ \t// __webpack_public_path__\n\t\t/******/ \t__webpack_require__.p = \"\";\n\t\t/******/\n\t\t/******/ \t// Load entry module and return exports\n\t\t/******/ \treturn __webpack_require__(0);\n\t\t/******/ })\n\t\t/************************************************************************/\n\t\t/******/ ([\n\t\t/* 0 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t\t};\n\t\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t\t};\n\t\t\tvar core_1 = __webpack_require__(1);\n\t\t\tvar scroll_to_1 = __webpack_require__(2);\n\t\t\texports.scrollTo = scroll_to_1.scrollTo;\n\t\t\tvar element_visible_1 = __webpack_require__(3);\n\t\t\texports.elementVisible = element_visible_1.elementVisible;\n\t\t\tvar computed_style_1 = __webpack_require__(4);\n\t\t\texports.computedStyle = computed_style_1.computedStyle;\n\t\t\tvar outer_width_1 = __webpack_require__(5);\n\t\t\texports.outerWidth = outer_width_1.outerWidth;\n\t\t\tvar outer_height_1 = __webpack_require__(6);\n\t\t\texports.outerHeight = outer_height_1.outerHeight;\n\t\t\tvar Ng2UtilsModule = (function () {\n\t\t\t    function Ng2UtilsModule() {\n\t\t\t    }\n\t\t\t    Ng2UtilsModule = __decorate([\n\t\t\t        core_1.NgModule({\n\t\t\t            declarations: [\n\t\t\t                scroll_to_1.scrollTo,\n\t\t\t                element_visible_1.elementVisible,\n\t\t\t                computed_style_1.computedStyle,\n\t\t\t                outer_width_1.outerWidth,\n\t\t\t                outer_height_1.outerHeight\n\t\t\t            ],\n\t\t\t            exports: [\n\t\t\t                scroll_to_1.scrollTo,\n\t\t\t                element_visible_1.elementVisible,\n\t\t\t                computed_style_1.computedStyle,\n\t\t\t                outer_width_1.outerWidth,\n\t\t\t                outer_height_1.outerHeight\n\t\t\t            ]\n\t\t\t        }), \n\t\t\t        __metadata('design:paramtypes', [])\n\t\t\t    ], Ng2UtilsModule);\n\t\t\t    return Ng2UtilsModule;\n\t\t\t}());\n\t\t\texports.Ng2UtilsModule = Ng2UtilsModule;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 1 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\t\n\t\t/***/ },\n\t\t/* 2 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * scroll to the selector within the parent selector by scrolling 10 times within 500ms\n\t\t\t * @param selector\n\t\t\t * @param parentSelector\n\t\t\t */\n\t\t\tfunction scrollTo(selector, parentSelector) {\n\t\t\t    console.log('selector', selector, 'parentSelector', parentSelector);\n\t\t\t    var parentEl, targetEl;\n\t\t\t    targetEl = document.querySelector(selector);\n\t\t\t    if (!targetEl) {\n\t\t\t        throw \"Invalid selector \" + selector;\n\t\t\t    }\n\t\t\t    parentEl = document.querySelector(parentSelector);\n\t\t\t    if (!parentEl) {\n\t\t\t        throw \"Invalid parent selector \" + parentSelector;\n\t\t\t    }\n\t\t\t    var parentElStyle = window.getComputedStyle(parentEl);\n\t\t\t    parentEl = parentElStyle['overflow'] === 'auto' ? parentEl : document.body;\n\t\t\t    var currentScrollTop = parentEl.scrollTop;\n\t\t\t    var targetOffsetTop = targetEl.offsetTop;\n\t\t\t    if (parentEl === document.body) {\n\t\t\t        var bodyRect = document.body.getBoundingClientRect();\n\t\t\t        var targetRect = targetEl.getBoundingClientRect();\n\t\t\t        targetOffsetTop = targetRect.top - bodyRect.top;\n\t\t\t    }\n\t\t\t    var step = Math.ceil((targetOffsetTop - currentScrollTop) / 10);\n\t\t\t    (function loop(i) {\n\t\t\t        setTimeout(function main() {\n\t\t\t            parentEl.scrollTop += step;\n\t\t\t            i > 1 && loop(i - 1);\n\t\t\t        }, 50);\n\t\t\t    }(10));\n\t\t\t}\n\t\t\texports.scrollTo = scrollTo;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 3 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * Returns an element is visible within outer element\n\t\t\t * @param innerEl\n\t\t\t * @param outerEl\n\t\t\t * @param adjustment\n\t\t\t * @returns {{top: boolean, bottom: boolean, left: boolean, right: boolean}}\n\t\t\t */\n\t\t\tfunction elementVisible(innerEl, outerEl, adjustment) {\n\t\t\t    var innerRect = innerEl.getBoundingClientRect();\n\t\t\t    var bottomAdjustment = (adjustment && adjustment.bottom || 0);\n\t\t\t    if (outerEl === window) {\n\t\t\t        return {\n\t\t\t            top: innerRect.bottom - bottomAdjustment > window.innerHeight\n\t\t\t                && innerRect.top < window.innerHeight,\n\t\t\t            bottom: innerRect.bottom - bottomAdjustment > 0\n\t\t\t                && innerRect.bottom < window.innerHeight,\n\t\t\t            left: innerRect.right > window.innerWidth\n\t\t\t                && innerRect.left < window.innerWidth,\n\t\t\t            right: innerRect.right > 0\n\t\t\t                && innerRect.right < window.innerWidth\n\t\t\t        };\n\t\t\t    }\n\t\t\t    else {\n\t\t\t        var outerRect = outerEl.getBoundingClientRect();\n\t\t\t        var defaultView = (innerEl.ownerDocument || document).defaultView;\n\t\t\t        var computedStyle = defaultView.getComputedStyle(outerEl, null);\n\t\t\t        var outerRectBorderTopWidth = parseInt(computedStyle.getPropertyValue('border-top-width'), 10);\n\t\t\t        var outerRectBorderLeftWidth = parseInt(computedStyle.getPropertyValue('border-left-width'), 10);\n\t\t\t        /* top is visible or bottom is visible */\n\t\t\t        var topVisible = (innerRect.top >= outerRect.top\n\t\t\t            && innerRect.top < outerRect.bottom);\n\t\t\t        var bottomVisible = (innerRect.bottom > (outerRect.top + outerRectBorderTopWidth)\n\t\t\t            && innerRect.bottom < outerRect.bottom);\n\t\t\t        var leftVisible = (innerRect.left >= outerRect.left\n\t\t\t            && innerRect.left < outerRect.right);\n\t\t\t        var rightVisible = (innerRect.right > (outerRect.left + outerRectBorderLeftWidth)\n\t\t\t            && innerRect.right < outerRect.right);\n\t\t\t        return {\n\t\t\t            top: topVisible,\n\t\t\t            bottom: bottomVisible,\n\t\t\t            left: leftVisible,\n\t\t\t            right: rightVisible\n\t\t\t        };\n\t\t\t    }\n\t\t\t}\n\t\t\texports.elementVisible = elementVisible;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 4 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\t/**\n\t\t\t * returns coumputed style of given element\n\t\t\t * @param el\n\t\t\t * @param styleProp\n\t\t\t * @returns {any}\n\t\t\t */\n\t\t\tfunction computedStyle(el, styleProp) {\n\t\t\t    var value, defaultView = (el.ownerDocument || document).defaultView;\n\t\t\t    // W3C standard way:\n\t\t\t    if (defaultView && defaultView.getComputedStyle) {\n\t\t\t        // sanitize property name to css notation\n\t\t\t        // (hypen separated words eg. font-Size)\n\t\t\t        styleProp = styleProp.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n\t\t\t        return defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);\n\t\t\t    }\n\t\t\t    else if (el['currentStyle']) {\n\t\t\t        // sanitize property name to camelCase\n\t\t\t        styleProp = styleProp.replace(/\\-(\\w)/g, function (str, letter) {\n\t\t\t            return letter.toUpperCase();\n\t\t\t        });\n\t\t\t        value = el['currentStyle'][styleProp];\n\t\t\t        // convert other units to pixels on IE\n\t\t\t        if (/^\\d+(em|pt|%|ex)?$/i.test(value)) {\n\t\t\t            return (function (value) {\n\t\t\t                var oldLeft = el.style.left, oldRsLeft = el['runtimeStyle'].left;\n\t\t\t                el['runtimeStyle'].left = el['currentStyle'].left;\n\t\t\t                el.style.left = value || 0;\n\t\t\t                value = el.style['pixelLeft'] + \"px\";\n\t\t\t                el.style.left = oldLeft;\n\t\t\t                el['runtimeStyle'].left = oldRsLeft;\n\t\t\t                return value;\n\t\t\t            })(value);\n\t\t\t        }\n\t\t\t        return value;\n\t\t\t    }\n\t\t\t}\n\t\t\texports.computedStyle = computedStyle;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 5 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tfunction outerWidth(el) {\n\t\t\t    var style = getComputedStyle(el);\n\t\t\t    return el.offsetWidth +\n\t\t\t        parseInt(style.getPropertyValue('margin-left')) +\n\t\t\t        parseInt(style.getPropertyValue('margin-right'));\n\t\t\t}\n\t\t\texports.outerWidth = outerWidth;\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 6 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t\"use strict\";\n\t\t\tfunction outerHeight(el) {\n\t\t\t    var style = getComputedStyle(el);\n\t\t\t    return el.offsetHeight +\n\t\t\t        parseInt(style.getPropertyValue('margin-top')) +\n\t\t\t        parseInt(style.getPropertyValue('margin-bottom'));\n\t\t\t}\n\t\t\texports.outerHeight = outerHeight;\n\t\t\n\t\t\n\t\t/***/ }\n\t\t/******/ ])\n\t\t});\n\t\t;\n\t\t//# sourceMappingURL=ng2-utils.umd.js.map\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-scrollable.umd.js.map\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory(__webpack_require__(1), __webpack_require__(2), __webpack_require__(3));\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine([\"@angular/core\", \"@angular/forms\", \"@angular/platform-browser\"], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"ng2-ui-sortable\"] = factory(require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@angular/platform-browser\"));\n\t\telse\n\t\t\troot[\"ng2-ui-sortable\"] = factory(root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@angular/platform-browser\"]);\n\t})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar forms_1 = __webpack_require__(2);\n\t\tvar platform_browser_1 = __webpack_require__(3);\n\t\tvar ng2_sortable_directive_1 = __webpack_require__(4);\n\t\texports.Ng2SortableDirective = ng2_sortable_directive_1.Ng2SortableDirective;\n\t\tvar Ng2SortableModule = (function () {\n\t\t    function Ng2SortableModule() {\n\t\t    }\n\t\t    Ng2SortableModule = __decorate([\n\t\t        core_1.NgModule({\n\t\t            imports: [platform_browser_1.BrowserModule, forms_1.FormsModule],\n\t\t            declarations: [ng2_sortable_directive_1.Ng2SortableDirective],\n\t\t            exports: [ng2_sortable_directive_1.Ng2SortableDirective]\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [])\n\t\t    ], Ng2SortableModule);\n\t\t    return Ng2SortableModule;\n\t\t}());\n\t\texports.Ng2SortableModule = Ng2SortableModule;\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\t\n\t/***/ },\n\t/* 3 */\n\t/***/ function(module, exports) {\n\t\n\t\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_3__;\n\t\n\t/***/ },\n\t/* 4 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t\"use strict\";\n\t\tvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n\t\t    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n\t\t    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n\t\t    return c > 3 && r && Object.defineProperty(target, key, r), r;\n\t\t};\n\t\tvar __metadata = (this && this.__metadata) || function (k, v) {\n\t\t    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n\t\t};\n\t\tvar core_1 = __webpack_require__(1);\n\t\tvar Ng2SortableDirective = (function () {\n\t\t    function Ng2SortableDirective(viewContainerRef) {\n\t\t        var _this = this;\n\t\t        this.viewContainerRef = viewContainerRef;\n\t\t        this.orderChanged = new core_1.EventEmitter();\n\t\t        this.dragStartHandler = function (event) {\n\t\t            //console.log('dragStartHandler');\n\t\t            _this.draggingEl = event.target;\n\t\t            Object.assign(_this.draggingEl.style, {\n\t\t                zIndex: 3,\n\t\t                pointerEvents: 'none'\n\t\t            });\n\t\t        };\n\t\t        this.dragHandler = function (event) {\n\t\t            //console.log('dragHandler');\n\t\t            Object.assign(_this.draggingEl.style, {\n\t\t                transform: 'translate(0px,' + event.deltaY + 'px)'\n\t\t            });\n\t\t            var newElDragEnter = document.elementFromPoint(event.center.x, event.center.y);\n\t\t            if (_this.elDragEnter !== newElDragEnter) {\n\t\t                if (_this.elDragEnter) {\n\t\t                    _this.elDragEnter.className = _this.elDragEnter.className.replace(/\\ drag-enter/g, '');\n\t\t                }\n\t\t                _this.elDragEnter = newElDragEnter;\n\t\t                if (newElDragEnter.tagName === 'LI') {\n\t\t                    newElDragEnter.className += ' drag-enter';\n\t\t                }\n\t\t            }\n\t\t        };\n\t\t        this.dragEndHandler = function (event) {\n\t\t            //console.log('dragEndHandler');\n\t\t            Object.assign(_this.draggingEl.style, {\n\t\t                transform: 'translate(0,0)',\n\t\t                zIndex: 1,\n\t\t                pointerEvents: 'inherit'\n\t\t            });\n\t\t            // remove class and drop the element\n\t\t            if (_this.elDragEnter) {\n\t\t                _this.elDragEnter.className = _this.elDragEnter.className.replace(/\\ drag-enter/g, '');\n\t\t                _this.elDragEnter.parentNode.insertBefore(_this.draggingEl, _this.elDragEnter);\n\t\t                _this.emitOrderChanged();\n\t\t            }\n\t\t        };\n\t\t        this.ulEl = this.viewContainerRef.element.nativeElement;\n\t\t    }\n\t\t    Ng2SortableDirective.prototype.ngAfterViewInit = function () {\n\t\t        this.liEls = this.ulEl.querySelectorAll('li');\n\t\t        for (var i = 0; i < this.liEls.length; i++) {\n\t\t            var liEl = this.liEls[i];\n\t\t            // create a simple instance by default, it only adds horizontal recognizers\n\t\t            var mc = new Hammer(liEl);\n\t\t            // let the pan gesture support all directions.\n\t\t            // this will block the vertical scrolling on a touch-device while on the element\n\t\t            mc.get('pan').set({ direction: Hammer.DIRECTION_ALL });\n\t\t            mc.on('panstart', this.dragStartHandler);\n\t\t            mc.on('panup pandown', this.dragHandler);\n\t\t            mc.on('panend', this.dragEndHandler);\n\t\t            this.emitOrderChanged();\n\t\t        }\n\t\t    };\n\t\t    Ng2SortableDirective.prototype.emitOrderChanged = function () {\n\t\t        var liEls = this.ulEl.querySelectorAll('li');\n\t\t        var orders = Array.prototype.slice.call(liEls).map(function (el) { return el.id; });\n\t\t        this.orderChanged.emit(orders);\n\t\t    };\n\t\t    __decorate([\n\t\t        // order of LI ids\n\t\t        core_1.Output(), \n\t\t        __metadata('design:type', Object)\n\t\t    ], Ng2SortableDirective.prototype, \"orderChanged\", void 0);\n\t\t    Ng2SortableDirective = __decorate([\n\t\t        core_1.Directive({\n\t\t            selector: '[ng2-sortable]'\n\t\t        }), \n\t\t        __metadata('design:paramtypes', [core_1.ViewContainerRef])\n\t\t    ], Ng2SortableDirective);\n\t\t    return Ng2SortableDirective;\n\t\t}());\n\t\texports.Ng2SortableDirective = Ng2SortableDirective;\n\t\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=ng2-ui-sortable.umd.js.map\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=ng2-ui.umd.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L25nMi11aS9kaXN0L25nMi11aS51bWQuanM/YTc1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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cUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEIsRUFBRTtBQUN4RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQyxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixRQUFRO0FBQ1I7QUFDQTs7O0FBR0EsU0FBUztBQUNU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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EiLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvaHR0cFwiKSwgcmVxdWlyZShcInJ4anMvUnhcIiksIHJlcXVpcmUoXCJyeGpzL1N1YmplY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiLCBcIkBhbmd1bGFyL2Zvcm1zXCIsIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiLCBcIkBhbmd1bGFyL2NvbW1vblwiLCBcIkBhbmd1bGFyL2h0dHBcIiwgXCJyeGpzL1J4XCIsIFwicnhqcy9TdWJqZWN0XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIm5nMi11aVwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKSwgcmVxdWlyZShcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIiksIHJlcXVpcmUoXCJAYW5ndWxhci9odHRwXCIpLCByZXF1aXJlKFwicnhqcy9SeFwiKSwgcmVxdWlyZShcInJ4anMvU3ViamVjdFwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wibmcyLXVpXCJdID0gZmFjdG9yeShyb290W1wiQGFuZ3VsYXIvY29yZVwiXSwgcm9vdFtcIkBhbmd1bGFyL2Zvcm1zXCJdLCByb290W1wiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSwgcm9vdFtcIkBhbmd1bGFyL2NvbW1vblwiXSwgcm9vdFtcIkBhbmd1bGFyL2h0dHBcIl0sIHJvb3RbXCJyeGpzL1J4XCJdLCByb290W1wicnhqcy9TdWJqZWN0XCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0fTtcblx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdH07XG5cdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHR2YXIgZm9ybXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdHZhciBwbGF0Zm9ybV9icm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHR2YXIgbmcyX292ZXJsYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdGV4cG9ydHMuT3ZlcmxheU1hbmFnZXIgPSBuZzJfb3ZlcmxheV8xLk92ZXJsYXlNYW5hZ2VyO1xuXHR2YXIgbmcyX2F1dG9fY29tcGxldGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdHZhciBuZzJfZGF0ZXRpbWVfcGlja2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblx0dmFyIG5nMl9jb2xsYXBzYWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdHZhciBuZzJfaW5maW5pdGVfbGlzdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdHZhciBuZzJfbWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblx0ZXhwb3J0cy5OZzJNYXBDb21wb25lbnQgPSBuZzJfbWFwXzEuTmcyTWFwQ29tcG9uZW50O1xuXHR2YXIgbmcyX21lbnVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHR2YXIgbmcyX3BhcmFsbGF4X3Njcm9sbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdHZhciBuZzJfcG9wdXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xuXHRleHBvcnRzLk5nMk1lc3NhZ2VQb3B1cENvbXBvbmVudCA9IG5nMl9wb3B1cF8xLk5nMk1lc3NhZ2VQb3B1cENvbXBvbmVudDtcblx0ZXhwb3J0cy5OZzJQb3B1cENvbXBvbmVudCA9IG5nMl9wb3B1cF8xLk5nMlBvcHVwQ29tcG9uZW50O1xuXHR2YXIgbmcyX3N0aWNreV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cdHZhciBuZzJfdGFiXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblx0dmFyIG5nMl90b29sdGlwX292ZXJsYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXHR2YXIgbmcyX3Njcm9sbGFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXHRleHBvcnRzLk5nMlNjcm9sbGFibGVEaXJlY3RpdmUgPSBuZzJfc2Nyb2xsYWJsZV8xLk5nMlNjcm9sbGFibGVEaXJlY3RpdmU7XG5cdHZhciBuZzJfdWlfc29ydGFibGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXHR2YXIgTmcyVUlNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gTmcyVUlNb2R1bGUoKSB7XG5cdCAgICB9XG5cdCAgICBOZzJVSU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHQgICAgICAgIGNvcmVfMS5OZ01vZHVsZSh7XG5cdCAgICAgICAgICAgIGltcG9ydHM6IFtwbGF0Zm9ybV9icm93c2VyXzEuQnJvd3Nlck1vZHVsZSwgZm9ybXNfMS5Gb3Jtc01vZHVsZV0sXG5cdCAgICAgICAgICAgIGV4cG9ydHM6IFtcblx0ICAgICAgICAgICAgICAgIG5nMl9hdXRvX2NvbXBsZXRlXzEuTmcyQXV0b0NvbXBsZXRlTW9kdWxlLFxuXHQgICAgICAgICAgICAgICAgbmcyX2RhdGV0aW1lX3BpY2tlcl8xLk5nMkRhdGV0aW1lUGlja2VyTW9kdWxlLFxuXHQgICAgICAgICAgICAgICAgbmcyX2NvbGxhcHNhYmxlXzEuTmcyQ29sbGFwc2FibGVNb2R1bGUsXG5cdCAgICAgICAgICAgICAgICBuZzJfaW5maW5pdGVfbGlzdF8xLk5nMkluZmluaXRlTGlzdE1vZHVsZSxcblx0ICAgICAgICAgICAgICAgIG5nMl9tYXBfMS5OZzJNYXBNb2R1bGUsXG5cdCAgICAgICAgICAgICAgICBuZzJfbWVudV8xLk5nMk1lbnVNb2R1bGUsXG5cdCAgICAgICAgICAgICAgICBuZzJfcGFyYWxsYXhfc2Nyb2xsXzEuTmcyUGFyYWxsYXhTY3JvbGxNb2R1bGUsXG5cdCAgICAgICAgICAgICAgICBuZzJfcG9wdXBfMS5OZzJQb3B1cE1vZHVsZSxcblx0ICAgICAgICAgICAgICAgIG5nMl9zdGlja3lfMS5OZzJTdGlja3lNb2R1bGUsXG5cdCAgICAgICAgICAgICAgICBuZzJfdGFiXzEuTmcyVGFiTW9kdWxlLFxuXHQgICAgICAgICAgICAgICAgbmcyX3Njcm9sbGFibGVfMS5OZzJTY3JvbGxhYmxlTW9kdWxlLFxuXHQgICAgICAgICAgICAgICAgbmcyX3Rvb2x0aXBfb3ZlcmxheV8xLk5nMlRvb2x0aXBPdmVybGF5TW9kdWxlLFxuXHQgICAgICAgICAgICAgICAgbmcyX292ZXJsYXlfMS5OZzJPdmVybGF5TW9kdWxlLFxuXHQgICAgICAgICAgICAgICAgbmcyX3VpX3NvcnRhYmxlXzEuTmcyU29ydGFibGVNb2R1bGVcblx0ICAgICAgICAgICAgXSxcblx0ICAgICAgICAgICAgcHJvdmlkZXJzOiBbbmcyX292ZXJsYXlfMS5PdmVybGF5TWFuYWdlcl1cblx0ICAgICAgICB9KSwgXG5cdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0ICAgIF0sIE5nMlVJTW9kdWxlKTtcblx0ICAgIHJldHVybiBOZzJVSU1vZHVsZTtcblx0fSgpKTtcblx0ZXhwb3J0cy5OZzJVSU1vZHVsZSA9IE5nMlVJTW9kdWxlO1xuXG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRcdGlmKHRydWUpXG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiLCBcIkBhbmd1bGFyL2Zvcm1zXCIsIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSwgZmFjdG9yeSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0XHRleHBvcnRzW1wibmcyLW92ZXJsYXlcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIpKTtcblx0XHRlbHNlXG5cdFx0XHRyb290W1wibmcyLW92ZXJsYXlcIl0gPSBmYWN0b3J5KHJvb3RbXCJAYW5ndWxhci9jb3JlXCJdLCByb290W1wiQGFuZ3VsYXIvZm9ybXNcIl0sIHJvb3RbXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCJdKTtcblx0fSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xuXHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHQvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdC8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcblx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQvKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcblx0LyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuXHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdC8qKioqKiovIFx0XHR9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0LyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0LyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0LyoqKioqKi8gXHR9XG5cdC8qKioqKiovXG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5cdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdC8qKioqKiovIH0pXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKiovIChbXG5cdC8qIDAgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgZm9ybXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFx0dmFyIHBsYXRmb3JtX2Jyb3dzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFx0dmFyIG92ZXJsYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0ZXhwb3J0cy5PdmVybGF5ID0gb3ZlcmxheV8xLk92ZXJsYXk7XG5cdFx0dmFyIG92ZXJsYXlfbWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XHRleHBvcnRzLk92ZXJsYXlNYW5hZ2VyID0gb3ZlcmxheV9tYW5hZ2VyXzEuT3ZlcmxheU1hbmFnZXI7XG5cdFx0dmFyIG92ZXJsYXlfZGlyZWN0aXZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcdGV4cG9ydHMuT3ZlcmxheURpcmVjdGl2ZSA9IG92ZXJsYXlfZGlyZWN0aXZlXzEuT3ZlcmxheURpcmVjdGl2ZTtcblx0XHR2YXIgTmcyT3ZlcmxheU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMk92ZXJsYXlNb2R1bGUoKSB7XG5cdFx0ICAgIH1cblx0XHQgICAgTmcyT3ZlcmxheU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHQgICAgICAgICAgICBpbXBvcnRzOiBbcGxhdGZvcm1fYnJvd3Nlcl8xLkJyb3dzZXJNb2R1bGUsIGZvcm1zXzEuRm9ybXNNb2R1bGVdLFxuXHRcdCAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW292ZXJsYXlfZGlyZWN0aXZlXzEuT3ZlcmxheURpcmVjdGl2ZV0sXG5cdFx0ICAgICAgICAgICAgcHJvdmlkZXJzOiBbb3ZlcmxheV9tYW5hZ2VyXzEuT3ZlcmxheU1hbmFnZXJdLFxuXHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtvdmVybGF5X2RpcmVjdGl2ZV8xLk92ZXJsYXlEaXJlY3RpdmVdXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBOZzJPdmVybGF5TW9kdWxlKTtcblx0XHQgICAgcmV0dXJuIE5nMk92ZXJsYXlNb2R1bGU7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMk92ZXJsYXlNb2R1bGUgPSBOZzJPdmVybGF5TW9kdWxlO1xuXHRcdDtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAxICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogMiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDMgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA0ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XHR2YXIgT3ZlcmxheSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE92ZXJsYXkoZWwsIG9wdGlvbnMpIHtcblx0XHQgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdCAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG5cdFx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdFx0ICAgICAgICBpZiAoIXRoaXMuaWQpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgb3ZlcmxheSBpZFwiO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdGhpcy5lbGVtZW50ID0gZWw7IC8vIG92ZXJsYXkgd3JhcHBlciBlbGVtZW50IHdpdGggdGFibGUgZHNwbGF5XG5cdFx0ICAgICAgICB0aGlzLndpbmRvd092ZXJsYXkgPSBvcHRpb25zLndpbmRvd092ZXJsYXk7XG5cdFx0ICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvblByb3BlcnR5KG9wdGlvbnMucG9zaXRpb24gfHwgJ2NlbnRlciBjZW50ZXInKTtcblx0XHQgICAgfVxuXHRcdCAgICBPdmVybGF5LnByb3RvdHlwZS5wb3NpdGlvbkl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICAgICAgICBpZiAodGhpcy5wb3NpdGlvbi5pbnNpZGUpIHtcblx0XHQgICAgICAgICAgICB0aGlzLnBvc2l0aW9uSXRJbnNpZGUodGhpcy5wb3NpdGlvbik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICB0aGlzLnBvc2l0aW9uSXRPdXRzaWRlKHRoaXMucG9zaXRpb24sIGV2ZW50KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfTtcblx0XHQgICAgT3ZlcmxheS5wcm90b3R5cGUuZ2V0UG9zaXRpb25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChwb3NpdGlvblN0cikge1xuXHRcdCAgICAgICAgdmFyIHBvc2l0aW9uID0ge30sIGluc2lkZTtcblx0XHQgICAgICAgIHZhciBfYSA9IHBvc2l0aW9uU3RyLnNwbGl0KCcgJyksIHZlcnRpY2FsID0gX2FbMF0sIGhvcml6b250YWwgPSBfYVsxXSwgaW5zaWRlU3RyID0gX2FbMl07XG5cdFx0ICAgICAgICBob3Jpem9udGFsID0gaG9yaXpvbnRhbCB8fCAnY2VudGVyJztcblx0XHQgICAgICAgIHZlcnRpY2FsID0gdmVydGljYWwgfHwgJ2NlbnRlcic7XG5cdFx0ICAgICAgICBpbnNpZGUgPSAoaW5zaWRlU3RyICE9PSAnb3V0c2lkZScgfHwgdGhpcy53aW5kb3dPdmVybGF5KTtcblx0XHQgICAgICAgIHBvc2l0aW9uLmhvcml6b250YWwgPSBPdmVybGF5W2hvcml6b250YWwudG9VcHBlckNhc2UoKV07XG5cdFx0ICAgICAgICBwb3NpdGlvbi52ZXJ0aWNhbCA9IE92ZXJsYXlbdmVydGljYWwudG9VcHBlckNhc2UoKV07XG5cdFx0ICAgICAgICBwb3NpdGlvbi5pbnNpZGUgPSBpbnNpZGU7XG5cdFx0ICAgICAgICByZXR1cm4gcG9zaXRpb247XG5cdFx0ICAgIH07XG5cdFx0ICAgIE92ZXJsYXkucHJvdG90eXBlLnBvc2l0aW9uSXRJbnNpZGUgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcblx0XHQgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuXHRcdCAgICAgICAgLy90b3AgLyBsZWZ0IHBvc2l0aW9uaW5nXG5cdFx0ICAgICAgICBpZiAodGhpcy53aW5kb3dPdmVybGF5KSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcblx0XHQgICAgICAgICAgICAvL3dvcmtzIGFzIGJsb2NrZXJcblx0XHQgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZWxlbWVudC5zdHlsZSwge1xuXHRcdCAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMiknLFxuXHRcdCAgICAgICAgICAgICAgICB0b3A6ICcwJywgbGVmdDogJzAnLCBib3R0b206ICcwJywgcmlnaHQ6ICcwJyxcblx0XHQgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSdcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIC8vYWRqdXN0IHRvcC9sZWZ0IHRvIG1hdGNoIHRvIHBhcmVudEVsZW1lbnRcblx0XHQgICAgICAgICAgICB2YXIgcGFyZW50RWwgPSB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHQgICAgICAgICAgICAvL3dvcmtzIGFzIGEgYmxvY2tlclxuXHRcdCAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5lbGVtZW50LnN0eWxlLCB7XG5cdFx0ICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdCAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG5cdFx0ICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC4yKScsXG5cdFx0ICAgICAgICAgICAgICAgIHRvcDogcGFyZW50RWwub2Zmc2V0VG9wICsgJ3B4Jyxcblx0XHQgICAgICAgICAgICAgICAgbGVmdDogcGFyZW50RWwub2Zmc2V0TGVmdCArICdweCcsXG5cdFx0ICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJlbnRFbC5vZmZzZXRXaWR0aCArICdweCcsXG5cdFx0ICAgICAgICAgICAgICAgIGhlaWdodDogcGFyZW50RWwub2Zmc2V0SGVpZ2h0ICsgJ3B4J1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgO1xuXHRcdCAgICAgICAgLy9ob3Jpem9udGFsIHBvc2l0aW9uXG5cdFx0ICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uLmhvcml6b250YWwpIHtcblx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuTEVGVDpcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuXHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuQ0VOVEVSOlxuXHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnY2VudGVyJztcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlJJR0hUOlxuXHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnO1xuXHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vdmVydGljYWwgcG9zaXRpb25cblx0XHQgICAgICAgIHN3aXRjaCAocG9zaXRpb24udmVydGljYWwpIHtcblx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuTEVGVDpcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmFsaWduSXRlbXMgPSAnZmxleC1zdGFydCc7XG5cdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5DRU5URVI6XG5cdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5Lk1JRERMRTpcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmFsaWduSXRlbXMgPSAnY2VudGVyJztcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlJJR0hUOlxuXHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYWxpZ25JdGVtcyA9ICdmbGV4LWVuZCc7XG5cdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBPdmVybGF5LnByb3RvdHlwZS5wb3NpdGlvbkl0T3V0c2lkZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgZXZlbnQpIHtcblx0XHQgICAgICAgIC8vYWRqdXN0IHRvcC9sZWZ0IHRvIG1hdGNoIHRvIHBhcmVudEVsZW1lbnRcblx0XHQgICAgICAgIHZhciBwYXJlbnRFbCA9IHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdCAgICAgICAgLy93b3JrcyBhcyBndWlkZSBsaW5lP1xuXHRcdCAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmVsZW1lbnQuc3R5bGUsIHtcblx0XHQgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHQgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG5cdFx0ICAgICAgICAgICAgdG9wOiBwYXJlbnRFbC5vZmZzZXRUb3AgKyAncHgnLFxuXHRcdCAgICAgICAgICAgIGxlZnQ6IHBhcmVudEVsLm9mZnNldExlZnQgKyAncHgnLFxuXHRcdCAgICAgICAgICAgIHdpZHRoOiBwYXJlbnRFbC5vZmZzZXRXaWR0aCArICdweCcsXG5cdFx0ICAgICAgICAgICAgaGVpZ2h0OiBwYXJlbnRFbC5vZmZzZXRIZWlnaHQgKyAncHgnXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHQgICAgICAgIHZhciBlbFRvUG9zaXRpb24gPSAodGhpcy5lbGVtZW50LmNoaWxkcmVuWzBdKTtcblx0XHQgICAgICAgIGVsVG9Qb3NpdGlvbi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0ICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcblx0XHQgICAgICAgIHN3aXRjaCAocG9zaXRpb24udmVydGljYWwpIHtcblx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuVE9QOlxuXHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUuYm90dG9tID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCArICdweCc7XG5cdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5CT1RUT006XG5cdFx0ICAgICAgICAgICAgICAgIGVsVG9Qb3NpdGlvbi5zdHlsZS50b3AgPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgJ3B4Jztcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkxFRlQ6XG5cdFx0ICAgICAgICAgICAgICAgIGVsVG9Qb3NpdGlvbi5zdHlsZS5yaWdodCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCArICdweCc7XG5cdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5SSUdIVDpcblx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGggKyAncHgnO1xuXHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHN3aXRjaCAocG9zaXRpb24uaG9yaXpvbnRhbCkge1xuXHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5DRU5URVI6XG5cdFx0ICAgICAgICAgICAgICAgIGVsVG9Qb3NpdGlvbi5zdHlsZS5sZWZ0ID0gKHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsVG9Qb3NpdGlvbi5vZmZzZXRXaWR0aCkgLyAyICsgJ3B4Jztcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkxFRlQ6XG5cdFx0ICAgICAgICAgICAgICAgIGVsVG9Qb3NpdGlvbi5zdHlsZS5sZWZ0ID0gJzAnO1xuXHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuUklHSFQ6XG5cdFx0ICAgICAgICAgICAgICAgIGVsVG9Qb3NpdGlvbi5zdHlsZS5yaWdodCA9ICcwJztcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlRPUDpcblx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLnRvcCA9ICcwJztcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkJPVFRPTTpcblx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmJvdHRvbSA9ICcwJztcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkNVUlNPUjpcblx0XHQgICAgICAgICAgICAgICAgdmFyIG1vdXNlUG9zID0gdXRpbF8xLlV0aWwuZ2V0TW91c2VQb3NpdGlvbkluRWxlbWVudChldmVudCwgdGhpcy5lbGVtZW50KTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKChtb3VzZVBvcy54ICsgZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoKSA+IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSAodGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoIC0gNSkgKyAncHgnO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdXNlUG9zLnggPCBlbFRvUG9zaXRpb24ub2Zmc2V0V2lkdGggLyAyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUubGVmdCA9ICcwcHgnO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSBtb3VzZVBvcy54IC0gZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoIC8gMiArICdweCc7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH07XG5cdFx0ICAgIE92ZXJsYXkuVE9QID0gMTE7XG5cdFx0ICAgIE92ZXJsYXkuTUlERExFID0gMTI7XG5cdFx0ICAgIE92ZXJsYXkuQk9UVE9NID0gMTM7XG5cdFx0ICAgIE92ZXJsYXkuTEVGVCA9IDIxO1xuXHRcdCAgICBPdmVybGF5LkNFTlRFUiA9IDIyO1xuXHRcdCAgICBPdmVybGF5LlJJR0hUID0gMjM7XG5cdFx0ICAgIE92ZXJsYXkuQ1VSU09SID0gMzE7XG5cdFx0ICAgIHJldHVybiBPdmVybGF5O1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5PdmVybGF5ID0gT3ZlcmxheTtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA1ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgVXRpbCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIFV0aWwoKSB7XG5cdFx0ICAgIH1cblx0XHQgICAgVXRpbC5nZXREb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG9FbGVtZW50KSB7XG5cdFx0ICAgICAgICB2YXIgcG9zWCA9IDAsIHBvc1kgPSAwO1xuXHRcdCAgICAgICAgaWYgKG9FbGVtZW50Lm9mZnNldFBhcmVudCkge1xuXHRcdCAgICAgICAgICAgIGZvciAoOyBvRWxlbWVudDsgb0VsZW1lbnQgPSBvRWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcblx0XHQgICAgICAgICAgICAgICAgcG9zWCArPSBvRWxlbWVudC5vZmZzZXRMZWZ0O1xuXHRcdCAgICAgICAgICAgICAgICBwb3NZICs9IG9FbGVtZW50Lm9mZnNldFRvcDtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHsgeDogcG9zWCwgeTogcG9zWSB9O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHsgeDogb0VsZW1lbnRbJ3gnXSwgeTogb0VsZW1lbnRbJ3knXSB9O1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBVdGlsLmdldE1vdXNlUG9zaXRpb25JbkVsZW1lbnQgPSBmdW5jdGlvbiAoZXZ0LCBlbGVtZW50KSB7XG5cdFx0ICAgICAgICBldnQgPSBldnQgfHwgd2luZG93LmV2ZW50O1xuXHRcdCAgICAgICAgdmFyIHBvc1ggPSAwLCBwb3NZID0gMDtcblx0XHQgICAgICAgIHZhciBlbFBvcyA9IHRoaXMuZ2V0RG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KTtcblx0XHQgICAgICAgIGlmIChldnQucGFnZVggfHwgZXZ0LnBhZ2VZKSB7XG5cdFx0ICAgICAgICAgICAgcG9zWCA9IGV2dC5wYWdlWDtcblx0XHQgICAgICAgICAgICBwb3NZID0gZXZ0LnBhZ2VZO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSBpZiAoZXZ0LmNsaWVudFggfHwgZXZ0LmNsaWVudFkpIHtcblx0XHQgICAgICAgICAgICBwb3NYID0gZXZ0LmNsaWVudFggK1xuXHRcdCAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgK1xuXHRcdCAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcblx0XHQgICAgICAgICAgICBwb3NZID0gZXZ0LmNsaWVudFkgK1xuXHRcdCAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArXG5cdFx0ICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICAgICAgICAgIHg6IHBvc1ggLSBlbFBvcy54LFxuXHRcdCAgICAgICAgICAgIHk6IHBvc1kgLSBlbFBvcy55XG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICB9O1xuXHRcdCAgICByZXR1cm4gVXRpbDtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuVXRpbCA9IFV0aWw7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBPdmVybGF5TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE92ZXJsYXlNYW5hZ2VyKCkge1xuXHRcdCAgICB9XG5cdFx0ICAgIE92ZXJsYXlNYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChvdmVybGF5KSB7XG5cdFx0ICAgICAgICBPdmVybGF5TWFuYWdlci5vdmVybGF5c1tvdmVybGF5LmlkXSA9IG92ZXJsYXk7XG5cdFx0ICAgICAgICAvLyBjb25zb2xlLmxvZygnb3ZlcmxheS5yZWdpc3RlciwgT3ZlcmxheU1hbmFnZXIub3ZlcmxheXMnLCBPdmVybGF5TWFuYWdlci5vdmVybGF5cyk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE92ZXJsYXlNYW5hZ2VyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGFyZywgZXZlbnQpIHtcblx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBPdmVybGF5TWFuYWdlci5vdmVybGF5c1thcmddIDogYXJnO1xuXHRcdCAgICAgICAgaWYgKCFvdmVybGF5Lm9wZW5lZCkge1xuXHRcdCAgICAgICAgICAgIG92ZXJsYXkucG9zaXRpb25JdChldmVudCk7XG5cdFx0ICAgICAgICAgICAgb3ZlcmxheS5vcGVuZWQgPSB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBPdmVybGF5TWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdFx0ICAgICAgICB2YXIgb3ZlcmxheSA9IHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnID8gT3ZlcmxheU1hbmFnZXIub3ZlcmxheXNbYXJnXSA6IGFyZztcblx0XHQgICAgICAgIG92ZXJsYXkuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdCAgICAgICAgb3ZlcmxheS5vcGVuZWQgPSBmYWxzZTtcblx0XHQgICAgfTtcblx0XHQgICAgLy9saXN0IG9mIG92ZXJsYXkgb2JqZWN0c1xuXHRcdCAgICBPdmVybGF5TWFuYWdlci5vdmVybGF5cyA9IHt9O1xuXHRcdCAgICBPdmVybGF5TWFuYWdlciA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkluamVjdGFibGUoKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBPdmVybGF5TWFuYWdlcik7XG5cdFx0ICAgIHJldHVybiBPdmVybGF5TWFuYWdlcjtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuT3ZlcmxheU1hbmFnZXIgPSBPdmVybGF5TWFuYWdlcjtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA3ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIG92ZXJsYXlfbWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XHR2YXIgb3ZlcmxheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XHR2YXIgT3ZlcmxheURpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE92ZXJsYXlEaXJlY3RpdmUodmlld0NvbnRhaW5lclJlZiwgb3ZlcmxheU1hbmFnZXIpIHtcblx0XHQgICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG5cdFx0ICAgICAgICB0aGlzLm92ZXJsYXlNYW5hZ2VyID0gb3ZlcmxheU1hbmFnZXI7XG5cdFx0ICAgICAgICB0aGlzLmVsID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcblx0XHQgICAgfVxuXHRcdCAgICBPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB0aGlzLndyYXBJdFdpdGhPdmVybGF5VGFnKCk7XG5cdFx0ICAgICAgICB0aGlzLnJlZ2lzdGVyVG9PdmVybGF5TWFuYWdlcigpO1xuXHRcdCAgICB9O1xuXHRcdCAgICBPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS53cmFwSXRXaXRoT3ZlcmxheVRhZyA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIC8vY29uc29sZS5sb2coJ3dyYXBwZWQgb3ZlcmxheSBkaXJlY3RpdmUgZWxlbWVudCB3aXRoIDxuZzItb3ZlcmxheT4nKTtcblx0XHQgICAgICAgIHRoaXMub3ZlcmxheUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmcyLW92ZXJsYXknKTtcblx0XHQgICAgICAgIHRoaXMub3ZlcmxheUVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0ICAgICAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMub3ZlcmxheUVsLCB0aGlzLmVsLm5leHRTaWJsaW5nKTtcblx0XHQgICAgICAgIHRoaXMub3ZlcmxheUVsLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuXHRcdCAgICB9O1xuXHRcdCAgICAvL2NyZWF0ZSBPdmVybGF5IG9iamVjdCwgIHRoZW4gcmVnaXN0ZXIgdGhpcyBlbGVtZW50IHRvIG92ZXJsYXlNYW5hZ2VyXG5cdFx0ICAgIE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLnJlZ2lzdGVyVG9PdmVybGF5TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHZhciBwb3NpdGlvblN0ciA9IHRoaXMub3ZlcmxheVBvc2l0aW9uO1xuXHRcdCAgICAgICAgdmFyIG92ZXJsYXkgPSBuZXcgb3ZlcmxheV8xLk92ZXJsYXkodGhpcy5vdmVybGF5RWwsIHtcblx0XHQgICAgICAgICAgICBpZDogdGhpcy5lbC5pZCxcblx0XHQgICAgICAgICAgICB3aW5kb3dPdmVybGF5OiB0aGlzLm92ZXJsYXlPZiA9PSBcIndpbmRvd1wiLFxuXHRcdCAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvblN0clxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICAvL2NvbnNvbGUubG9nKCdyZWdpc3RlcmluZyBvdmVybGF5Jywgb3ZlcmxheSk7XG5cdFx0ICAgICAgICB0aGlzLm92ZXJsYXlNYW5hZ2VyLnJlZ2lzdGVyKG92ZXJsYXkpO1xuXHRcdCAgICB9O1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dCgnbmcyLW92ZXJsYXktb2YnKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3ZlcmxheU9mXCIsIHZvaWQgMCk7XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KCduZzItb3ZlcmxheS1wb3NpdGlvbicpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuXHRcdCAgICBdLCBPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvdmVybGF5UG9zaXRpb25cIiwgdm9pZCAwKTtcblx0XHQgICAgT3ZlcmxheURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkRpcmVjdGl2ZSh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmcyLW92ZXJsYXldLCBbbmcyLW92ZXJsYXktb2ZdLCBbbmcyLW92ZXJsYXktcG9zaXRpb25dJyxcblx0XHQgICAgICAgIH0pLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2NvcmVfMS5WaWV3Q29udGFpbmVyUmVmLCBvdmVybGF5X21hbmFnZXJfMS5PdmVybGF5TWFuYWdlcl0pXG5cdFx0ICAgIF0sIE92ZXJsYXlEaXJlY3RpdmUpO1xuXHRcdCAgICByZXR1cm4gT3ZlcmxheURpcmVjdGl2ZTtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuT3ZlcmxheURpcmVjdGl2ZSA9IE92ZXJsYXlEaXJlY3RpdmU7XG5cdFxuXHRcblx0LyoqKi8gfVxuXHQvKioqKioqLyBdKVxuXHR9KTtcblx0O1xuXHQvLyMgc291cmNlTWFwcGluZ1VSTD1uZzItb3ZlcmxheS51bWQuanMubWFwXG5cbi8qKiovIH0sXG4vKiA1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRcdGlmKHRydWUpXG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg4KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiLCBcIkBhbmd1bGFyL2Zvcm1zXCIsIFwiQGFuZ3VsYXIvY29tbW9uXCIsIFwiQGFuZ3VsYXIvaHR0cFwiLCBcInJ4anMvUnhcIiwgXCJyeGpzL1N1YmplY3RcIl0sIGZhY3RvcnkpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdFx0ZXhwb3J0c1tcIm5nMi1hdXRvLWNvbXBsZXRlXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKSwgcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvaHR0cFwiKSwgcmVxdWlyZShcInJ4anMvUnhcIiksIHJlcXVpcmUoXCJyeGpzL1N1YmplY3RcIikpO1xuXHRcdGVsc2Vcblx0XHRcdHJvb3RbXCJuZzItYXV0by1jb21wbGV0ZVwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9mb3Jtc1wiXSwgcm9vdFtcIkBhbmd1bGFyL2NvbW1vblwiXSwgcm9vdFtcIkBhbmd1bGFyL2h0dHBcIl0sIHJvb3RbXCJyeGpzL1J4XCJdLCByb290W1wicnhqcy9TdWJqZWN0XCJdKTtcblx0fSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV81X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXykge1xuXHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHQvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdC8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcblx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQvKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcblx0LyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuXHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdC8qKioqKiovIFx0XHR9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0LyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0LyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0LyoqKioqKi8gXHR9XG5cdC8qKioqKiovXG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5cdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdC8qKioqKiovIH0pXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKiovIChbXG5cdC8qIDAgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgZm9ybXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFx0dmFyIGNvbW1vbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHR2YXIgYXV0b19jb21wbGV0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XHRleHBvcnRzLkF1dG9Db21wbGV0ZSA9IGF1dG9fY29tcGxldGVfMS5BdXRvQ29tcGxldGU7XG5cdFx0dmFyIGF1dG9fY29tcGxldGVfY29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcdGV4cG9ydHMuQXV0b0NvbXBsZXRlQ29tcG9uZW50ID0gYXV0b19jb21wbGV0ZV9jb21wb25lbnRfMS5BdXRvQ29tcGxldGVDb21wb25lbnQ7XG5cdFx0dmFyIGF1dG9fY29tcGxldGVfZGlyZWN0aXZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXHRcdGV4cG9ydHMuQXV0b0NvbXBsZXRlRGlyZWN0aXZlID0gYXV0b19jb21wbGV0ZV9kaXJlY3RpdmVfMS5BdXRvQ29tcGxldGVEaXJlY3RpdmU7XG5cdFx0dmFyIE5nMkF1dG9Db21wbGV0ZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMkF1dG9Db21wbGV0ZU1vZHVsZSgpIHtcblx0XHQgICAgfVxuXHRcdCAgICBOZzJBdXRvQ29tcGxldGVNb2R1bGUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5OZ01vZHVsZSh7XG5cdFx0ICAgICAgICAgICAgaW1wb3J0czogW2NvbW1vbl8xLkNvbW1vbk1vZHVsZSwgZm9ybXNfMS5Gb3Jtc01vZHVsZV0sXG5cdFx0ICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbYXV0b19jb21wbGV0ZV9jb21wb25lbnRfMS5BdXRvQ29tcGxldGVDb21wb25lbnQsIGF1dG9fY29tcGxldGVfZGlyZWN0aXZlXzEuQXV0b0NvbXBsZXRlRGlyZWN0aXZlXSxcblx0XHQgICAgICAgICAgICBleHBvcnRzOiBbYXV0b19jb21wbGV0ZV9jb21wb25lbnRfMS5BdXRvQ29tcGxldGVDb21wb25lbnQsIGF1dG9fY29tcGxldGVfZGlyZWN0aXZlXzEuQXV0b0NvbXBsZXRlRGlyZWN0aXZlXSxcblx0XHQgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFthdXRvX2NvbXBsZXRlX2NvbXBvbmVudF8xLkF1dG9Db21wbGV0ZUNvbXBvbmVudF0sXG5cdFx0ICAgICAgICAgICAgcHJvdmlkZXJzOiBbYXV0b19jb21wbGV0ZV8xLkF1dG9Db21wbGV0ZV1cblx0XHQgICAgICAgIH0pLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG5cdFx0ICAgIF0sIE5nMkF1dG9Db21wbGV0ZU1vZHVsZSk7XG5cdFx0ICAgIHJldHVybiBOZzJBdXRvQ29tcGxldGVNb2R1bGU7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMkF1dG9Db21wbGV0ZU1vZHVsZSA9IE5nMkF1dG9Db21wbGV0ZU1vZHVsZTtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAxICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogMiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDMgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA0ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIGh0dHBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XHQvKipcblx0XHQgKiBwcm92aWRlcyBhdXRvLWNvbXBsZXRlIHJlbGF0ZWQgdXRpbGl0eSBmdW5jdGlvbnNcblx0XHQgKi9cblx0XHR2YXIgQXV0b0NvbXBsZXRlID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gQXV0b0NvbXBsZXRlKGh0dHApIHtcblx0XHQgICAgICAgIHRoaXMuaHR0cCA9IGh0dHA7XG5cdFx0ICAgICAgICAvLyAuLi5cblx0XHQgICAgfVxuXHRcdCAgICBBdXRvQ29tcGxldGUucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChsaXN0LCBrZXl3b3JkKSB7XG5cdFx0ICAgICAgICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuICEhSlNPTi5zdHJpbmdpZnkoZWwpLm1hdGNoKG5ldyBSZWdFeHAoa2V5d29yZCwgXCJpXCIpKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9O1xuXHRcdCAgICAvKipcblx0XHQgICAgICogcmV0dXJuIHJlbW90ZSBkYXRhIGZyb20gdGhlIGdpdmVuIHNvdXJjZSBhbmQgb3B0aW9ucywgYW5kIGRhdGEgcGF0aFxuXHRcdCAgICAgKlxuXHRcdCAgICAgKiBAcGFyYW0geyp9IG9wdGlvbnMgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHF1ZXJ5IHBhcmFtdGVycyBmb3IgdGhlIEdFVCBjYWxsXG5cdFx0ICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPFJlc3BvbnNlPn1cblx0XHQgICAgICpcblx0XHQgICAgICogQG1lbWJlck9mIEF1dG9Db21wbGV0ZVxuXHRcdCAgICAgKi9cblx0XHQgICAgQXV0b0NvbXBsZXRlLnByb3RvdHlwZS5nZXRSZW1vdGVEYXRhID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICB2YXIga2V5VmFsdWVzID0gW107XG5cdFx0ICAgICAgICB2YXIgdXJsID0gXCJcIjtcblx0XHQgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdCAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGFsbCBrZXl3b3JkIHRvIHZhbHVlXG5cdFx0ICAgICAgICAgICAgICAgIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiOlwiICsga2V5LCBcImdcIik7XG5cdFx0ICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuc291cmNlO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAodXJsLm1hdGNoKHJlZ2V4cCkpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHJlZ2V4cCwgb3B0aW9uc1trZXldKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGtleVZhbHVlcy5wdXNoKGtleSArIFwiPVwiICsgb3B0aW9uc1trZXldKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChrZXlWYWx1ZXMubGVuZ3RoKSB7XG5cdFx0ICAgICAgICAgICAgdmFyIHFzID0ga2V5VmFsdWVzLmpvaW4oXCImXCIpO1xuXHRcdCAgICAgICAgICAgIHVybCArPSB1cmwubWF0Y2goL1xcP1thLXpdL2kpID8gcXMgOiAoXCI/XCIgKyBxcyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gdGhpcy5odHRwLmdldCh1cmwpXG5cdFx0ICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVzcCkgeyByZXR1cm4gcmVzcC5qc29uKCk7IH0pXG5cdFx0ICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVzcCkge1xuXHRcdCAgICAgICAgICAgIHZhciBsaXN0ID0gcmVzcC5kYXRhIHx8IHJlc3A7XG5cdFx0ICAgICAgICAgICAgaWYgKF90aGlzLnBhdGhUb0RhdGEpIHtcblx0XHQgICAgICAgICAgICAgICAgdmFyIHBhdGhzID0gX3RoaXMucGF0aFRvRGF0YS5zcGxpdChcIi5cIik7XG5cdFx0ICAgICAgICAgICAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIGxpc3QgPSBsaXN0W3Byb3BdOyB9KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfTtcblx0XHQgICAgO1xuXHRcdCAgICBBdXRvQ29tcGxldGUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKCksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbaHR0cF8xLkh0dHBdKVxuXHRcdCAgICBdLCBBdXRvQ29tcGxldGUpO1xuXHRcdCAgICByZXR1cm4gQXV0b0NvbXBsZXRlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5BdXRvQ29tcGxldGUgPSBBdXRvQ29tcGxldGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzVfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDYgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV82X187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA3ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIFN1YmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFx0dmFyIGF1dG9fY29tcGxldGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0LyoqXG5cdFx0ICogc2hvdyBhIHNlbGVjdGVkIGRhdGUgaW4gbW9udGhseSBjYWxlbmRhclxuXHRcdCAqIEVhY2ggZmlsdGVyZWRMaXN0IGl0ZW0gaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydHkgaW4gYWRkaXRpb24gdG8gZGF0YSBpdHNlbGZcblx0XHQgKiAgIDEuIGRpc3BsYXlWYWx1ZSBhcyBzdHJpbmcgZS5nLiBBbGxlbiBLaW1cblx0XHQgKiAgIDIuIGRhdGFWYWx1ZSBhcyBhbnkgZS5nLlxuXHRcdCAqL1xuXHRcdHZhciBBdXRvQ29tcGxldGVDb21wb25lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICAvKipcblx0XHQgICAgICogY29uc3RydWN0b3Jcblx0XHQgICAgICovXG5cdFx0ICAgIGZ1bmN0aW9uIEF1dG9Db21wbGV0ZUNvbXBvbmVudChlbGVtZW50UmVmLCBhdXRvQ29tcGxldGUpIHtcblx0XHQgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlID0gYXV0b0NvbXBsZXRlO1xuXHRcdCAgICAgICAgdGhpcy5taW5DaGFycyA9IDA7XG5cdFx0ICAgICAgICB0aGlzLnZhbHVlUHJvcGVydHlOYW1lID0gXCJpZFwiO1xuXHRcdCAgICAgICAgdGhpcy5kaXNwbGF5UHJvcGVydHlOYW1lID0gXCJ2YWx1ZVwiO1xuXHRcdCAgICAgICAgdGhpcy5kcm9wZG93blZpc2libGUgPSBmYWxzZTtcblx0XHQgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG5cdFx0ICAgICAgICB0aGlzLmZpbHRlcmVkTGlzdCA9IFtdO1xuXHRcdCAgICAgICAgdGhpcy5pdGVtSW5kZXggPSAwO1xuXHRcdCAgICAgICAgdGhpcy52YWx1ZVNlbGVjdGVkID0gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG5cdFx0ICAgICAgICB0aGlzLmRlbGF5ID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgICB2YXIgdGltZXIgPSAwO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2ssIG1zKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0ICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgbXMpO1xuXHRcdCAgICAgICAgICAgIH07XG5cdFx0ICAgICAgICB9KSgpO1xuXHRcdCAgICAgICAgdGhpcy5lbCA9IGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblx0XHQgICAgfVxuXHRcdCAgICBBdXRvQ29tcGxldGVDb21wb25lbnQucHJvdG90eXBlLmlzU3JjQXJyID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgcmV0dXJuICh0aGlzLnNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkFycmF5XCIpO1xuXHRcdCAgICB9O1xuXHRcdCAgICAvKipcblx0XHQgICAgICogdXNlciBlbnRlcnMgaW50byBpbnB1dCBlbCwgc2hvd3MgbGlzdCB0byBzZWxlY3QsIHRoZW4gc2VsZWN0IG9uZVxuXHRcdCAgICAgKi9cblx0XHQgICAgQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHRoaXMuaW5wdXRFbCA9ICh0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKSk7XG5cdFx0ICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZS5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcblx0XHQgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlLnBhdGhUb0RhdGEgPSB0aGlzLnBhdGhUb0RhdGE7XG5cdFx0ICAgIH07XG5cdFx0ICAgIEF1dG9Db21wbGV0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVsb2FkTGlzdEluRGVsYXkgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdmFyIGRlbGF5TXMgPSB0aGlzLmlzU3JjQXJyKCkgPyAxMCA6IDUwMDtcblx0XHQgICAgICAgIC8vIGV4ZWN1dGluZyBhZnRlciB1c2VyIHN0b3BwZWQgdHlwaW5nXG5cdFx0ICAgICAgICB0aGlzLmRlbGF5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbG9hZExpc3QoKTsgfSwgZGVsYXlNcyk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIEF1dG9Db21wbGV0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvd0Ryb3Bkb3duTGlzdCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHRoaXMua2V5d29yZCA9IFwiXCI7XG5cdFx0ICAgICAgICB0aGlzLmlucHV0RWwuZm9jdXMoKTtcblx0XHQgICAgICAgIHRoaXMucmVsb2FkTGlzdCgpO1xuXHRcdCAgICB9O1xuXHRcdCAgICBBdXRvQ29tcGxldGVDb21wb25lbnQucHJvdG90eXBlLmhpZGVEcm9wZG93bkxpc3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB0aGlzLmRyb3Bkb3duVmlzaWJsZSA9IGZhbHNlO1xuXHRcdCAgICB9O1xuXHRcdCAgICBBdXRvQ29tcGxldGVDb21wb25lbnQucHJvdG90eXBlLnJlbG9hZExpc3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdmFyIGtleXdvcmQgPSB0aGlzLmlucHV0RWwudmFsdWU7XG5cdFx0ICAgICAgICB0aGlzLmhpZGVEcm9wZG93bkxpc3QoKTtcblx0XHQgICAgICAgIHRoaXMuZHJvcGRvd25WaXNpYmxlID0gdHJ1ZTtcblx0XHQgICAgICAgIGlmICh0aGlzLmlzU3JjQXJyKCkpIHtcblx0XHQgICAgICAgICAgICAvLyBsb2NhbCBzb3VyY2UgXG5cdFx0ICAgICAgICAgICAgdGhpcy5maWx0ZXJlZExpc3QgPSB0aGlzLmF1dG9Db21wbGV0ZS5maWx0ZXIodGhpcy5zb3VyY2UsIHRoaXMua2V5d29yZCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG5cdFx0ICAgICAgICAgICAgaWYgKGtleXdvcmQubGVuZ3RoID49IHRoaXMubWluQ2hhcnMpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAvLyBjdXN0b20gZnVuY3Rpb24gdGhhdCByZXR1cm5zIG9ic2VydmFibGUgXG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZShrZXl3b3JkKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHJlc3ApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucGF0aFRvRGF0YSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGF0aHMgPSBfdGhpcy5wYXRoVG9EYXRhLnNwbGl0KFwiLlwiKTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcmVzcCA9IHJlc3BbcHJvcF07IH0pO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maWx0ZXJlZExpc3QgPSByZXNwO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBudWxsOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTsgfSAvLyBjb21wbGV0ZVxuXHRcdCAgICAgICAgICAgICAgICAgICAgKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIC8vIHJlbW90ZSBzb3VyY2UgIFxuXHRcdCAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0geyBrZXl3b3JkOiBrZXl3b3JkIH07XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZS5nZXRSZW1vdGVEYXRhKHF1ZXJ5KVxuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKHJlc3ApIHtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maWx0ZXJlZExpc3QgPSByZXNwO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBudWxsOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTsgfSAvLyBjb21wbGV0ZVxuXHRcdCAgICAgICAgICAgICAgICAgICAgKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgfTtcblx0XHQgICAgQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3RvdHlwZS5zZWxlY3RPbmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHRcdCAgICAgICAgdGhpcy5oaWRlRHJvcGRvd25MaXN0KCk7XG5cdFx0ICAgICAgICB0aGlzLnZhbHVlU2VsZWN0ZWQubmV4dChkYXRhKTtcblx0XHQgICAgfTtcblx0XHQgICAgO1xuXHRcdCAgICBBdXRvQ29tcGxldGVDb21wb25lbnQucHJvdG90eXBlLmlucHV0RWxLZXlIYW5kbGVyID0gZnVuY3Rpb24gKGV2dCkge1xuXHRcdCAgICAgICAgdmFyIHRvdGFsTnVtSXRlbSA9IHRoaXMuZmlsdGVyZWRMaXN0Lmxlbmd0aDtcblx0XHQgICAgICAgIHN3aXRjaCAoZXZ0LmtleUNvZGUpIHtcblx0XHQgICAgICAgICAgICBjYXNlIDI3OlxuXHRcdCAgICAgICAgICAgICAgICB0aGlzLmhpZGVEcm9wZG93bkxpc3QoKTtcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSAzODpcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5pdGVtSW5kZXggPSAodG90YWxOdW1JdGVtICsgdGhpcy5pdGVtSW5kZXggLSAxKSAlIHRvdGFsTnVtSXRlbTtcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICAgICAgY2FzZSA0MDpcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93blZpc2libGUgPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICB0aGlzLml0ZW1JbmRleCA9ICh0b3RhbE51bUl0ZW0gKyB0aGlzLml0ZW1JbmRleCArIDEpICUgdG90YWxOdW1JdGVtO1xuXHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHQgICAgICAgICAgICBjYXNlIDEzOlxuXHRcdCAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJlZExpc3QubGVuZ3RoID4gMCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RPbmUodGhpcy5maWx0ZXJlZExpc3RbdGhpcy5pdGVtSW5kZXhdKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH07XG5cdFx0ICAgIDtcblx0XHQgICAgQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRGb3JtYXR0ZWRMaXN0ID0gZnVuY3Rpb24gKGRhdGEpIHtcblx0XHQgICAgICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmxpc3RGb3JtYXR0ZXIgfHwgdGhpcy5kZWZhdWx0TGlzdEZvcm1hdHRlcjtcblx0XHQgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuYXBwbHkodGhpcywgW2RhdGFdKTtcblx0XHQgICAgfTtcblx0XHQgICAgQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3RvdHlwZS5kZWZhdWx0TGlzdEZvcm1hdHRlciA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0ICAgICAgICB2YXIgaHRtbCA9IFwiXCI7XG5cdFx0ICAgICAgICBodG1sICs9IGRhdGFbdGhpcy52YWx1ZVByb3BlcnR5TmFtZV0gPyBcIjxiPihcIiArIGRhdGFbdGhpcy52YWx1ZVByb3BlcnR5TmFtZV0gKyBcIik8L2I+XCIgOiBcIlwiO1xuXHRcdCAgICAgICAgaHRtbCArPSBkYXRhW3RoaXMuZGlzcGxheVByb3BlcnR5TmFtZV0gPyBcIjxzcGFuPlwiICsgZGF0YVt0aGlzLmRpc3BsYXlQcm9wZXJ0eU5hbWVdICsgXCI8L3NwYW4+XCIgOiBkYXRhO1xuXHRcdCAgICAgICAgcmV0dXJuIGh0bWw7XG5cdFx0ICAgIH07XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KFwibGlzdC1mb3JtYXR0ZXJcIiksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBGdW5jdGlvbilcblx0XHQgICAgXSwgQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsaXN0Rm9ybWF0dGVyXCIsIHZvaWQgMCk7XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KFwic291cmNlXCIpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuXHRcdCAgICBdLCBBdXRvQ29tcGxldGVDb21wb25lbnQucHJvdG90eXBlLCBcInNvdXJjZVwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dChcInBhdGgtdG8tZGF0YVwiKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYXRoVG9EYXRhXCIsIHZvaWQgMCk7XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KFwibWluLWNoYXJzXCIpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuXHRcdCAgICBdLCBBdXRvQ29tcGxldGVDb21wb25lbnQucHJvdG90eXBlLCBcIm1pbkNoYXJzXCIsIHZvaWQgMCk7XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KFwidmFsdWUtcHJvcGVydHktbmFtZVwiKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVByb3BlcnR5TmFtZVwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dChcImRpc3BsYXktcHJvcGVydHktbmFtZVwiKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgQXV0b0NvbXBsZXRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNwbGF5UHJvcGVydHlOYW1lXCIsIHZvaWQgMCk7XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KFwicGxhY2Vob2xkZXJcIiksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIEF1dG9Db21wbGV0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcblx0XHQgICAgQXV0b0NvbXBsZXRlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuQ29tcG9uZW50KHtcblx0XHQgICAgICAgICAgICBzZWxlY3RvcjogXCJhdXRvLWNvbXBsZXRlXCIsXG5cdFx0ICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICA8ZGl2IGNsYXNzPVxcXCJhdXRvLWNvbXBsZXRlXFxcIj5cXG5cXG4gICAgPCEtLSBrZXl3b3JkIGlucHV0IC0tPlxcbiAgICA8aW5wdXQgY2xhc3M9XFxcImtleXdvcmRcXFwiXFxuICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwie3twbGFjZWhvbGRlcn19XFxcIlxcbiAgICAgICAgICAgKGZvY3VzKT1cXFwic2hvd0Ryb3Bkb3duTGlzdCgpXFxcIlxcbiAgICAgICAgICAgKGJsdXIpPVxcXCJkcm9wZG93blZpc2libGU9ZmFsc2VcXFwiXFxuICAgICAgICAgICAoa2V5ZG93bik9XFxcImlucHV0RWxLZXlIYW5kbGVyKCRldmVudClcXFwiXFxuICAgICAgICAgICAoaW5wdXQpPVxcXCJyZWxvYWRMaXN0SW5EZWxheSgpXFxcIlxcbiAgICAgICAgICAgWyhuZ01vZGVsKV09XFxcImtleXdvcmRcXFwiIC8+XFxuXFxuICAgIDwhLS0gZHJvcGRvd24gdGhhdCB1c2VyIGNhbiBzZWxlY3QgLS0+XFxuICAgIDx1bCAqbmdJZj1cXFwiZHJvcGRvd25WaXNpYmxlXFxcIj5cXG4gICAgICA8bGkgKm5nSWY9XFxcImlzTG9hZGluZ1xcXCIgY2xhc3M9XFxcImxvYWRpbmdcXFwiPkxvYWRpbmc8L2xpPlxcbiAgICAgIDxsaSBjbGFzcz1cXFwiaXRlbVxcXCJcXG4gICAgICAgICAgKm5nRm9yPVxcXCJsZXQgaXRlbSBvZiBmaWx0ZXJlZExpc3Q7IGxldCBpPWluZGV4XFxcIlxcbiAgICAgICAgICAobW91c2Vkb3duKT1cXFwic2VsZWN0T25lKGl0ZW0pXFxcIlxcbiAgICAgICAgICBbbmdDbGFzc109XFxcIntzZWxlY3RlZDogaSA9PT0gaXRlbUluZGV4fVxcXCJcXG4gICAgICAgICAgW2lubmVySHRtbF09XFxcImdldEZvcm1hdHRlZExpc3QoaXRlbSlcXFwiPlxcbiAgICAgIDwvbGk+XFxuICAgIDwvdWw+XFxuXFxuICA8L2Rpdj5cIixcblx0XHQgICAgICAgICAgICBwcm92aWRlcnM6IFthdXRvX2NvbXBsZXRlXzEuQXV0b0NvbXBsZXRlXSxcblx0XHQgICAgICAgICAgICBzdHlsZXM6IFtcIlxcbiAgQGtleWZyYW1lcyBzbGlkZURvd24ge1xcbiAgICAwJSB7XFxuICAgICAgdHJhbnNmb3JtOiAgdHJhbnNsYXRlWSgtMTBweCk7XFxuICAgIH1cXG4gICAgMTAwJSB7XFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDBweCk7XFxuICAgIH1cXG4gIH1cXG4gIC5hdXRvLWNvbXBsZXRlIGlucHV0IHtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYm9yZGVyOiAycHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci13aWR0aDogM3B4IDJweDtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBiYWNrZ3JvdW5kLWNsaXA6IGNvbnRlbnQtYm94O1xcbiAgfVxcblxcbiAgLmF1dG8tY29tcGxldGUgdWwge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHdpZHRoIDogMTAwJTtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICBhbmltYXRpb246IHNsaWRlRG93biAwLjFzO1xcbiAgfVxcblxcbiAgLmF1dG8tY29tcGxldGUgdWwgbGkge1xcbiAgICBwYWRkaW5nOiAycHggNXB4O1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG4gIH1cXG5cXG4gIC5hdXRvLWNvbXBsZXRlIHVsIGxpLnNlbGVjdGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcXG4gIH1cXG5cXG4gIC5hdXRvLWNvbXBsZXRlIHVsIGxpOmxhc3QtY2hpbGQge1xcbiAgICBib3JkZXItYm90dG9tOiBub25lO1xcbiAgfVxcblxcbiAgLmF1dG8tY29tcGxldGUgdWwgbGk6aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjO1xcbiAgfVwiXG5cdFx0ICAgICAgICAgICAgXSxcblx0XHQgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBjb3JlXzEuVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLkVsZW1lbnRSZWYsIGF1dG9fY29tcGxldGVfMS5BdXRvQ29tcGxldGVdKVxuXHRcdCAgICBdLCBBdXRvQ29tcGxldGVDb21wb25lbnQpO1xuXHRcdCAgICByZXR1cm4gQXV0b0NvbXBsZXRlQ29tcG9uZW50O1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5BdXRvQ29tcGxldGVDb21wb25lbnQgPSBBdXRvQ29tcGxldGVDb21wb25lbnQ7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogOCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDkgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcdHZhciBhdXRvX2NvbXBsZXRlX2NvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XHQvKipcblx0XHQgKiBkaXNwbGF5IGF1dG8tY29tcGxldGUgc2VjdGlvbiB3aXRoIGlucHV0IGFuZCBkcm9wZG93biBsaXN0IHdoZW4gaXQgaXMgY2xpY2tlZFxuXHRcdCAqL1xuXHRcdHZhciBBdXRvQ29tcGxldGVEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBBdXRvQ29tcGxldGVEaXJlY3RpdmUocmVzb2x2ZXIsIHZpZXdDb250YWluZXJSZWYpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICB0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0ICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuXHRcdCAgICAgICAgdGhpcy5uZ01vZGVsQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcblx0XHQgICAgICAgIHRoaXMudmFsdWVDaGFuZ2VkID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcblx0XHQgICAgICAgIHRoaXMuaGlkZUF1dG9Db21wbGV0ZURyb3Bkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKF90aGlzLmNvbXBvbmVudFJlZikge1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmXG5cdFx0ICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudGFnTmFtZSAhPT0gXCJJTlBVVFwiICYmXG5cdFx0ICAgICAgICAgICAgICAgICAgICAhX3RoaXMuZWxlbWVudEluKGV2ZW50LnRhcmdldCwgX3RoaXMuYWNEcm9wZG93bkVsKSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudFJlZiA9IHVuZGVmaW5lZDtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIGlmICghZXZlbnQpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnRSZWYgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgdGhpcy5zdHlsZUF1dG9Db21wbGV0ZURyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5jb21wb25lbnRSZWYuaW5zdGFuY2U7XG5cdFx0ICAgICAgICAgICAgLyogc2V0dGluZyB3aWR0aC9oZWlnaHQgYXV0byBjb21wbGV0ZSAqL1xuXHRcdCAgICAgICAgICAgIHZhciB0aGlzRWxCQ1IgPSBfdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHQgICAgICAgICAgICBfdGhpcy5hY0Ryb3Bkb3duRWwuc3R5bGUud2lkdGggPSB0aGlzRWxCQ1Iud2lkdGggKyBcInB4XCI7XG5cdFx0ICAgICAgICAgICAgX3RoaXMuYWNEcm9wZG93bkVsLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdCAgICAgICAgICAgIF90aGlzLmFjRHJvcGRvd25FbC5zdHlsZS56SW5kZXggPSBcIjFcIjtcblx0XHQgICAgICAgICAgICBfdGhpcy5hY0Ryb3Bkb3duRWwuc3R5bGUudG9wID0gXCIwXCI7XG5cdFx0ICAgICAgICAgICAgX3RoaXMuYWNEcm9wZG93bkVsLnN0eWxlLmxlZnQgPSBcIjBcIjtcblx0XHQgICAgICAgICAgICBfdGhpcy5hY0Ryb3Bkb3duRWwuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0ICAgICAgICAgICAgdmFyIHRoaXNJbnB1dEVsQkNSID0gX3RoaXMuaW5wdXRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHQgICAgICAgICAgICBjb21wb25lbnQuaW5wdXRFbC5zdHlsZS53aWR0aCA9ICh0aGlzSW5wdXRFbEJDUi53aWR0aCAtIDMwKSArIFwicHhcIjtcblx0XHQgICAgICAgICAgICBjb21wb25lbnQuaW5wdXRFbC5zdHlsZS5oZWlnaHQgPSB0aGlzSW5wdXRFbEJDUi5oZWlnaHQgKyBcInB4XCI7XG5cdFx0ICAgICAgICAgICAgY29tcG9uZW50LmlucHV0RWwuZm9jdXMoKTtcblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICB0aGlzLnNlbGVjdE5ld1ZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuXHRcdCAgICAgICAgICAgIC8qIG1vZGlmeSB0b1N0cmluZyBmdW5jdGlvbiBvZiB2YWx1ZSBpZiB2YWx1ZSBpcyBhbiBvYmplY3QgKi9cblx0XHQgICAgICAgICAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIpIHtcblx0XHQgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXlWYWxfMSA9IHZhbFtfdGhpcy5kaXNwbGF5UHJvcGVydHlOYW1lIHx8IFwidmFsdWVcIl07XG5cdFx0ICAgICAgICAgICAgICAgIHZhbC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXlWYWxfMTsgfTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgLyogZW1pdCBuZ01vZGVsQ2hhbmdlIGFuZCB2YWx1ZUNoYW5nZWQgKi9cblx0XHQgICAgICAgICAgICBpZiAodmFsICE9PSBfdGhpcy5uZ01vZGVsKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLm5nTW9kZWxDaGFuZ2UuZW1pdCh2YWwpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBpZiAodmFsKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlQ2hhbmdlZC5lbWl0KHZhbCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIC8qIGhpZGUgZHJvcGRvd24gKi9cblx0XHQgICAgICAgICAgICBfdGhpcy5oaWRlQXV0b0NvbXBsZXRlRHJvcGRvd24oKTtcblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICB0aGlzLmVsID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcblx0XHQgICAgfVxuXHRcdCAgICBBdXRvQ29tcGxldGVEaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgLy8gd3JhcCB0aGlzIGVsZW1lbnQgd2l0aCA8ZGl2IGNsYXNzPVwibmcyLWF1dG8tY29tcGxldGVcIj5cblx0XHQgICAgICAgIHZhciBkaXZFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cdFx0ICAgICAgICBkaXZFbC5jbGFzc05hbWUgPSBcIm5nMi1hdXRvLWNvbXBsZXRlXCI7XG5cdFx0ICAgICAgICBkaXZFbC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHQgICAgICAgIGRpdkVsLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdCAgICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShkaXZFbCwgdGhpcy5lbC5uZXh0U2libGluZyk7XG5cdFx0ICAgICAgICBkaXZFbC5hcHBlbmRDaGlsZCh0aGlzLmVsKTtcblx0XHQgICAgICAgIC8vIGFwcGx5IHRvU3RyaW5nKCkgbWV0aG9kIGZvciB0aGUgb2JqZWN0XG5cdFx0ICAgICAgICB0aGlzLnNlbGVjdE5ld1ZhbHVlKHRoaXMubmdNb2RlbCk7XG5cdFx0ICAgICAgICAvLyB3aGVuIHNvbWV3aGVyZSBlbHNlIGNsaWNrZWQsIGhpZGUgdGhpcyBhdXRvY29tcGxldGVcblx0XHQgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhpZGVBdXRvQ29tcGxldGVEcm9wZG93bik7XG5cdFx0ICAgIH07XG5cdFx0ICAgIEF1dG9Db21wbGV0ZURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICBpZiAodGhpcy5jb21wb25lbnRSZWYpIHtcblx0XHQgICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5pbnN0YW5jZS52YWx1ZVNlbGVjdGVkLnVuc3Vic2NyaWJlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oaWRlQXV0b0NvbXBsZXRlRHJvcGRvd24pO1xuXHRcdCAgICB9O1xuXHRcdCAgICAvL3Nob3cgYXV0by1jb21wbGV0ZSBsaXN0IGJlbG93IHRoZSBjdXJyZW50IGVsZW1lbnRcblx0XHQgICAgQXV0b0NvbXBsZXRlRGlyZWN0aXZlLnByb3RvdHlwZS5zaG93QXV0b0NvbXBsZXRlRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB0aGlzLmhpZGVBdXRvQ29tcGxldGVEcm9wZG93bigpO1xuXHRcdCAgICAgICAgdmFyIGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGF1dG9fY29tcGxldGVfY29tcG9uZW50XzEuQXV0b0NvbXBsZXRlQ29tcG9uZW50KTtcblx0XHQgICAgICAgIHRoaXMuY29tcG9uZW50UmVmID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5KTtcblx0XHQgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudFJlZi5pbnN0YW5jZTtcblx0XHQgICAgICAgIGNvbXBvbmVudC5saXN0Rm9ybWF0dGVyID0gdGhpcy5saXN0Rm9ybWF0dGVyO1xuXHRcdCAgICAgICAgLy9jb21wb25lbnQucHJlZmlsbEZ1bmMgPSB0aGlzLnByZWZpbGxGdW5jO1xuXHRcdCAgICAgICAgY29tcG9uZW50LnBhdGhUb0RhdGEgPSB0aGlzLnBhdGhUb0RhdGE7XG5cdFx0ICAgICAgICBjb21wb25lbnQubWluQ2hhcnMgPSB0aGlzLm1pbkNoYXJzO1xuXHRcdCAgICAgICAgY29tcG9uZW50LnZhbHVlUHJvcGVydHlOYW1lID0gdGhpcy52YWx1ZVByb3BlcnR5TmFtZSB8fCBcImlkXCI7XG5cdFx0ICAgICAgICBjb21wb25lbnQuZGlzcGxheVByb3BlcnR5TmFtZSA9IHRoaXMuZGlzcGxheVByb3BlcnR5TmFtZSB8fCBcInZhbHVlXCI7XG5cdFx0ICAgICAgICBjb21wb25lbnQuc291cmNlID0gdGhpcy5zb3VyY2U7XG5cdFx0ICAgICAgICBjb21wb25lbnQucGxhY2Vob2xkZXIgPSB0aGlzLmF1dG9Db21wbGV0ZVBsYWNlaG9sZGVyO1xuXHRcdCAgICAgICAgY29tcG9uZW50LnZhbHVlU2VsZWN0ZWQuc3Vic2NyaWJlKHRoaXMuc2VsZWN0TmV3VmFsdWUpO1xuXHRcdCAgICAgICAgdGhpcy5hY0Ryb3Bkb3duRWwgPSB0aGlzLmNvbXBvbmVudFJlZi5sb2NhdGlvbi5uYXRpdmVFbGVtZW50O1xuXHRcdCAgICAgICAgdGhpcy5hY0Ryb3Bkb3duRWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdCAgICAgICAgLy8gaWYgdGhpcyBlbGVtZW50IGlzIG5vdCBhbiBpbnB1dCB0YWcsIG1vdmUgZHJvcGRvd24gYWZ0ZXIgaW5wdXQgdGFnXG5cdFx0ICAgICAgICAvLyBzbyB0aGF0IGl0IGRpc3BsYXlzIGNvcnJlY3RseVxuXHRcdCAgICAgICAgdGhpcy5tb3ZlQXV0b2NvbXBsZXRlRHJvcERvd25BZnRlcklucHV0RWwoKTtcblx0XHQgICAgICAgIHNldFRpbWVvdXQodGhpcy5zdHlsZUF1dG9Db21wbGV0ZURyb3Bkb3duKTtcblx0XHQgICAgfTtcblx0XHQgICAgQXV0b0NvbXBsZXRlRGlyZWN0aXZlLnByb3RvdHlwZS5tb3ZlQXV0b2NvbXBsZXRlRHJvcERvd25BZnRlcklucHV0RWwgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB0aGlzLmlucHV0RWwgPSB0aGlzLmVsO1xuXHRcdCAgICAgICAgaWYgKHRoaXMuZWwudGFnTmFtZSAhPT0gXCJJTlBVVFwiICYmIHRoaXMuYWNEcm9wZG93bkVsKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5pbnB1dEVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKFwiaW5wdXRcIik7XG5cdFx0ICAgICAgICAgICAgdGhpcy5pbnB1dEVsLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuYWNEcm9wZG93bkVsLCB0aGlzLmlucHV0RWwubmV4dFNpYmxpbmcpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBBdXRvQ29tcGxldGVEaXJlY3RpdmUucHJvdG90eXBlLmVsZW1lbnRJbiA9IGZ1bmN0aW9uIChlbCwgY29udGFpbmVyRWwpIHtcblx0XHQgICAgICAgIHdoaWxlIChlbCA9IGVsLnBhcmVudE5vZGUpIHtcblx0XHQgICAgICAgICAgICBpZiAoZWwgPT09IGNvbnRhaW5lckVsKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdFx0ICAgIH07XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KFwiYXV0by1jb21wbGV0ZS1wbGFjZWhvbGRlclwiKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgQXV0b0NvbXBsZXRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJhdXRvQ29tcGxldGVQbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dChcImxpc3QtZm9ybWF0dGVyXCIpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgRnVuY3Rpb24pXG5cdFx0ICAgIF0sIEF1dG9Db21wbGV0ZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGlzdEZvcm1hdHRlclwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dChcInNvdXJjZVwiKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIE9iamVjdClcblx0XHQgICAgXSwgQXV0b0NvbXBsZXRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwgdm9pZCAwKTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoXCJwYXRoLXRvLWRhdGFcIiksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIEF1dG9Db21wbGV0ZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFRvRGF0YVwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dChcIm1pbi1jaGFyc1wiKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIE51bWJlcilcblx0XHQgICAgXSwgQXV0b0NvbXBsZXRlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJtaW5DaGFyc1wiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dChcInZhbHVlLXByb3BlcnR5LW5hbWVcIiksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIEF1dG9Db21wbGV0ZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVQcm9wZXJ0eU5hbWVcIiwgdm9pZCAwKTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoXCJkaXNwbGF5LXByb3BlcnR5LW5hbWVcIiksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIEF1dG9Db21wbGV0ZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzcGxheVByb3BlcnR5TmFtZVwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dCgpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuXHRcdCAgICBdLCBBdXRvQ29tcGxldGVEaXJlY3RpdmUucHJvdG90eXBlLCBcIm5nTW9kZWxcIiwgdm9pZCAwKTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuT3V0cHV0KCksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG5cdFx0ICAgIF0sIEF1dG9Db21wbGV0ZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmdNb2RlbENoYW5nZVwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5PdXRwdXQoXCJ2YWx1ZS1jaGFuZ2VkXCIpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuXHRcdCAgICBdLCBBdXRvQ29tcGxldGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlZFwiLCB2b2lkIDApO1xuXHRcdCAgICBBdXRvQ29tcGxldGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5EaXJlY3RpdmUoe1xuXHRcdCAgICAgICAgICAgIHNlbGVjdG9yOiBcIlthdXRvLWNvbXBsZXRlXSwgW25nMi1hdXRvLWNvbXBsZXRlXVwiLFxuXHRcdCAgICAgICAgICAgIGhvc3Q6IHtcblx0XHQgICAgICAgICAgICAgICAgXCIoY2xpY2spXCI6IFwic2hvd0F1dG9Db21wbGV0ZURyb3Bkb3duKClcIlxuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW2NvcmVfMS5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIGNvcmVfMS5WaWV3Q29udGFpbmVyUmVmXSlcblx0XHQgICAgXSwgQXV0b0NvbXBsZXRlRGlyZWN0aXZlKTtcblx0XHQgICAgcmV0dXJuIEF1dG9Db21wbGV0ZURpcmVjdGl2ZTtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuQXV0b0NvbXBsZXRlRGlyZWN0aXZlID0gQXV0b0NvbXBsZXRlRGlyZWN0aXZlO1xuXHRcblx0XG5cdC8qKiovIH1cblx0LyoqKioqKi8gXSlcblx0fSk7XG5cdDtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLWF1dG8tY29tcGxldGUudW1kLmpzLm1hcFxuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X187XG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOF9fO1xuXG4vKioqLyB9LFxuLyogOSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzlfXztcblxuLyoqKi8gfSxcbi8qIDEwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRcdGlmKHRydWUpXG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiLCBcIkBhbmd1bGFyL2Zvcm1zXCIsIFwiQGFuZ3VsYXIvY29tbW9uXCJdLCBmYWN0b3J5KTtcblx0XHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRcdGV4cG9ydHNbXCJuZzItZGF0ZXRpbWUtcGlja2VyXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKSwgcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvY29tbW9uXCIpKTtcblx0XHRlbHNlXG5cdFx0XHRyb290W1wibmcyLWRhdGV0aW1lLXBpY2tlclwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9mb3Jtc1wiXSwgcm9vdFtcIkBhbmd1bGFyL2NvbW1vblwiXSk7XG5cdH0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcblx0cmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcblx0LyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdC8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0LyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0LyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG5cdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0LyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuXHQvKioqKioqLyBcdFx0fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdC8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdC8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG5cdC8qKioqKiovIFx0fVxuXHQvKioqKioqL1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHQvKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXHQvKioqKioqLyB9KVxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqLyAoW1xuXHQvKiAwICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIGZvcm1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdHZhciBjb21tb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFx0dmFyIGRhdGV0aW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcdGV4cG9ydHMuRGF0ZVRpbWUgPSBkYXRldGltZV8xLkRhdGVUaW1lO1xuXHRcdHZhciBkYXRldGltZV9waWNrZXJfY29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcdGV4cG9ydHMuRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQgPSBkYXRldGltZV9waWNrZXJfY29tcG9uZW50XzEuRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQ7XG5cdFx0dmFyIGRhdGV0aW1lX3BpY2tlcl9kaXJlY3RpdmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFx0ZXhwb3J0cy5EYXRlVGltZVBpY2tlckRpcmVjdGl2ZSA9IGRhdGV0aW1lX3BpY2tlcl9kaXJlY3RpdmVfMS5EYXRlVGltZVBpY2tlckRpcmVjdGl2ZTtcblx0XHR2YXIgTmcyRGF0ZXRpbWVQaWNrZXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJEYXRldGltZVBpY2tlck1vZHVsZSgpIHtcblx0XHQgICAgfVxuXHRcdCAgICBOZzJEYXRldGltZVBpY2tlck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHQgICAgICAgICAgICBpbXBvcnRzOiBbY29tbW9uXzEuQ29tbW9uTW9kdWxlLCBmb3Jtc18xLkZvcm1zTW9kdWxlXSxcblx0XHQgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtkYXRldGltZV9waWNrZXJfY29tcG9uZW50XzEuRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQsIGRhdGV0aW1lX3BpY2tlcl9kaXJlY3RpdmVfMS5EYXRlVGltZVBpY2tlckRpcmVjdGl2ZV0sXG5cdFx0ICAgICAgICAgICAgZXhwb3J0czogW2RhdGV0aW1lX3BpY2tlcl9jb21wb25lbnRfMS5EYXRlVGltZVBpY2tlckNvbXBvbmVudCwgZGF0ZXRpbWVfcGlja2VyX2RpcmVjdGl2ZV8xLkRhdGVUaW1lUGlja2VyRGlyZWN0aXZlXSxcblx0XHQgICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtkYXRldGltZV9waWNrZXJfY29tcG9uZW50XzEuRGF0ZVRpbWVQaWNrZXJDb21wb25lbnRdLFxuXHRcdCAgICAgICAgICAgIHByb3ZpZGVyczogW2RhdGV0aW1lXzEuRGF0ZVRpbWVdXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBOZzJEYXRldGltZVBpY2tlck1vZHVsZSk7XG5cdFx0ICAgIHJldHVybiBOZzJEYXRldGltZVBpY2tlck1vZHVsZTtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuTmcyRGF0ZXRpbWVQaWNrZXJNb2R1bGUgPSBOZzJEYXRldGltZVBpY2tlck1vZHVsZTtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAxICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogMiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDMgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA0ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIERhdGVUaW1lID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gRGF0ZVRpbWUoKSB7XG5cdFx0ICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcblx0XHQgICAgfVxuXHRcdCAgICBEYXRlVGltZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHRoaXMubW9udGhzID0gW1xuXHRcdCAgICAgICAgICAgIHsgZnVsbE5hbWU6ICdKYW51YXJ5Jywgc2hvcnROYW1lOiAnSmFuJyB9LFxuXHRcdCAgICAgICAgICAgIHsgZnVsbE5hbWU6ICdGZWJydWFyeScsIHNob3J0TmFtZTogJ0ZlYicgfSxcblx0XHQgICAgICAgICAgICB7IGZ1bGxOYW1lOiAnTWFyY2gnLCBzaG9ydE5hbWU6ICdNYXInIH0sXG5cdFx0ICAgICAgICAgICAgeyBmdWxsTmFtZTogJ0FwcmlsJywgc2hvcnROYW1lOiAnQXByJyB9LFxuXHRcdCAgICAgICAgICAgIHsgZnVsbE5hbWU6ICdNYXknLCBzaG9ydE5hbWU6ICdNYXknIH0sXG5cdFx0ICAgICAgICAgICAgeyBmdWxsTmFtZTogJ0p1bmUnLCBzaG9ydE5hbWU6ICdKdW4nIH0sXG5cdFx0ICAgICAgICAgICAgeyBmdWxsTmFtZTogJ0p1bHknLCBzaG9ydE5hbWU6ICdKdWwnIH0sXG5cdFx0ICAgICAgICAgICAgeyBmdWxsTmFtZTogJ0F1Z3VzdCcsIHNob3J0TmFtZTogJ0F1ZycgfSxcblx0XHQgICAgICAgICAgICB7IGZ1bGxOYW1lOiAnU2VwdGVtYmVyJywgc2hvcnROYW1lOiAnU2VwJyB9LFxuXHRcdCAgICAgICAgICAgIHsgZnVsbE5hbWU6ICdPY3RvYmVyJywgc2hvcnROYW1lOiAnT2N0JyB9LFxuXHRcdCAgICAgICAgICAgIHsgZnVsbE5hbWU6ICdOb3ZlbWJlcicsIHNob3J0TmFtZTogJ05vdicgfSxcblx0XHQgICAgICAgICAgICB7IGZ1bGxOYW1lOiAnRGVjZW1iZXInLCBzaG9ydE5hbWU6ICdEZWMnIH1cblx0XHQgICAgICAgIF07XG5cdFx0ICAgICAgICB0aGlzLmRheXMgPSBbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzFdO1xuXHRcdCAgICAgICAgLyoqXG5cdFx0ICAgICAgICAgKiBBY2NvcmRpbmcgdG8gSW50ZXJuYXRpb25hbCBTdGFuZGFyZCBJU08gODYwMSwgTW9uZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcblx0XHQgICAgICAgICAqIGZvbGxvd2VkIGJ5IFR1ZXNkYXksIFdlZG5lc2RheSwgVGh1cnNkYXksIEZyaWRheSwgU2F0dXJkYXksXG5cdFx0ICAgICAgICAgKiBhbmQgd2l0aCBTdW5kYXkgYXMgdGhlIHNldmVudGggYW5kIGZpbmFsIGRheS5cblx0XHQgICAgICAgICAqIEhvd2V2ZXIsIGluIEphdmFzY3JpcHQgU3VuZGF5IGlzIDAsIE1vbmRheSBpcyAxLi4gYW5kIHNvIG9uXG5cdFx0ICAgICAgICAgKi9cblx0XHQgICAgICAgIHRoaXMuZGF5c09mV2VlayA9IFtcblx0XHQgICAgICAgICAgICB7IGZ1bGxOYW1lOiAnU3VuZGF5Jywgc2hvcnROYW1lOiAnU3UnLCB3ZWVrZW5kOiB0cnVlIH0sXG5cdFx0ICAgICAgICAgICAgeyBmdWxsTmFtZTogJ01vbmRheScsIHNob3J0TmFtZTogJ01vJyB9LFxuXHRcdCAgICAgICAgICAgIHsgZnVsbE5hbWU6ICdUdWVzZGF5Jywgc2hvcnROYW1lOiAnVHUnIH0sXG5cdFx0ICAgICAgICAgICAgeyBmdWxsTmFtZTogJ1dlZG5lc2RheScsIHNob3J0TmFtZTogJ1dlJyB9LFxuXHRcdCAgICAgICAgICAgIHsgZnVsbE5hbWU6ICdUaHVyc2RheScsIHNob3J0TmFtZTogJ1RoJyB9LFxuXHRcdCAgICAgICAgICAgIHsgZnVsbE5hbWU6ICdGcmlkYXknLCBzaG9ydE5hbWU6ICdGcicgfSxcblx0XHQgICAgICAgICAgICB7IGZ1bGxOYW1lOiAnU2F0dXJkYXknLCBzaG9ydE5hbWU6ICdTYScsIHdlZWtlbmQ6IHRydWUgfVxuXHRcdCAgICAgICAgXTtcblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogaWYgbW9tZW50anMgaXMgYXZhaWxhYmxlLCB1c2UgbW9tZW50anMgbG9jYWxpemVkIG1vbnRocywgd2VlaywgZXRjLlxuXHRcdCAgICAgICAgICovXG5cdFx0ICAgICAgICBpZiAodHlwZW9mIG1vbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHQgICAgICAgICAgICB0aGlzLm1vbnRocyA9IHRoaXMubW9udGhzLm1hcChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG5cdFx0ICAgICAgICAgICAgICAgIGVsLmZ1bGxOYW1lID0gbW9tZW50Lm1vbnRocygpW2luZGV4XTtcblx0XHQgICAgICAgICAgICAgICAgZWwuc2hvcnROYW1lID0gbW9tZW50Lm1vbnRoc1Nob3J0KClbaW5kZXhdO1xuXHRcdCAgICAgICAgICAgICAgICByZXR1cm4gZWw7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgdGhpcy5kYXlzT2ZXZWVrID0gdGhpcy5kYXlzT2ZXZWVrLm1hcChmdW5jdGlvbiAoZWwsIGluZGV4KSB7XG5cdFx0ICAgICAgICAgICAgICAgIGVsLmZ1bGxOYW1lID0gbW9tZW50LndlZWtkYXlzKClbaW5kZXhdO1xuXHRcdCAgICAgICAgICAgICAgICBlbC5zaG9ydE5hbWUgPSBtb21lbnQud2Vla2RheXNTaG9ydCgpW2luZGV4XS5zdWJzdHIoMCwgMik7XG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiBlbDtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICB0aGlzLmZpcnN0RGF5T2ZXZWVrID0gbW9tZW50LmxvY2FsZURhdGEoKS5maXJzdERheU9mV2VlaygpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdGhpcy5maXJzdERheU9mV2VlayA9IHRoaXMuZmlyc3REYXlPZldlZWsgfHwgMDtcblx0XHQgICAgICAgIHRoaXMubG9jYWxpemVkRGF5c09mV2VlayA9IHRoaXMuZGF5c09mV2Vla1xuXHRcdCAgICAgICAgICAgIC5jb25jYXQodGhpcy5kYXlzT2ZXZWVrKVxuXHRcdCAgICAgICAgICAgIC5zcGxpY2UodGhpcy5maXJzdERheU9mV2VlaywgNyk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIERhdGVUaW1lLnByb3RvdHlwZS5nZXRNb250aERhdGEgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcblx0XHQgICAgICAgIHllYXIgPSBtb250aCA+IDExID8geWVhciArIDEgOlxuXHRcdCAgICAgICAgICAgIG1vbnRoIDwgMCA/IHllYXIgLSAxIDogeWVhcjtcblx0XHQgICAgICAgIG1vbnRoID0gKG1vbnRoICsgMTIpICUgMTI7XG5cdFx0ICAgICAgICB2YXIgZmlyc3REYXlPZk1vbnRoID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpO1xuXHRcdCAgICAgICAgdmFyIGxhc3REYXlPZk1vbnRoID0gbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCAwKTtcblx0XHQgICAgICAgIHZhciBsYXN0RGF5T2ZQcmV2aW91c01vbnRoID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDApO1xuXHRcdCAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gbGFzdERheU9mTW9udGguZ2V0RGF0ZSgpO1xuXHRcdCAgICAgICAgdmFyIGRheXNJbkxhc3RNb250aCA9IGxhc3REYXlPZlByZXZpb3VzTW9udGguZ2V0RGF0ZSgpO1xuXHRcdCAgICAgICAgdmFyIGRheU9mV2VlayA9IGZpcnN0RGF5T2ZNb250aC5nZXREYXkoKTtcblx0XHQgICAgICAgIC8vIEVuc3VyZSB0aGVyZSBhcmUgYWx3YXlzIGxlYWRpbmcgZGF5cyB0byBnaXZlIGNvbnRleHRcblx0XHQgICAgICAgIHZhciBsZWFkaW5nRGF5cyA9IChkYXlPZldlZWsgLSB0aGlzLmZpcnN0RGF5T2ZXZWVrICsgNykgJSA3IHx8IDc7XG5cdFx0ICAgICAgICB2YXIgdHJhaWxpbmdEYXlzID0gdGhpcy5kYXlzLnNsaWNlKDAsIDYgKiA3IC0gKGxlYWRpbmdEYXlzICsgZGF5c0luTW9udGgpKTtcblx0XHQgICAgICAgIGlmICh0cmFpbGluZ0RheXMubGVuZ3RoID4gNykge1xuXHRcdCAgICAgICAgICAgIHRyYWlsaW5nRGF5cyA9IHRyYWlsaW5nRGF5cy5zbGljZSgwLCB0cmFpbGluZ0RheXMubGVuZ3RoIC0gNyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB2YXIgbW9udGhEYXRhID0ge1xuXHRcdCAgICAgICAgICAgIHllYXI6IHllYXIsXG5cdFx0ICAgICAgICAgICAgbW9udGg6IG1vbnRoLFxuXHRcdCAgICAgICAgICAgIGRheXM6IHRoaXMuZGF5cy5zbGljZSgwLCBkYXlzSW5Nb250aCksXG5cdFx0ICAgICAgICAgICAgbGVhZGluZ0RheXM6IHRoaXMuZGF5cy5zbGljZSgtbGVhZGluZ0RheXMgLSAoMzEgLSBkYXlzSW5MYXN0TW9udGgpLCBkYXlzSW5MYXN0TW9udGgpLFxuXHRcdCAgICAgICAgICAgIHRyYWlsaW5nRGF5czogdHJhaWxpbmdEYXlzXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgcmV0dXJuIG1vbnRoRGF0YTtcblx0XHQgICAgfTtcblx0XHQgICAgO1xuXHRcdCAgICBEYXRlVGltZS5tb21lbnRGb3JtYXREYXRlID0gZnVuY3Rpb24gKGQsIGRhdGVGb3JtYXQpIHtcblx0XHQgICAgICAgIGlmICh0eXBlb2YgbW9tZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdCAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJtb21lbnRqcyBpcyByZXF1aXJlZCB3aXRoIGRhdGVGb3JtYXQuXFxuICAgICAgICBwbGVhc2UgYWRkIDxzY3JpcHQgc3JjPVxcXCJtb21lbnQubWluLmpzXFxcIj48L3NjcmlwdD5cXFwiPiBpbiB5b3VyIGh0bWwuXCIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG1vbWVudChkKS5mb3JtYXQoZGF0ZUZvcm1hdCk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIERhdGVUaW1lLm1vbWVudFBhcnNlID0gZnVuY3Rpb24gKGRhdGVTdHIpIHtcblx0XHQgICAgICAgIGlmICh0eXBlb2YgbW9tZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdCAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJtb21lbnRqcyBpcyByZXF1aXJlZCB3aXRoIGRhdGVGb3JtYXQuXFxuICAgICAgICBwbGVhc2UgYWRkIDxzY3JpcHQgc3JjPVxcXCJtb21lbnQubWluLmpzXFxcIj48L3NjcmlwdD5cXFwiPiBpbiB5b3VyIGh0bWwuXCIpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG1vbWVudChkYXRlU3RyKS50b0RhdGUoKTtcblx0XHQgICAgfTtcblx0XHQgICAgRGF0ZVRpbWUuZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uIChkLCBkYXRlT25seSkge1xuXHRcdCAgICAgICAgLy8gcmV0dXJuIGQudG9Mb2NhbGVTdHJpbmcoJ2VuLXVzJywgaGFzaCk7IC8vIElFMTEgZG9lcyBub3QgdW5kZXJzdGFuZCB0aGlzXG5cdFx0ICAgICAgICB2YXIgcGFkMCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gKFwiMFwiICsgbnVtYmVyKS5zbGljZSgtMik7XG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgdmFyIHJldCA9IGQuZ2V0RnVsbFllYXIoKSArICctJyArIHBhZDAoZC5nZXRNb250aCgpICsgMSkgKyAnLScgKyBwYWQwKGQuZ2V0RGF0ZSgpKTtcblx0XHQgICAgICAgIGlmICghZGF0ZU9ubHkpIHtcblx0XHQgICAgICAgICAgICByZXQgKz0gJyAnICsgcGFkMChkLmdldEhvdXJzKCkpICsgJzonICsgcGFkMChkLmdldE1pbnV0ZXMoKSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gcmV0O1xuXHRcdCAgICB9O1xuXHRcdCAgICAvL3JldHVybiBkYXRlIGFzIGdpdmVuIGZyb20gZ2l2ZW4gc3RyaW5nXG5cdFx0ICAgIC8vIHdpdGhvdXQgY29uc2lkZXJpbmcgdGltZXpvbmUgYW5kIGRheSBsaWdodCBzYXZpbmcgdGltZSBjb25zaWRlcmVkXG5cdFx0ICAgIERhdGVUaW1lLnBhcnNlID0gZnVuY3Rpb24gKGRhdGVTdHIpIHtcblx0XHQgICAgICAgIGRhdGVTdHIgPSBEYXRlVGltZS5yZW1vdmVUaW1lem9uZShkYXRlU3RyKTtcblx0XHQgICAgICAgIGRhdGVTdHIgPSBkYXRlU3RyICsgRGF0ZVRpbWUuYWRkRFNUT2Zmc2V0KGRhdGVTdHIpO1xuXHRcdCAgICAgICAgcmV0dXJuIERhdGVUaW1lLmdldERhdGVGcm9tU3RyaW5nKGRhdGVTdHIpO1xuXHRcdCAgICB9O1xuXHRcdCAgICAvL3JlbW92ZSB0aW1lem9uZVxuXHRcdCAgICBEYXRlVGltZS5yZW1vdmVUaW1lem9uZSA9IGZ1bmN0aW9uIChkYXRlU3RyKSB7XG5cdFx0ICAgICAgICAvLyBpZiBubyB0aW1lIGlzIGdpdmVuLCBhZGQgMDA6MDA6MDAgYXQgdGhlIGVuZFxuXHRcdCAgICAgICAgdmFyIG1hdGNoZXMgPSBkYXRlU3RyLm1hdGNoKC9bMC05XXsyfTovKTtcblx0XHQgICAgICAgIGRhdGVTdHIgKz0gbWF0Y2hlcyA/ICcnIDogJyAwMDowMDowMCc7XG5cdFx0ICAgICAgICByZXR1cm4gZGF0ZVN0ci5yZXBsYWNlKC8oWzAtOV17Mn0tWzAtOV17Mn0pLShbMC05XXs0fSkvLCAnJDItJDEnKSAvL21tLWRkLXl5eXkgdG8geXl5eS1tbS1kZFxuXHRcdCAgICAgICAgICAgIC5yZXBsYWNlKC8oW1xcLy1dWzAtOV17Miw0fSlcXCAoWzAtOV17Mn1cXDpbMC05XXsyfVxcOikvLCAnJDFUJDInKSAvL3JlZm9ybWF0IGZvciBGRlxuXHRcdCAgICAgICAgICAgIC5yZXBsYWNlKC9FRFR8RVNUfENEVHxDU1R8TURUfFBEVHxQU1R8VVR8R01UL2csICcnKSAvL3JlbW92ZSB0aW1lem9uZVxuXHRcdCAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqXFwoXFwpXFxzKi8sICcnKSAvL3JlbW92ZSB0aW1lem9uZVxuXHRcdCAgICAgICAgICAgIC5yZXBsYWNlKC9bXFwtXFwrXVswLTldezJ9Oj9bMC05XXsyfSQvLCAnJykgLy9yZW1vdmUgdGltZXpvbmVcblx0XHQgICAgICAgICAgICAucmVwbGFjZSgvMDAwWiQvLCAnMDAnKTsgLy9yZW1vdmUgdGltZXpvbmVcblx0XHQgICAgfTtcblx0XHQgICAgRGF0ZVRpbWUuYWRkRFNUT2Zmc2V0ID0gZnVuY3Rpb24gKGRhdGVTdHIpIHtcblx0XHQgICAgICAgIHZhciBkYXRlID0gRGF0ZVRpbWUuZ2V0RGF0ZUZyb21TdHJpbmcoZGF0ZVN0cik7XG5cdFx0ICAgICAgICB2YXIgamFuID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcblx0XHQgICAgICAgIHZhciBqdWwgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDYsIDEpO1xuXHRcdCAgICAgICAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcblx0XHQgICAgICAgIHZhciBpc0RTVCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA8IHN0ZFRpbWV6b25lT2Zmc2V0O1xuXHRcdCAgICAgICAgdmFyIG9mZnNldCA9IGlzRFNUID8gc3RkVGltZXpvbmVPZmZzZXQgLSA2MCA6IHN0ZFRpbWV6b25lT2Zmc2V0O1xuXHRcdCAgICAgICAgdmFyIGRpZmYgPSBvZmZzZXQgPj0gMCA/ICctJyA6ICcrJztcblx0XHQgICAgICAgIG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCk7XG5cdFx0ICAgICAgICByZXR1cm4gZGlmZiArXG5cdFx0ICAgICAgICAgICAgKCcwJyArIChvZmZzZXQgLyA2MCkpLnNsaWNlKC0yKSArICc6JyArXG5cdFx0ICAgICAgICAgICAgKCcwJyArIChvZmZzZXQgJSA2MCkpLnNsaWNlKC0yKTtcblx0XHQgICAgfTtcblx0XHQgICAgO1xuXHRcdCAgICBEYXRlVGltZS5nZXREYXRlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChkYXRlU3RyKSB7XG5cdFx0ICAgICAgICB2YXIgdG1wID0gZGF0ZVN0ci5zcGxpdCgvW1xcK1xcLTpcXCBUXS8pOyAvLyBzcGxpdCBieSBkYXNoLCBjb2xvbiBvciBzcGFjZVxuXHRcdCAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHBhcnNlSW50KHRtcFswXSwgMTApLCBwYXJzZUludCh0bXBbMV0sIDEwKSAtIDEsIHBhcnNlSW50KHRtcFsyXSwgMTApLCBwYXJzZUludCh0bXBbM10gfHwgJzAnLCAxMCksIHBhcnNlSW50KHRtcFs0XSB8fCAnMCcsIDEwKSwgcGFyc2VJbnQodG1wWzVdIHx8ICcwJywgMTApKTtcblx0XHQgICAgfTtcblx0XHQgICAgRGF0ZVRpbWUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKCksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0XHQgICAgXSwgRGF0ZVRpbWUpO1xuXHRcdCAgICByZXR1cm4gRGF0ZVRpbWU7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLkRhdGVUaW1lID0gRGF0ZVRpbWU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBkYXRldGltZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XHQvL0BUT0RPXG5cdFx0Ly8gLiBkaXNwbGF5IGN1cnJlbnRseSBzZWxlY3RlZCBkYXlcblx0XHQvKipcblx0XHQgKiBzaG93IGEgc2VsZWN0ZWQgZGF0ZSBpbiBtb250aGx5IGNhbGVuZGFyXG5cdFx0ICovXG5cdFx0dmFyIERhdGVUaW1lUGlja2VyQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQoZWxlbWVudFJlZiwgZGF0ZVRpbWUsIGNkUmVmKSB7XG5cdFx0ICAgICAgICB0aGlzLmRhdGVUaW1lID0gZGF0ZVRpbWU7XG5cdFx0ICAgICAgICB0aGlzLmNkUmVmID0gY2RSZWY7XG5cdFx0ICAgICAgICB0aGlzLmNoYW5nZXMgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuXHRcdCAgICAgICAgdGhpcy5jbG9zaW5nID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcblx0XHQgICAgICAgIHRoaXMuZWwgPSBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cdFx0ICAgIH1cblx0XHQgICAgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIGlmICghdGhpcy5kYXRlT25seSkge1xuXHRcdCAgICAgICAgICAgIHRoaXMuX2hvdXJzLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuXHRcdCAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX2hvdXJzLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcblx0XHQgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICB0aGlzLl9taW51dGVzLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuXHRcdCAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHRoaXMuX21pbnV0ZXMubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuXHRcdCAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInllYXJcIiwge1xuXHRcdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWREYXRlLmdldEZ1bGxZZWFyKCk7XG5cdFx0ICAgICAgICB9LFxuXHRcdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdCAgICB9KTtcblx0XHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aFwiLCB7XG5cdFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZERhdGUuZ2V0TW9udGgoKTtcblx0XHQgICAgICAgIH0sXG5cdFx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgIH0pO1xuXHRcdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRheVwiLCB7XG5cdFx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZERhdGUuZ2V0RGF0ZSgpO1xuXHRcdCAgICAgICAgfSxcblx0XHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdFx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0XHQgICAgfSk7XG5cdFx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9kYXlcIiwge1xuXHRcdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgdmFyIGR0ID0gbmV3IERhdGUoKTtcblx0XHQgICAgICAgICAgICBkdC5zZXRIb3VycygwKTtcblx0XHQgICAgICAgICAgICBkdC5zZXRNaW51dGVzKDApO1xuXHRcdCAgICAgICAgICAgIGR0LnNldFNlY29uZHMoMCk7XG5cdFx0ICAgICAgICAgICAgZHQuc2V0TWlsbGlzZWNvbmRzKDApO1xuXHRcdCAgICAgICAgICAgIHJldHVybiBkdDtcblx0XHQgICAgICAgIH0sXG5cdFx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0ICAgIH0pO1xuXHRcdCAgICBEYXRlVGltZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUuaW5pdERhdGVUaW1lID0gZnVuY3Rpb24gKGRhdGUpIHtcblx0XHQgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gZGF0ZTtcblx0XHQgICAgICAgIHRoaXMuaG91ciA9IHRoaXMuc2VsZWN0ZWREYXRlLmdldEhvdXJzKCk7XG5cdFx0ICAgICAgICB0aGlzLm1pbnV0ZSA9IHRoaXMuc2VsZWN0ZWREYXRlLmdldE1pbnV0ZXMoKTtcblx0XHQgICAgICAgIHRoaXMubW9udGhEYXRhID0gdGhpcy5kYXRlVGltZS5nZXRNb250aERhdGEodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcblx0XHQgICAgfTtcblx0XHQgICAgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLnRvRGF0ZSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCwgZGF5KSB7XG5cdFx0ICAgICAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZS50b0RhdGVPbmx5ID0gZnVuY3Rpb24gKGRhdGUpIHtcblx0XHQgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDAsIDAsIDAsIDApO1xuXHRcdCAgICB9O1xuXHRcdCAgICAvKipcblx0XHQgICAgICogc2V0IHRoZSBzZWxlY3RlZCBkYXRlIGFuZCBjbG9zZSBpdCB3aGVuIGNsb3NlT25TZWxlY3QgaXMgdHJ1ZVxuXHRcdCAgICAgKiBAcGFyYW0gZGF0ZSB7RGF0ZX1cblx0XHQgICAgICovXG5cdFx0ICAgIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZS5zZWxlY3REYXRlID0gZnVuY3Rpb24gKGRheU51bSkge1xuXHRcdCAgICAgICAgaWYgKGRheU51bSkge1xuXHRcdCAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gbmV3IERhdGUodGhpcy5tb250aERhdGEueWVhciwgdGhpcy5tb250aERhdGEubW9udGgsIGRheU51bSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICB0aGlzLmNoYW5nZXMuZW1pdCh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0ZWREYXRlOiB0aGlzLnNlbGVjdGVkRGF0ZSxcblx0XHQgICAgICAgICAgICBob3VyOiB0aGlzLmhvdXIsXG5cdFx0ICAgICAgICAgICAgbWludXRlOiB0aGlzLm1pbnV0ZVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICB0aGlzLmNsb3NpbmcuZW1pdCh0cnVlKTtcblx0XHQgICAgfTtcblx0XHQgICAgO1xuXHRcdCAgICAvKipcblx0XHQgICAgICogc2hvdyBwcmV2L25leHQgbW9udGggY2FsZW5kYXJcblx0XHQgICAgICovXG5cdFx0ICAgIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVNb250aERhdGEgPSBmdW5jdGlvbiAobnVtKSB7XG5cdFx0ICAgICAgICB0aGlzLm1vbnRoRGF0YSA9IHRoaXMuZGF0ZVRpbWUuZ2V0TW9udGhEYXRhKHRoaXMubW9udGhEYXRhLnllYXIsIHRoaXMubW9udGhEYXRhLm1vbnRoICsgbnVtKTtcblx0XHQgICAgfTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuVmlld0NoaWxkKCdob3VycycpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgY29yZV8xLkVsZW1lbnRSZWYpXG5cdFx0ICAgIF0sIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJfaG91cnNcIiwgdm9pZCAwKTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuVmlld0NoaWxkKCdtaW51dGVzJyksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBjb3JlXzEuRWxlbWVudFJlZilcblx0XHQgICAgXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIl9taW51dGVzXCIsIHZvaWQgMCk7XG5cdFx0ICAgIERhdGVUaW1lUGlja2VyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuQ29tcG9uZW50KHtcblx0XHQgICAgICAgICAgICBwcm92aWRlcnM6IFtkYXRldGltZV8xLkRhdGVUaW1lXSxcblx0XHQgICAgICAgICAgICBzZWxlY3RvcjogJ2RhdGV0aW1lLXBpY2tlcicsXG5cdFx0ICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuPGRpdiBjbGFzcz1cXFwiZGF0ZXRpbWUtcGlja2VyXFxcIiB0YWJpbmRleD1cXFwiMFxcXCI+XFxuXFxuICA8IS0tIE1vbnRoIC0gWWVhciAgLS0+XFxuICA8ZGl2IGNsYXNzPVxcXCJtb250aFxcXCI+XFxuICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwicHJldlxcXCIgKGNsaWNrKT1cXFwidXBkYXRlTW9udGhEYXRhKC0xKVxcXCI+JmxhcXVvOzwvYnV0dG9uPlxcbiAgICAgPHNwYW4gdGl0bGU9XFxcInt7ZGF0ZVRpbWUubW9udGhzW21vbnRoRGF0YS5tb250aF0uZnVsbE5hbWV9fVxcXCI+XFxuICAgICAgICAgICB7e2RhdGVUaW1lLm1vbnRoc1ttb250aERhdGEubW9udGhdLnNob3J0TmFtZX19XFxuICAgICA8L3NwYW4+XFxuICAgIHt7bW9udGhEYXRhLnllYXJ9fVxcbiAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcIm5leHRcXFwiIChjbGljayk9XFxcInVwZGF0ZU1vbnRoRGF0YSgrMSlcXFwiPiZyYXF1bzs8L2J1dHRvbj5cXG4gIDwvZGl2PlxcblxcbiAgPGRpdiBjbGFzcz1cXFwiZGF5c1xcXCI+XFxuXFxuICAgIDwhLS0gU3UgTW8gVHUgV2UgVGggRnIgU2EgLS0+XFxuICAgIDxkaXYgY2xhc3M9XFxcImRheS1vZi13ZWVrXFxcIlxcbiAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGRheU9mV2VlayBvZiBkYXRlVGltZS5sb2NhbGl6ZWREYXlzT2ZXZWVrXFxcIlxcbiAgICAgICAgIFtuZ0NsYXNzXT1cXFwie3dlZWtlbmQ6IGRheU9mV2Vlay53ZWVrZW5kfVxcXCJcXG4gICAgICAgICB0aXRsZT1cXFwie3tkYXlPZldlZWsuZnVsbE5hbWV9fVxcXCI+XFxuICAgICAge3tkYXlPZldlZWsuc2hvcnROYW1lfX1cXG4gICAgPC9kaXY+XFxuXFxuICAgIDwhLS0gRmlsbCB1cCBibGFuayBkYXlzIGZvciB0aGlzIG1vbnRoIC0tPlxcbiAgICA8ZGl2ICpuZ0lmPVxcXCJtb250aERhdGEubGVhZGluZ0RheXMubGVuZ3RoIDwgN1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiZGF5XFxcIiAqbmdGb3I9XFxcImxldCBkYXlOdW0gb2YgbW9udGhEYXRhLmxlYWRpbmdEYXlzXFxcIlxcbiAgICAgICAgICAgW25nQ2xhc3NdPVxcXCJ7d2Vla2VuZDogWzAsNl0uaW5kZXhPZih0b0RhdGUobW9udGhEYXRhLnllYXIsIG1vbnRoRGF0YS5tb250aC0xLCBkYXlOdW0pLmdldERheSgpKSAhPT0gLTF9XFxcIj5cXG4gICAgICAgIHt7ZGF5TnVtfX1cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIDxkaXYgY2xhc3M9XFxcImRheSBzZWxlY3RhYmxlXFxcIlxcbiAgICAgICAgICpuZ0Zvcj1cXFwibGV0IGRheU51bSBvZiBtb250aERhdGEuZGF5c1xcXCJcXG4gICAgICAgICAoY2xpY2spPVxcXCJzZWxlY3REYXRlKGRheU51bSlcXFwiXFxuICAgICAgICAgdGl0bGU9XFxcInt7bW9udGhEYXRhLnllYXJ9fS17e21vbnRoRGF0YS5tb250aCsxfX0te3tkYXlOdW19fVxcXCJcXG4gICAgICAgICBbbmdDbGFzc109XFxcIntcXG4gICAgICAgICAgIHNlbGVjdGVkOlxcbiAgICAgICAgICAgICB0b0RhdGUobW9udGhEYXRhLnllYXIsIG1vbnRoRGF0YS5tb250aCwgZGF5TnVtKS5nZXRUaW1lKCkgPT09IHRvRGF0ZU9ubHkoc2VsZWN0ZWREYXRlKS5nZXRUaW1lKCksXFxuICAgICAgICAgICB0b2RheTpcXG4gICAgICAgICAgICAgdG9EYXRlKG1vbnRoRGF0YS55ZWFyLCBtb250aERhdGEubW9udGgsIGRheU51bSkuZ2V0VGltZSgpID09PSB0b2RheS5nZXRUaW1lKCksXFxuICAgICAgICAgICB3ZWVrZW5kOlxcbiAgICAgICAgICAgICBbMCw2XS5pbmRleE9mKHRvRGF0ZShtb250aERhdGEueWVhciwgbW9udGhEYXRhLm1vbnRoLCBkYXlOdW0pLmdldERheSgpKSAhPT0gLTFcXG4gICAgICAgICB9XFxcIj5cXG4gICAgICB7e2RheU51bX19XFxuICAgIDwvZGl2PlxcblxcbiAgICA8IS0tIEZpbGwgdXAgYmxhbmsgZGF5cyBmb3IgdGhpcyBtb250aCAtLT5cXG4gICAgPGRpdiAqbmdJZj1cXFwibW9udGhEYXRhLnRyYWlsaW5nRGF5cy5sZW5ndGggPCA3XFxcIj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJkYXlcXFwiXFxuICAgICAgICAgICAqbmdGb3I9XFxcImxldCBkYXlOdW0gb2YgbW9udGhEYXRhLnRyYWlsaW5nRGF5c1xcXCJcXG4gICAgICAgICAgIFtuZ0NsYXNzXT1cXFwie3dlZWtlbmQ6IFswLDZdLmluZGV4T2YodG9EYXRlKG1vbnRoRGF0YS55ZWFyLCBtb250aERhdGEubW9udGgrMSwgZGF5TnVtKS5nZXREYXkoKSkgIT09IC0xfVxcXCI+XFxuICAgICAgICB7e2RheU51bX19XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuXFxuICA8IS0tIFRpbWUgLS0+XFxuICA8ZGl2IGNsYXNzPVxcXCJkYXlzXFxcIiBpZD1cXFwidGltZVxcXCIgKm5nSWY9XFxcIiFkYXRlT25seVxcXCI+XFxuICAgIDxsYWJlbCBjbGFzcz1cXFwidGltZUxhYmVsXFxcIj5UaW1lOjwvbGFiZWw+XFxuICAgIDxzcGFuIGNsYXNzPVxcXCJ0aW1lVmFsdWVcXFwiPlxcbiAgICAgIHt7KFxcXCIwXFxcIitob3VyKS5zbGljZSgtMil9fSA6IHt7KFxcXCIwXFxcIittaW51dGUpLnNsaWNlKC0yKX19XFxuICAgIDwvc3Bhbj48YnIvPlxcbiAgICA8bGFiZWwgY2xhc3M9XFxcImhvdXJMYWJlbFxcXCI+SG91cjo8L2xhYmVsPlxcbiAgICA8aW5wdXQgI2hvdXJzIGNsYXNzPVxcXCJob3VySW5wdXRcXFwiXFxuICAgICAgICAgICAoY2hhbmdlKT1cXFwic2VsZWN0RGF0ZSgpXFxcIlxcbiAgICAgICAgICAgdHlwZT1cXFwicmFuZ2VcXFwiIG1pbj1cXFwiMFxcXCIgbWF4PVxcXCIyM1xcXCIgWyhuZ01vZGVsKV09XFxcImhvdXJcXFwiIC8+XFxuICAgIDxsYWJlbCBjbGFzcz1cXFwibWludXRlc0xhYmVsXFxcIj5NaW46PC9sYWJlbD5cXG4gICAgPGlucHV0ICNtaW51dGVzIGNsYXNzPVxcXCJtaW51dGVzSW5wdXRcXFwiXFxuICAgICAgICAgICAoY2hhbmdlKT1cXFwic2VsZWN0RGF0ZSgpXFxcIlxcbiAgICAgICAgICAgdHlwZT1cXFwicmFuZ2VcXFwiIG1pbj1cXFwiMFxcXCIgbWF4PVxcXCI1OVxcXCIgcmFuZ2U9XFxcIjEwXFxcIiBbKG5nTW9kZWwpXT1cXFwibWludXRlXFxcIi8+XFxuICA8L2Rpdj5cXG48L2Rpdj5cXG5cXG48IS0tPGhyLz4tLT5cXG48IS0tRGF0ZToge3tzZWxlY3RlZERhdGV9fTxici8+LS0+XFxuPCEtLUhvdXI6IHt7aG91cn19IE1pbnV0ZToge3ttaW51dGV9fTxici8+LS0+XFxuICBcIixcblx0XHQgICAgICAgICAgICBzdHlsZXM6IFtcblx0XHQgICAgICAgICAgICAgICAgXCJcXG4gQGtleWZyYW1lcyBzbGlkZURvd24ge1xcbiAgMCUge1xcbiAgICB0cmFuc2Zvcm06ICB0cmFuc2xhdGVZKC0xMHB4KTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMHB4KTtcXG4gIH1cXG59XFxuXFxuLmRhdGV0aW1lLXBpY2tlciB7XFxuICAgIGNvbG9yOiAjMzMzO1xcbiAgICBvdXRsaW5lLXdpZHRoOiAwO1xcbiAgICBmb250OiBub3JtYWwgMTRweCBzYW5zLXNlcmlmO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuICAgIGFuaW1hdGlvbjogc2xpZGVEb3duIDAuMXMgZWFzZS1pbi1vdXQ7XFxuICAgIGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxufVxcbi5kYXRldGltZS1waWNrZXIgPiAubW9udGgge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGxpbmUtaGVpZ2h0OiAyMnB4O1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjZmNmY2ZjO1xcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuLmRhdGV0aW1lLXBpY2tlciA+IC5tb250aCA+IGJ1dHRvbiB7XFxuICAgIGNvbG9yOiAjNTU1O1xcbiAgICBmb250OiBub3JtYWwgMTRweCBzYW5zLXNlcmlmO1xcbiAgICBvdXRsaW5lOiBub25lO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmRhdGV0aW1lLXBpY2tlciA+IC5tb250aCA+IGJ1dHRvbjpob3ZlciB7XFxuICAgIGNvbG9yOiAjMzMzO1xcbn1cXG4uZGF0ZXRpbWUtcGlja2VyID4gLm1vbnRoID4gYnV0dG9uLnByZXYge1xcbiAgICBsZWZ0OiAxMHB4O1xcbn1cXG4uZGF0ZXRpbWUtcGlja2VyID4gLm1vbnRoID4gYnV0dG9uLm5leHQge1xcbiAgICByaWdodDogMTBweDtcXG59XFxuLmRhdGV0aW1lLXBpY2tlciA+IC5kYXlzIHtcXG4gICAgd2lkdGg6IDIxMHB4OyAvKiAzMCB4IDcgKi9cXG4gICAgbWFyZ2luOiAxMHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcbi5kYXRldGltZS1waWNrZXIgPiAuZGF5cyAuZGF5LW9mLXdlZWssXFxuLmRhdGV0aW1lLXBpY2tlciA+IC5kYXlzIC5kYXkge1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICB3aWR0aDogMzBweDtcXG4gICAgbGluZS1oZWlnaHQ6IDI4cHg7XFxuICAgIGZsb2F0OiBsZWZ0O1xcbn1cXG4uZGF0ZXRpbWUtcGlja2VyID4gLmRheXMgLmRheS1vZi13ZWVrIHtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi5kYXRldGltZS1waWNrZXIgPiAuZGF5cyAuZGF5LW9mLXdlZWsud2Vla2VuZCB7XFxuICAgIGNvbG9yOiAjY2NjO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBpbmhlcml0O1xcbn1cXG4uZGF0ZXRpbWUtcGlja2VyID4gLmRheXMgLmRheTpub3QoLnNlbGVjdGFibGUpIHtcXG4gICAgY29sb3I6ICNjY2M7XFxuICAgIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuLmRhdGV0aW1lLXBpY2tlciA+IC5kYXlzIC53ZWVrZW5kIHtcXG4gICAgY29sb3I6ICNjY2M7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxufVxcbi5kYXRldGltZS1waWNrZXIgPiAuZGF5cyAuZGF5LnNlbGVjdGFibGUgIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uZGF0ZXRpbWUtcGlja2VyID4gLmRheXMgLmRheS5zZWxlY3RlZCB7XFxuICAgIGJhY2tncm91bmQ6IGdyYXk7XFxuICAgIGNvbG9yOiAjZmZmO1xcbn1cXG4uZGF0ZXRpbWUtcGlja2VyID4gLmRheXMgLmRheTpub3QoLnNlbGVjdGVkKS5zZWxlY3RhYmxlOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZDogI2VlZTtcXG59XFxuLmRhdGV0aW1lLXBpY2tlciA+IC5kYXlzOmFmdGVyIHtcXG4gICAgY29udGVudDogJyc7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBjbGVhcjogbGVmdDtcXG4gICAgaGVpZ2h0OiAwO1xcbn1cXG4uZGF0ZXRpbWUtcGlja2VyIC5ob3VyTGFiZWwsXFxuLmRhdGV0aW1lLXBpY2tlciAubWludXRlc0xhYmVsIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICB3aWR0aDogNDBweDtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7XFxufVxcbi5kYXRldGltZS1waWNrZXIgaW5wdXRbdHlwZT1yYW5nZV0ge1xcbiAgICB3aWR0aDogMTUwcHg7XFxufVxcbiAgXCJcblx0XHQgICAgICAgICAgICBdLFxuXHRcdCAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjb3JlXzEuRWxlbWVudFJlZiwgZGF0ZXRpbWVfMS5EYXRlVGltZSwgY29yZV8xLkNoYW5nZURldGVjdG9yUmVmXSlcblx0XHQgICAgXSwgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQpO1xuXHRcdCAgICByZXR1cm4gRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQ7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLkRhdGVUaW1lUGlja2VyQ29tcG9uZW50ID0gRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQ7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBkYXRldGltZV9waWNrZXJfY29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcdHZhciBkYXRldGltZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XHQvKipcblx0XHQgKiBUbyBzaW1wbGlmeSB0aGUgaW1wbGVtZW50YXRpb24sIGl0IGxpbWl0cyB0aGUgdHlwZSBpZiB2YWx1ZSB0byBzdHJpbmcgb25seSwgbm90IGEgZGF0ZVxuXHRcdCAqIElmIHRoZSBnaXZlbiBzdHJpbmcgaXMgbm90IGEgdmFsaWQgZGF0ZSwgaXQgZGVmYXVsdHMgYmFjayB0byB0b2RheVxuXHRcdCAqL1xuXHRcdHZhciBEYXRlVGltZVBpY2tlckRpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlKF9yZXNvbHZlciwgX3ZpZXdDb250YWluZXJSZWYpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICB0aGlzLl9yZXNvbHZlciA9IF9yZXNvbHZlcjtcblx0XHQgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcblx0XHQgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICogQGRlcHJlY2F0ZWRcblx0XHQgICAgICAgICAqL1xuXHRcdCAgICAgICAgdGhpcy5uZ01vZGVsQ2hhbmdlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcblx0XHQgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuXHRcdCAgICAgICAgdGhpcy5fa2V5RXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMuaGlkZURhdGV0aW1lUGlja2VyKCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIHRoaXMuaGlkZURhdGV0aW1lUGlja2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICAgICAgICAgICAgaWYgKF90aGlzLl9jb21wb25lbnRSZWYpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdjbGljaycgJiZcblx0XHQgICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCAhPT0gX3RoaXMuX2VsICYmICFfdGhpcy5fZWxlbWVudEluKGV2ZW50LnRhcmdldCwgX3RoaXMuX2RhdGV0aW1lUGlja2VyKSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvbXBvbmVudFJlZi5kZXN0cm95KCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY29tcG9uZW50UmVmID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFldmVudCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvbXBvbmVudFJlZi5kZXN0cm95KCk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY29tcG9uZW50UmVmID0gdW5kZWZpbmVkO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIHRoaXMuX2VsID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG5cdFx0ICAgIH1cblx0XHQgICAgRGF0ZVRpbWVQaWNrZXJEaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgLy93cmFwIHRoaXMgZWxlbWVudCB3aXRoIGEgPGRpdj4gdGFnLCBzbyB0aGF0IHdlIGNhbiBwb3NpdGlvbiBkeW5hbWljIGVsZW1lbW50IGNvcnJlY3RseVxuXHRcdCAgICAgICAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdCAgICAgICAgd3JhcHBlci5jbGFzc05hbWUgPSAnbmcyLWRhdGV0aW1lLXBpY2tlcic7XG5cdFx0ICAgICAgICB3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcblx0XHQgICAgICAgIHdyYXBwZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHRcdCAgICAgICAgdGhpcy5fZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUod3JhcHBlciwgdGhpcy5fZWwubmV4dFNpYmxpbmcpO1xuXHRcdCAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLl9lbCk7XG5cdFx0ICAgICAgICB0aGlzLl9yZWdpc3RlckV2ZW50TGlzdGVuZXJzKCk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgaWYgKGNoYW5nZXNbJ3ZhbHVlJ10gIT09IHVuZGVmaW5lZCB8fCBjaGFuZ2VzWyduZ01vZGVsJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgIGlmIChjaGFuZ2VzWyduZ01vZGVsJ10gIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5uZ01vZGVsO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB2YXIgZGF0ZU5nTW9kZWxfMTtcblx0XHQgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRpbWV6b25lIGFuZCByZXNwZWN0IGRheSBsaWdodCBzYXZpbmcgdGltZVxuXHRcdCAgICAgICAgICAgICAgICBkYXRlTmdNb2RlbF8xID0gdGhpcy5kYXRlRm9ybWF0ID9cblx0XHQgICAgICAgICAgICAgICAgICAgIGRhdGV0aW1lXzEuRGF0ZVRpbWUubW9tZW50UGFyc2UoJycgKyB0aGlzLnZhbHVlKSA6XG5cdFx0ICAgICAgICAgICAgICAgICAgICBkYXRldGltZV8xLkRhdGVUaW1lLnBhcnNlKCcnICsgdGhpcy52YWx1ZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGRhdGVOZ01vZGVsXzEgPSB0aGlzLnZhbHVlO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgZGF0ZU5nTW9kZWxfMSA9IG5ldyBEYXRlKCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIHZhciBmb3JtYXR0ZWQgPSB2b2lkIDA7XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuZGF0ZUZvcm1hdCkge1xuXHRcdCAgICAgICAgICAgICAgICBmb3JtYXR0ZWQgPSBkYXRldGltZV8xLkRhdGVUaW1lLm1vbWVudEZvcm1hdERhdGUoZGF0ZU5nTW9kZWxfMSwgdGhpcy5kYXRlRm9ybWF0KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IGRhdGV0aW1lXzEuRGF0ZVRpbWUuZm9ybWF0RGF0ZShkYXRlTmdNb2RlbF8xLCB0aGlzLmRhdGVPbmx5KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgdGhpcy5fZWxbJ3ZhbHVlJ10gPSBmb3JtYXR0ZWQ7XG5cdFx0ICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBkYXRlTmdNb2RlbF8xO1xuXHRcdCAgICAgICAgICAgIC8vIEBkZXByZWNhdGVkXG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXMuZGF0ZUZvcm1hdCkge1xuXHRcdCAgICAgICAgICAgICAgICBkYXRlTmdNb2RlbF8xLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGV0aW1lXzEuRGF0ZVRpbWUubW9tZW50Rm9ybWF0RGF0ZShkYXRlTmdNb2RlbF8xLCBfdGhpcy5kYXRlRm9ybWF0KTtcblx0XHQgICAgICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGRhdGVOZ01vZGVsXzEudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVfMS5EYXRlVGltZS5mb3JtYXREYXRlKGRhdGVOZ01vZGVsXzEsIF90aGlzLmRhdGVPbmx5KTtcblx0XHQgICAgICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLm5nTW9kZWxDaGFuZ2UuZW1pdChkYXRlTmdNb2RlbF8xKTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICB0aGlzLl9pbml0RGF0ZSgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBEYXRlVGltZVBpY2tlckRpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAvLyBhZGQgYSBjbGljayBsaXN0ZW5lciB0byBkb2N1bWVudCwgc28gdGhhdCBpdCBjYW4gaGlkZSB3aGVuIG90aGVycyBjbGlja2VkXG5cdFx0ICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlRGF0ZXRpbWVQaWNrZXIpO1xuXHRcdCAgICAgICAgdGhpcy5fZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9rZXlFdmVudExpc3RlbmVyKTtcblx0XHQgICAgICAgIGlmICh0aGlzLl9kYXRldGltZVBpY2tlcikge1xuXHRcdCAgICAgICAgICAgIHRoaXMuX2RhdGV0aW1lUGlja2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5RXZlbnRMaXN0ZW5lcik7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH07XG5cdFx0ICAgIC8vc2hvdyBkYXRldGltZVBpY2tlciBiZWxvdyB0aGUgY3VycmVudCBlbGVtZW50XG5cdFx0ICAgIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlLnByb3RvdHlwZS5zaG93RGF0ZXRpbWVQaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudFJlZikge1xuXHRcdCAgICAgICAgICAgIHJldHVybjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5fcmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoZGF0ZXRpbWVfcGlja2VyX2NvbXBvbmVudF8xLkRhdGVUaW1lUGlja2VyQ29tcG9uZW50KTtcblx0XHQgICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZiA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xuXHRcdCAgICAgICAgdGhpcy5fZGF0ZXRpbWVQaWNrZXIgPSB0aGlzLl9jb21wb25lbnRSZWYubG9jYXRpb24ubmF0aXZlRWxlbWVudDtcblx0XHQgICAgICAgIHRoaXMuX2RhdGV0aW1lUGlja2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5RXZlbnRMaXN0ZW5lcik7XG5cdFx0ICAgICAgICB0aGlzLl9pbml0RGF0ZSgpO1xuXHRcdCAgICAgICAgdGhpcy5fc3R5bGVEYXRldGltZVBpY2tlcigpO1xuXHRcdCAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZTtcblx0XHQgICAgICAgIGNvbXBvbmVudC5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoY2hhbmdlcykge1xuXHRcdCAgICAgICAgICAgIHZhciBuZXdOZ01vZGVsID0gbmV3IERhdGUoY2hhbmdlcy5zZWxlY3RlZERhdGUpO1xuXHRcdCAgICAgICAgICAgIG5ld05nTW9kZWwuc2V0SG91cnMocGFyc2VJbnQoY2hhbmdlcy5ob3VyLCAxMCkpO1xuXHRcdCAgICAgICAgICAgIG5ld05nTW9kZWwuc2V0TWludXRlcyhwYXJzZUludChjaGFuZ2VzLm1pbnV0ZSwgMTApKTtcblx0XHQgICAgICAgICAgICB2YXIgZm9ybWF0dGVkO1xuXHRcdCAgICAgICAgICAgIGlmIChfdGhpcy5kYXRlRm9ybWF0KSB7XG5cdFx0ICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IGRhdGV0aW1lXzEuRGF0ZVRpbWUubW9tZW50Rm9ybWF0RGF0ZShuZXdOZ01vZGVsLCBfdGhpcy5kYXRlRm9ybWF0KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIGZvcm1hdHRlZCA9IGRhdGV0aW1lXzEuRGF0ZVRpbWUuZm9ybWF0RGF0ZShuZXdOZ01vZGVsLCBfdGhpcy5kYXRlT25seSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIF90aGlzLl9lbFsndmFsdWUnXSA9IGZvcm1hdHRlZDtcblx0XHQgICAgICAgICAgICBfdGhpcy5fdmFsdWUgPSBuZXdOZ01vZGVsO1xuXHRcdCAgICAgICAgICAgIF90aGlzLnZhbHVlQ2hhbmdlLmVtaXQobmV3TmdNb2RlbCk7XG5cdFx0ICAgICAgICAgICAgLy8gQGRlcHJlY2F0ZWRcblx0XHQgICAgICAgICAgICBpZiAoX3RoaXMuZGF0ZUZvcm1hdCkge1xuXHRcdCAgICAgICAgICAgICAgICBuZXdOZ01vZGVsLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGV0aW1lXzEuRGF0ZVRpbWUubW9tZW50Rm9ybWF0RGF0ZShuZXdOZ01vZGVsLCBfdGhpcy5kYXRlRm9ybWF0KTtcblx0XHQgICAgICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIG5ld05nTW9kZWwudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZXRpbWVfMS5EYXRlVGltZS5mb3JtYXREYXRlKG5ld05nTW9kZWwsIF90aGlzLmRhdGVPbmx5KTtcblx0XHQgICAgICAgICAgICAgICAgfTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgX3RoaXMubmdNb2RlbENoYW5nZS5lbWl0KG5ld05nTW9kZWwpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICBjb21wb25lbnQuY2xvc2luZy5zdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgICAgIGlmIChfdGhpcy5jbG9zZU9uU2VsZWN0ICE9PSBcImZhbHNlXCIpIHtcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMuaGlkZURhdGV0aW1lUGlja2VyKCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlLnByb3RvdHlwZS5fZWxlbWVudEluID0gZnVuY3Rpb24gKGVsLCBjb250YWluZXJFbCkge1xuXHRcdCAgICAgICAgd2hpbGUgKGVsID0gZWwucGFyZW50Tm9kZSkge1xuXHRcdCAgICAgICAgICAgIGlmIChlbCA9PT0gY29udGFpbmVyRWwpXG5cdFx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHRcdCAgICB9O1xuXHRcdCAgICBEYXRlVGltZVBpY2tlckRpcmVjdGl2ZS5wcm90b3R5cGUuX2luaXREYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudFJlZikge1xuXHRcdCAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2U7XG5cdFx0ICAgICAgICAgICAgY29tcG9uZW50LmluaXREYXRlVGltZSh0aGlzLl92YWx1ZSk7XG5cdFx0ICAgICAgICAgICAgY29tcG9uZW50LmRhdGVPbmx5ID0gdGhpcy5kYXRlT25seTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfTtcblx0XHQgICAgRGF0ZVRpbWVQaWNrZXJEaXJlY3RpdmUucHJvdG90eXBlLl9yZWdpc3RlckV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgLy8gYWRkIGEgY2xpY2sgbGlzdGVuZXIgdG8gZG9jdW1lbnQsIHNvIHRoYXQgaXQgY2FuIGhpZGUgd2hlbiBvdGhlcnMgY2xpY2tlZFxuXHRcdCAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGlkZURhdGV0aW1lUGlja2VyKTtcblx0XHQgICAgICAgIHRoaXMuX2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fa2V5RXZlbnRMaXN0ZW5lcik7XG5cdFx0ICAgIH07XG5cdFx0ICAgIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlLnByb3RvdHlwZS5fc3R5bGVEYXRldGltZVBpY2tlciA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICAvLyBzZXR0aW5nIHdpZHRoL2hlaWdodCBhdXRvIGNvbXBsZXRlXG5cdFx0ICAgICAgICB2YXIgdGhpc0VsQkNSID0gdGhpcy5fZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0ICAgICAgICB0aGlzLl9kYXRldGltZVBpY2tlci5zdHlsZS53aWR0aCA9IHRoaXNFbEJDUi53aWR0aCArICdweCc7XG5cdFx0ICAgICAgICB0aGlzLl9kYXRldGltZVBpY2tlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cdFx0ICAgICAgICB0aGlzLl9kYXRldGltZVBpY2tlci5zdHlsZS56SW5kZXggPSAnMTAwMCc7XG5cdFx0ICAgICAgICB0aGlzLl9kYXRldGltZVBpY2tlci5zdHlsZS5sZWZ0ID0gJzAnO1xuXHRcdCAgICAgICAgdGhpcy5fZGF0ZXRpbWVQaWNrZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdoZWlnaHQgMC4zcyBlYXNlLWluJztcblx0XHQgICAgICAgIHRoaXMuX2RhdGV0aW1lUGlja2VyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblx0XHQgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgICAgIHZhciB0aGlzRWxCY3IgPSBfdGhpcy5fZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0ICAgICAgICAgICAgdmFyIGRhdGV0aW1lUGlja2VyRWxCY3IgPSBfdGhpcy5fZGF0ZXRpbWVQaWNrZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0ICAgICAgICAgICAgaWYgKHRoaXNFbEJjci5ib3R0b20gKyBkYXRldGltZVBpY2tlckVsQmNyLmhlaWdodCA+IHdpbmRvdy5pbm5lckhlaWdodCkge1xuXHRcdCAgICAgICAgICAgICAgICAvLyBpZiBub3QgZW5vdWdoIHNwYWNlIHRvIHNob3cgb24gYmVsb3csIHNob3cgYWJvdmVcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMuX2RhdGV0aW1lUGlja2VyLnN0eWxlLmJvdHRvbSA9ICcwJztcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgc2hvdyBiZWxvd1xuXHRcdCAgICAgICAgICAgICAgICBfdGhpcy5fZGF0ZXRpbWVQaWNrZXIuc3R5bGUudG9wID0gdGhpc0VsQmNyLmhlaWdodCArICdweCc7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIF90aGlzLl9kYXRldGltZVBpY2tlci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIDtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoJ2RhdGUtZm9ybWF0JyksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYXRlRm9ybWF0XCIsIHZvaWQgMCk7XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KCdkYXRlLW9ubHknKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG5cdFx0ICAgIF0sIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYXRlT25seVwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dCgnY2xvc2Utb24tc2VsZWN0JyksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjbG9zZU9uU2VsZWN0XCIsIHZvaWQgMCk7XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KCksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBEYXRlKVxuXHRcdCAgICBdLCBEYXRlVGltZVBpY2tlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmdNb2RlbFwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5PdXRwdXQoKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIGNvcmVfMS5FdmVudEVtaXR0ZXIpXG5cdFx0ICAgIF0sIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJuZ01vZGVsQ2hhbmdlXCIsIHZvaWQgMCk7XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KCd2YWx1ZScpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuXHRcdCAgICBdLCBEYXRlVGltZVBpY2tlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuT3V0cHV0KCd2YWx1ZUNoYW5nZScpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgY29yZV8xLkV2ZW50RW1pdHRlcilcblx0XHQgICAgXSwgRGF0ZVRpbWVQaWNrZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5cdFx0ICAgIERhdGVUaW1lUGlja2VyRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHtcblx0XHQgICAgICAgICAgICBzZWxlY3RvcjogJ1tkYXRldGltZS1waWNrZXJdLCBbbmcyLWRhdGV0aW1lLXBpY2tlcl0nLFxuXHRcdCAgICAgICAgICAgIHByb3ZpZGVyczogW2RhdGV0aW1lXzEuRGF0ZVRpbWVdLFxuXHRcdCAgICAgICAgICAgIGhvc3Q6IHtcblx0XHQgICAgICAgICAgICAgICAgJyhjbGljayknOiAnc2hvd0RhdGV0aW1lUGlja2VyKCknXG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgY29yZV8xLlZpZXdDb250YWluZXJSZWZdKVxuXHRcdCAgICBdLCBEYXRlVGltZVBpY2tlckRpcmVjdGl2ZSk7XG5cdFx0ICAgIHJldHVybiBEYXRlVGltZVBpY2tlckRpcmVjdGl2ZTtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuRGF0ZVRpbWVQaWNrZXJEaXJlY3RpdmUgPSBEYXRlVGltZVBpY2tlckRpcmVjdGl2ZTtcblx0XG5cdFxuXHQvKioqLyB9XG5cdC8qKioqKiovIF0pXG5cdH0pO1xuXHQ7XG5cdC8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nMi1kYXRldGltZS1waWNrZXIudW1kLmpzLm1hcFxuXG4vKioqLyB9LFxuLyogMTEgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdChmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdFx0aWYodHJ1ZSlcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcblx0XHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRcdGRlZmluZShbXCJAYW5ndWxhci9jb3JlXCIsIFwiQGFuZ3VsYXIvZm9ybXNcIiwgXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCJdLCBmYWN0b3J5KTtcblx0XHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRcdGV4cG9ydHNbXCJuZzItY29sbGFwc2FibGVcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIpKTtcblx0XHRlbHNlXG5cdFx0XHRyb290W1wibmcyLWNvbGxhcHNhYmxlXCJdID0gZmFjdG9yeShyb290W1wiQGFuZ3VsYXIvY29yZVwiXSwgcm9vdFtcIkBhbmd1bGFyL2Zvcm1zXCJdLCByb290W1wiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSk7XG5cdH0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcblx0cmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcblx0LyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdC8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0LyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0LyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG5cdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0LyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuXHQvKioqKioqLyBcdFx0fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdC8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdC8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG5cdC8qKioqKiovIFx0fVxuXHQvKioqKioqL1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHQvKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXHQvKioqKioqLyB9KVxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqLyAoW1xuXHQvKiAwICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIGZvcm1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdHZhciBwbGF0Zm9ybV9icm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcdHZhciBuZzJfY29sbGFwc2FibGVfY29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcdGV4cG9ydHMuTmcyQ29sbGFwc2FibGVDb21wb25lbnQgPSBuZzJfY29sbGFwc2FibGVfY29tcG9uZW50XzEuTmcyQ29sbGFwc2FibGVDb21wb25lbnQ7XG5cdFx0dmFyIE5nMkNvbGxhcHNhYmxlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTmcyQ29sbGFwc2FibGVNb2R1bGUoKSB7XG5cdFx0ICAgIH1cblx0XHQgICAgTmcyQ29sbGFwc2FibGVNb2R1bGUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5OZ01vZHVsZSh7XG5cdFx0ICAgICAgICAgICAgaW1wb3J0czogW3BsYXRmb3JtX2Jyb3dzZXJfMS5Ccm93c2VyTW9kdWxlLCBmb3Jtc18xLkZvcm1zTW9kdWxlXSxcblx0XHQgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtuZzJfY29sbGFwc2FibGVfY29tcG9uZW50XzEuTmcyQ29sbGFwc2FibGVDb21wb25lbnRdLFxuXHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtuZzJfY29sbGFwc2FibGVfY29tcG9uZW50XzEuTmcyQ29sbGFwc2FibGVDb21wb25lbnRdXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBOZzJDb2xsYXBzYWJsZU1vZHVsZSk7XG5cdFx0ICAgIHJldHVybiBOZzJDb2xsYXBzYWJsZU1vZHVsZTtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuTmcyQ29sbGFwc2FibGVNb2R1bGUgPSBOZzJDb2xsYXBzYWJsZU1vZHVsZTtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAxICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogMiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDMgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA0ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIE5nMkNvbGxhcHNhYmxlQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTmcyQ29sbGFwc2FibGVDb21wb25lbnQodmlld0NvbnRhaW5lcikge1xuXHRcdCAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcblx0XHQgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleENsYXNzID0gJ3NlbGVjdGVkJztcblx0XHQgICAgICAgIHRoaXMuc2VsZWN0ZWRDb250ZW50c0NsYXNzID0gJ3NlbGVjdGVkJztcblx0XHQgICAgICAgIHRoaXMuZWwgPSB0aGlzLnZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMkNvbGxhcHNhYmxlQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdGhpcy5pbmRleEVscyA9IFtdLnNsaWNlLmNhbGwodGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5kZXhdJykpO1xuXHRcdCAgICAgICAgdGhpcy5jb250ZW50c0VscyA9IFtdLnNsaWNlLmNhbGwodGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKCdbY29udGVudHNdJykpO1xuXHRcdCAgICAgICAgdGhpcy5zZWxlY3RUYWIodGhpcy5zZWxlY3RlZEluZGV4KTtcblx0XHQgICAgICAgIHRoaXMuaW5kZXhFbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblx0XHQgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMuc2VsZWN0VGFiKGVsLmdldEF0dHJpYnV0ZSgnaW5kZXgnKSk7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfTtcblx0XHQgICAgTmcyQ29sbGFwc2FibGVDb21wb25lbnQucHJvdG90eXBlLnNlbGVjdFRhYiA9IGZ1bmN0aW9uIChpZCkge1xuXHRcdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XHQgICAgICAgIGlkID0gaWQgfHwgdGhpcy5pbmRleEVsc1swXS5nZXRBdHRyaWJ1dGUoJ2luZGV4Jyk7XG5cdFx0ICAgICAgICB0aGlzLmluZGV4RWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cdFx0ICAgICAgICAgICAgX3RoaXMucmVtb3ZlQ2xhc3MoZWwsIF90aGlzLnNlbGVjdGVkSW5kZXhDbGFzcyk7XG5cdFx0ICAgICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnaW5kZXgnKSA9PSBpZCkge1xuXHRcdCAgICAgICAgICAgICAgICBfdGhpcy5hZGRDbGFzcyhlbCwgX3RoaXMuc2VsZWN0ZWRJbmRleENsYXNzKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHRoaXMuY29udGVudHNFbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblx0XHQgICAgICAgICAgICBfdGhpcy5yZW1vdmVDbGFzcyhlbCwgX3RoaXMuc2VsZWN0ZWRDb250ZW50c0NsYXNzKTtcblx0XHQgICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50cycpID09IGlkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLmFkZENsYXNzKGVsLCBfdGhpcy5zZWxlY3RlZENvbnRlbnRzQ2xhc3MpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJDb2xsYXBzYWJsZUNvbXBvbmVudC5wcm90b3R5cGUuYWRkQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIHN0cikge1xuXHRcdCAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSAoZWwuY2xhc3NOYW1lIHx8ICcnKS5zcGxpdCgnICcpO1xuXHRcdCAgICAgICAgY2xhc3NOYW1lcy5wdXNoKHN0cik7XG5cdFx0ICAgICAgICBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcblx0XHQgICAgfTtcblx0XHQgICAgTmcyQ29sbGFwc2FibGVDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsLCBzdHIpIHtcblx0XHQgICAgICAgIGVsLmNsYXNzTmFtZSA9IChlbC5jbGFzc05hbWUgfHwgJycpLnJlcGxhY2UobmV3IFJlZ0V4cCgnWyBdKicgKyBzdHIpLCAnJyk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KCdzZWxlY3RlZCcpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuXHRcdCAgICBdLCBOZzJDb2xsYXBzYWJsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dCgnc2VsZWN0ZWQtaW5kZXgtY2xhc3MnKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgTmcyQ29sbGFwc2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkSW5kZXhDbGFzc1wiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dCgnc2VsZWN0ZWQtY29udGVudHMtY2xhc3MnKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgTmcyQ29sbGFwc2FibGVDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkQ29udGVudHNDbGFzc1wiLCB2b2lkIDApO1xuXHRcdCAgICBOZzJDb2xsYXBzYWJsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkNvbXBvbmVudCh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICduZzItY29sbGFwc2FibGUsIFtuZzItY29sbGFwc2FibGVdJyxcblx0XHQgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBjb3JlXzEuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcblx0XHQgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG5cdFx0ICAgICAgICAgICAgc3R5bGVzOiBbXCJcXG4gICAgW25nMi1jb2xsYXBzYWJsZV0gW2luZGV4XSB7XFxuICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICBtYXJnaW46IDJweCAwIDAgMDtcXG4gICAgICBwYWRkaW5nOiAuNWVtIC41ZW0gLjVlbSAuN2VtO1xcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2NjY2M7XFxuICAgICAgYmFja2dyb3VuZDogI2VkZWRlZDtcXG4gICAgICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweDsgXFxuICAgICAgY29sb3I6ICMyYjJiMmI7XFxuICAgIH1cXG4gICAgW25nMi1jb2xsYXBzYWJsZV0gW2luZGV4XS5zZWxlY3RlZCB7XFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgIzAwM2VmZjtcXG4gICAgICBiYWNrZ3JvdW5kOiAjMDA3ZmZmO1xcbiAgICAgIGNvbG9yOiAjZmZmZmZmO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweCAycHggMCAwO1xcbiAgICB9XFxuICAgIFtuZzItY29sbGFwc2FibGVdIFtjb250ZW50c10ge1xcbiAgICAgIGJvcmRlci10b3A6IDA7XFxuICAgICAgYmFja2dyb3VuZDogI2ZmZmZmZjtcXG4gICAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgICBwYWRkaW5nOiAwcHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMCAwIDJweCAycHg7XFxuICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgIGJvcmRlcjogMDtcXG4gICAgICBmb250LXNpemU6IDA7XFxuICAgIH1cXG4gICAgW25nMi1jb2xsYXBzYWJsZV0gW2NvbnRlbnRzXS5zZWxlY3RlZCB7XFxuICAgICAgaGVpZ2h0OiA1MHB4O1xcbiAgICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgI2RkZGRkZDtcXG4gICAgICB0cmFuc2l0aW9uOiBmb250LXNpemUgMC4zcyBlYXNlLWluLCBoZWlnaHQgMC4zcyBlYXNlLWluO1xcbiAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgfVxcbiAgXCJdLFxuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLlZpZXdDb250YWluZXJSZWZdKVxuXHRcdCAgICBdLCBOZzJDb2xsYXBzYWJsZUNvbXBvbmVudCk7XG5cdFx0ICAgIHJldHVybiBOZzJDb2xsYXBzYWJsZUNvbXBvbmVudDtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuTmcyQ29sbGFwc2FibGVDb21wb25lbnQgPSBOZzJDb2xsYXBzYWJsZUNvbXBvbmVudDtcblx0XG5cdFxuXHQvKioqLyB9XG5cdC8qKioqKiovIF0pXG5cdH0pO1xuXHQ7XG5cdC8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nMi1jb2xsYXBzYWJsZS51bWQuanMubWFwXG5cbi8qKiovIH0sXG4vKiAxMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRpZih0cnVlKVxuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMSksIF9fd2VicGFja19yZXF1aXJlX18oMiksIF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0ZGVmaW5lKFtcIkBhbmd1bGFyL2NvcmVcIiwgXCJAYW5ndWxhci9mb3Jtc1wiLCBcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0sIGZhY3RvcnkpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdFx0ZXhwb3J0c1tcIm5nMi1pbmZpbml0ZS1saXN0XCJdID0gZmFjdG9yeShyZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKSwgcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cm9vdFtcIm5nMi1pbmZpbml0ZS1saXN0XCJdID0gZmFjdG9yeShyb290W1wiQGFuZ3VsYXIvY29yZVwiXSwgcm9vdFtcIkBhbmd1bGFyL2Zvcm1zXCJdLCByb290W1wiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSk7XG5cdH0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcblx0cmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcblx0LyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdC8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0LyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0LyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG5cdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0LyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuXHQvKioqKioqLyBcdFx0fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdC8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdC8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG5cdC8qKioqKiovIFx0fVxuXHQvKioqKioqL1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHQvKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXHQvKioqKioqLyB9KVxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqLyAoW1xuXHQvKiAwICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIGZvcm1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdHZhciBwbGF0Zm9ybV9icm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcdHZhciBuZzJfaW5maW5pdGVfbGlzdF9kaXJlY3RpdmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0ZXhwb3J0cy5OZzJJbmZpbml0ZUxpc3REaXJlY3RpdmUgPSBuZzJfaW5maW5pdGVfbGlzdF9kaXJlY3RpdmVfMS5OZzJJbmZpbml0ZUxpc3REaXJlY3RpdmU7XG5cdFx0dmFyIE5nMkluZmluaXRlTGlzdE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMkluZmluaXRlTGlzdE1vZHVsZSgpIHtcblx0XHQgICAgfVxuXHRcdCAgICBOZzJJbmZpbml0ZUxpc3RNb2R1bGUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5OZ01vZHVsZSh7XG5cdFx0ICAgICAgICAgICAgaW1wb3J0czogW3BsYXRmb3JtX2Jyb3dzZXJfMS5Ccm93c2VyTW9kdWxlLCBmb3Jtc18xLkZvcm1zTW9kdWxlXSxcblx0XHQgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtuZzJfaW5maW5pdGVfbGlzdF9kaXJlY3RpdmVfMS5OZzJJbmZpbml0ZUxpc3REaXJlY3RpdmVdLFxuXHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtuZzJfaW5maW5pdGVfbGlzdF9kaXJlY3RpdmVfMS5OZzJJbmZpbml0ZUxpc3REaXJlY3RpdmVdXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBOZzJJbmZpbml0ZUxpc3RNb2R1bGUpO1xuXHRcdCAgICByZXR1cm4gTmcySW5maW5pdGVMaXN0TW9kdWxlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJJbmZpbml0ZUxpc3RNb2R1bGUgPSBOZzJJbmZpbml0ZUxpc3RNb2R1bGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAzICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogNCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBuZzJfdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFx0dmFyIE5nMkluZmluaXRlTGlzdERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMkluZmluaXRlTGlzdERpcmVjdGl2ZShlbCkge1xuXHRcdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XHQgICAgICAgIHRoaXMuZW5kVmlzaWJsZSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7XG5cdFx0ICAgICAgICB0aGlzLmVsZW1lbnRWaXNpYmxlID0gbmcyX3V0aWxzXzEuZWxlbWVudFZpc2libGU7XG5cdFx0ICAgICAgICB0aGlzLnNjcm9sbExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgICAgIHZhciB2aXNpYmxlID0gX3RoaXMuZWxlbWVudFZpc2libGUoX3RoaXMuZW5kRWwsIF90aGlzLmVsKTtcblx0XHQgICAgICAgICAgICBpZiAoX3RoaXMuaG9yaXpvbnRhbCAmJiAodmlzaWJsZS5sZWZ0IHx8IHZpc2libGUucmlnaHQpKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLmVuZFZpc2libGUuZW1pdCh0cnVlKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSBpZiAoIV90aGlzLmhvcml6b250YWwgJiYgKHZpc2libGUudG9wIHx8IHZpc2libGUuYm90dG9tKSkge1xuXHRcdCAgICAgICAgICAgICAgICBfdGhpcy5lbmRWaXNpYmxlLmVtaXQodHJ1ZSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIHRoaXMuZWwgPSBlbC5uYXRpdmVFbGVtZW50O1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIHNldHVwIGxpc3Qgb2Ygc2VjdGlvbnNcblx0XHQgICAgTmcySW5maW5pdGVMaXN0RGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHRoaXMuZW5kRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ1tuZzItaW5maW5pdGUtbGlzdC1lbmRdJyk7XG5cdFx0ICAgICAgICBpZiAoIXRoaXMuZW5kRWwpIHtcblx0XHQgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgJ25nMi1pbmZpbml0ZS1saXN0LWVuZFwiO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdGhpcy5zY3JvbGxMaXN0ZW5lcigpO1xuXHRcdCAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnNjcm9sbExpc3RlbmVyKTtcblx0XHQgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnNjcm9sbExpc3RlbmVyKTtcblx0XHQgICAgfTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG5cdFx0ICAgIF0sIE5nMkluZmluaXRlTGlzdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbFwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5PdXRwdXQoKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIE9iamVjdClcblx0XHQgICAgXSwgTmcySW5maW5pdGVMaXN0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbmRWaXNpYmxlXCIsIHZvaWQgMCk7XG5cdFx0ICAgIE5nMkluZmluaXRlTGlzdERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkRpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25nMi1pbmZpbml0ZS1saXN0XScgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLkVsZW1lbnRSZWZdKVxuXHRcdCAgICBdLCBOZzJJbmZpbml0ZUxpc3REaXJlY3RpdmUpO1xuXHRcdCAgICByZXR1cm4gTmcySW5maW5pdGVMaXN0RGlyZWN0aXZlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJJbmZpbml0ZUxpc3REaXJlY3RpdmUgPSBOZzJJbmZpbml0ZUxpc3REaXJlY3RpdmU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRcdGlmKHRydWUpXG5cdFx0XHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcblx0XHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiXSwgZmFjdG9yeSk7XG5cdFx0XHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRcdFx0ZXhwb3J0c1tcIm5nMi11dGlsc1wiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIikpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyb290W1wibmcyLXV0aWxzXCJdID0gZmFjdG9yeShyb290W1wiQGFuZ3VsYXIvY29yZVwiXSk7XG5cdFx0fSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18pIHtcblx0XHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHRcdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHRcdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0XHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0XHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdFx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0XHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHRcdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHRcdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdFx0LyoqKioqKi8gXHRcdH07XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdFx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0XHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0XHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHRcdC8qKioqKiovIFx0fVxuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdFx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHRcdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0XHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHRcdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdFx0LyoqKioqKi8gfSlcblx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRcdC8qKioqKiovIChbXG5cdFx0LyogMCAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHRcdH07XG5cdFx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0XHR2YXIgc2Nyb2xsX3RvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdFx0ZXhwb3J0cy5zY3JvbGxUbyA9IHNjcm9sbF90b18xLnNjcm9sbFRvO1xuXHRcdFx0dmFyIGVsZW1lbnRfdmlzaWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHRcdGV4cG9ydHMuZWxlbWVudFZpc2libGUgPSBlbGVtZW50X3Zpc2libGVfMS5lbGVtZW50VmlzaWJsZTtcblx0XHRcdHZhciBjb21wdXRlZF9zdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XHRcdGV4cG9ydHMuY29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkX3N0eWxlXzEuY29tcHV0ZWRTdHlsZTtcblx0XHRcdHZhciBvdXRlcl93aWR0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XHRcdGV4cG9ydHMub3V0ZXJXaWR0aCA9IG91dGVyX3dpZHRoXzEub3V0ZXJXaWR0aDtcblx0XHRcdHZhciBvdXRlcl9oZWlnaHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFx0XHRleHBvcnRzLm91dGVySGVpZ2h0ID0gb3V0ZXJfaGVpZ2h0XzEub3V0ZXJIZWlnaHQ7XG5cdFx0XHR2YXIgTmcyVXRpbHNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgIGZ1bmN0aW9uIE5nMlV0aWxzTW9kdWxlKCkge1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBOZzJVdGlsc01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHRcdFx0ICAgICAgICBjb3JlXzEuTmdNb2R1bGUoe1xuXHRcdFx0ICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG5cdFx0XHQgICAgICAgICAgICAgICAgc2Nyb2xsX3RvXzEuc2Nyb2xsVG8sXG5cdFx0XHQgICAgICAgICAgICAgICAgZWxlbWVudF92aXNpYmxlXzEuZWxlbWVudFZpc2libGUsXG5cdFx0XHQgICAgICAgICAgICAgICAgY29tcHV0ZWRfc3R5bGVfMS5jb21wdXRlZFN0eWxlLFxuXHRcdFx0ICAgICAgICAgICAgICAgIG91dGVyX3dpZHRoXzEub3V0ZXJXaWR0aCxcblx0XHRcdCAgICAgICAgICAgICAgICBvdXRlcl9oZWlnaHRfMS5vdXRlckhlaWdodFxuXHRcdFx0ICAgICAgICAgICAgXSxcblx0XHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtcblx0XHRcdCAgICAgICAgICAgICAgICBzY3JvbGxfdG9fMS5zY3JvbGxUbyxcblx0XHRcdCAgICAgICAgICAgICAgICBlbGVtZW50X3Zpc2libGVfMS5lbGVtZW50VmlzaWJsZSxcblx0XHRcdCAgICAgICAgICAgICAgICBjb21wdXRlZF9zdHlsZV8xLmNvbXB1dGVkU3R5bGUsXG5cdFx0XHQgICAgICAgICAgICAgICAgb3V0ZXJfd2lkdGhfMS5vdXRlcldpZHRoLFxuXHRcdFx0ICAgICAgICAgICAgICAgIG91dGVyX2hlaWdodF8xLm91dGVySGVpZ2h0XG5cdFx0XHQgICAgICAgICAgICBdXG5cdFx0XHQgICAgICAgIH0pLCBcblx0XHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0XHRcdCAgICBdLCBOZzJVdGlsc01vZHVsZSk7XG5cdFx0XHQgICAgcmV0dXJuIE5nMlV0aWxzTW9kdWxlO1xuXHRcdFx0fSgpKTtcblx0XHRcdGV4cG9ydHMuTmcyVXRpbHNNb2R1bGUgPSBOZzJVdGlsc01vZHVsZTtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDEgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX187XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiAyICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdC8qKlxuXHRcdFx0ICogc2Nyb2xsIHRvIHRoZSBzZWxlY3RvciB3aXRoaW4gdGhlIHBhcmVudCBzZWxlY3RvciBieSBzY3JvbGxpbmcgMTAgdGltZXMgd2l0aGluIDUwMG1zXG5cdFx0XHQgKiBAcGFyYW0gc2VsZWN0b3Jcblx0XHRcdCAqIEBwYXJhbSBwYXJlbnRTZWxlY3RvclxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBzY3JvbGxUbyhzZWxlY3RvciwgcGFyZW50U2VsZWN0b3IpIHtcblx0XHRcdCAgICBjb25zb2xlLmxvZygnc2VsZWN0b3InLCBzZWxlY3RvciwgJ3BhcmVudFNlbGVjdG9yJywgcGFyZW50U2VsZWN0b3IpO1xuXHRcdFx0ICAgIHZhciBwYXJlbnRFbCwgdGFyZ2V0RWw7XG5cdFx0XHQgICAgdGFyZ2V0RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblx0XHRcdCAgICBpZiAoIXRhcmdldEVsKSB7XG5cdFx0XHQgICAgICAgIHRocm93IFwiSW52YWxpZCBzZWxlY3RvciBcIiArIHNlbGVjdG9yO1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBwYXJlbnRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyZW50U2VsZWN0b3IpO1xuXHRcdFx0ICAgIGlmICghcGFyZW50RWwpIHtcblx0XHRcdCAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHBhcmVudCBzZWxlY3RvciBcIiArIHBhcmVudFNlbGVjdG9yO1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICB2YXIgcGFyZW50RWxTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudEVsKTtcblx0XHRcdCAgICBwYXJlbnRFbCA9IHBhcmVudEVsU3R5bGVbJ292ZXJmbG93J10gPT09ICdhdXRvJyA/IHBhcmVudEVsIDogZG9jdW1lbnQuYm9keTtcblx0XHRcdCAgICB2YXIgY3VycmVudFNjcm9sbFRvcCA9IHBhcmVudEVsLnNjcm9sbFRvcDtcblx0XHRcdCAgICB2YXIgdGFyZ2V0T2Zmc2V0VG9wID0gdGFyZ2V0RWwub2Zmc2V0VG9wO1xuXHRcdFx0ICAgIGlmIChwYXJlbnRFbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuXHRcdFx0ICAgICAgICB2YXIgYm9keVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ICAgICAgICB2YXIgdGFyZ2V0UmVjdCA9IHRhcmdldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ICAgICAgICB0YXJnZXRPZmZzZXRUb3AgPSB0YXJnZXRSZWN0LnRvcCAtIGJvZHlSZWN0LnRvcDtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgdmFyIHN0ZXAgPSBNYXRoLmNlaWwoKHRhcmdldE9mZnNldFRvcCAtIGN1cnJlbnRTY3JvbGxUb3ApIC8gMTApO1xuXHRcdFx0ICAgIChmdW5jdGlvbiBsb29wKGkpIHtcblx0XHRcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiBtYWluKCkge1xuXHRcdFx0ICAgICAgICAgICAgcGFyZW50RWwuc2Nyb2xsVG9wICs9IHN0ZXA7XG5cdFx0XHQgICAgICAgICAgICBpID4gMSAmJiBsb29wKGkgLSAxKTtcblx0XHRcdCAgICAgICAgfSwgNTApO1xuXHRcdFx0ICAgIH0oMTApKTtcblx0XHRcdH1cblx0XHRcdGV4cG9ydHMuc2Nyb2xsVG8gPSBzY3JvbGxUbztcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDMgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIGFuIGVsZW1lbnQgaXMgdmlzaWJsZSB3aXRoaW4gb3V0ZXIgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIGlubmVyRWxcblx0XHRcdCAqIEBwYXJhbSBvdXRlckVsXG5cdFx0XHQgKiBAcGFyYW0gYWRqdXN0bWVudFxuXHRcdFx0ICogQHJldHVybnMge3t0b3A6IGJvb2xlYW4sIGJvdHRvbTogYm9vbGVhbiwgbGVmdDogYm9vbGVhbiwgcmlnaHQ6IGJvb2xlYW59fVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBlbGVtZW50VmlzaWJsZShpbm5lckVsLCBvdXRlckVsLCBhZGp1c3RtZW50KSB7XG5cdFx0XHQgICAgdmFyIGlubmVyUmVjdCA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHQgICAgdmFyIGJvdHRvbUFkanVzdG1lbnQgPSAoYWRqdXN0bWVudCAmJiBhZGp1c3RtZW50LmJvdHRvbSB8fCAwKTtcblx0XHRcdCAgICBpZiAob3V0ZXJFbCA9PT0gd2luZG93KSB7XG5cdFx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0XHQgICAgICAgICAgICB0b3A6IGlubmVyUmVjdC5ib3R0b20gLSBib3R0b21BZGp1c3RtZW50ID4gd2luZG93LmlubmVySGVpZ2h0XG5cdFx0XHQgICAgICAgICAgICAgICAgJiYgaW5uZXJSZWN0LnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCxcblx0XHRcdCAgICAgICAgICAgIGJvdHRvbTogaW5uZXJSZWN0LmJvdHRvbSAtIGJvdHRvbUFkanVzdG1lbnQgPiAwXG5cdFx0XHQgICAgICAgICAgICAgICAgJiYgaW5uZXJSZWN0LmJvdHRvbSA8IHdpbmRvdy5pbm5lckhlaWdodCxcblx0XHRcdCAgICAgICAgICAgIGxlZnQ6IGlubmVyUmVjdC5yaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoXG5cdFx0XHQgICAgICAgICAgICAgICAgJiYgaW5uZXJSZWN0LmxlZnQgPCB3aW5kb3cuaW5uZXJXaWR0aCxcblx0XHRcdCAgICAgICAgICAgIHJpZ2h0OiBpbm5lclJlY3QucmlnaHQgPiAwXG5cdFx0XHQgICAgICAgICAgICAgICAgJiYgaW5uZXJSZWN0LnJpZ2h0IDwgd2luZG93LmlubmVyV2lkdGhcblx0XHRcdCAgICAgICAgfTtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgZWxzZSB7XG5cdFx0XHQgICAgICAgIHZhciBvdXRlclJlY3QgPSBvdXRlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ICAgICAgICB2YXIgZGVmYXVsdFZpZXcgPSAoaW5uZXJFbC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KS5kZWZhdWx0Vmlldztcblx0XHRcdCAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG91dGVyRWwsIG51bGwpO1xuXHRcdFx0ICAgICAgICB2YXIgb3V0ZXJSZWN0Qm9yZGVyVG9wV2lkdGggPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSwgMTApO1xuXHRcdFx0ICAgICAgICB2YXIgb3V0ZXJSZWN0Qm9yZGVyTGVmdFdpZHRoID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItbGVmdC13aWR0aCcpLCAxMCk7XG5cdFx0XHQgICAgICAgIC8qIHRvcCBpcyB2aXNpYmxlIG9yIGJvdHRvbSBpcyB2aXNpYmxlICovXG5cdFx0XHQgICAgICAgIHZhciB0b3BWaXNpYmxlID0gKGlubmVyUmVjdC50b3AgPj0gb3V0ZXJSZWN0LnRvcFxuXHRcdFx0ICAgICAgICAgICAgJiYgaW5uZXJSZWN0LnRvcCA8IG91dGVyUmVjdC5ib3R0b20pO1xuXHRcdFx0ICAgICAgICB2YXIgYm90dG9tVmlzaWJsZSA9IChpbm5lclJlY3QuYm90dG9tID4gKG91dGVyUmVjdC50b3AgKyBvdXRlclJlY3RCb3JkZXJUb3BXaWR0aClcblx0XHRcdCAgICAgICAgICAgICYmIGlubmVyUmVjdC5ib3R0b20gPCBvdXRlclJlY3QuYm90dG9tKTtcblx0XHRcdCAgICAgICAgdmFyIGxlZnRWaXNpYmxlID0gKGlubmVyUmVjdC5sZWZ0ID49IG91dGVyUmVjdC5sZWZ0XG5cdFx0XHQgICAgICAgICAgICAmJiBpbm5lclJlY3QubGVmdCA8IG91dGVyUmVjdC5yaWdodCk7XG5cdFx0XHQgICAgICAgIHZhciByaWdodFZpc2libGUgPSAoaW5uZXJSZWN0LnJpZ2h0ID4gKG91dGVyUmVjdC5sZWZ0ICsgb3V0ZXJSZWN0Qm9yZGVyTGVmdFdpZHRoKVxuXHRcdFx0ICAgICAgICAgICAgJiYgaW5uZXJSZWN0LnJpZ2h0IDwgb3V0ZXJSZWN0LnJpZ2h0KTtcblx0XHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHRcdCAgICAgICAgICAgIHRvcDogdG9wVmlzaWJsZSxcblx0XHRcdCAgICAgICAgICAgIGJvdHRvbTogYm90dG9tVmlzaWJsZSxcblx0XHRcdCAgICAgICAgICAgIGxlZnQ6IGxlZnRWaXNpYmxlLFxuXHRcdFx0ICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0VmlzaWJsZVxuXHRcdFx0ICAgICAgICB9O1xuXHRcdFx0ICAgIH1cblx0XHRcdH1cblx0XHRcdGV4cG9ydHMuZWxlbWVudFZpc2libGUgPSBlbGVtZW50VmlzaWJsZTtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDQgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiByZXR1cm5zIGNvdW1wdXRlZCBzdHlsZSBvZiBnaXZlbiBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0gZWxcblx0XHRcdCAqIEBwYXJhbSBzdHlsZVByb3Bcblx0XHRcdCAqIEByZXR1cm5zIHthbnl9XG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIGNvbXB1dGVkU3R5bGUoZWwsIHN0eWxlUHJvcCkge1xuXHRcdFx0ICAgIHZhciB2YWx1ZSwgZGVmYXVsdFZpZXcgPSAoZWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkuZGVmYXVsdFZpZXc7XG5cdFx0XHQgICAgLy8gVzNDIHN0YW5kYXJkIHdheTpcblx0XHRcdCAgICBpZiAoZGVmYXVsdFZpZXcgJiYgZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuXHRcdFx0ICAgICAgICAvLyBzYW5pdGl6ZSBwcm9wZXJ0eSBuYW1lIHRvIGNzcyBub3RhdGlvblxuXHRcdFx0ICAgICAgICAvLyAoaHlwZW4gc2VwYXJhdGVkIHdvcmRzIGVnLiBmb250LVNpemUpXG5cdFx0XHQgICAgICAgIHN0eWxlUHJvcCA9IHN0eWxlUHJvcC5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHQgICAgICAgIHJldHVybiBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcCk7XG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIGVsc2UgaWYgKGVsWydjdXJyZW50U3R5bGUnXSkge1xuXHRcdFx0ICAgICAgICAvLyBzYW5pdGl6ZSBwcm9wZXJ0eSBuYW1lIHRvIGNhbWVsQ2FzZVxuXHRcdFx0ICAgICAgICBzdHlsZVByb3AgPSBzdHlsZVByb3AucmVwbGFjZSgvXFwtKFxcdykvZywgZnVuY3Rpb24gKHN0ciwgbGV0dGVyKSB7XG5cdFx0XHQgICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHQgICAgICAgIH0pO1xuXHRcdFx0ICAgICAgICB2YWx1ZSA9IGVsWydjdXJyZW50U3R5bGUnXVtzdHlsZVByb3BdO1xuXHRcdFx0ICAgICAgICAvLyBjb252ZXJ0IG90aGVyIHVuaXRzIHRvIHBpeGVscyBvbiBJRVxuXHRcdFx0ICAgICAgICBpZiAoL15cXGQrKGVtfHB0fCV8ZXgpPyQvaS50ZXN0KHZhbHVlKSkge1xuXHRcdFx0ICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdCAgICAgICAgICAgICAgICB2YXIgb2xkTGVmdCA9IGVsLnN0eWxlLmxlZnQsIG9sZFJzTGVmdCA9IGVsWydydW50aW1lU3R5bGUnXS5sZWZ0O1xuXHRcdFx0ICAgICAgICAgICAgICAgIGVsWydydW50aW1lU3R5bGUnXS5sZWZ0ID0gZWxbJ2N1cnJlbnRTdHlsZSddLmxlZnQ7XG5cdFx0XHQgICAgICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IHZhbHVlIHx8IDA7XG5cdFx0XHQgICAgICAgICAgICAgICAgdmFsdWUgPSBlbC5zdHlsZVsncGl4ZWxMZWZ0J10gKyBcInB4XCI7XG5cdFx0XHQgICAgICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IG9sZExlZnQ7XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxbJ3J1bnRpbWVTdHlsZSddLmxlZnQgPSBvbGRSc0xlZnQ7XG5cdFx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHRcdFx0ICAgICAgICAgICAgfSkodmFsdWUpO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0XHRcdCAgICB9XG5cdFx0XHR9XG5cdFx0XHRleHBvcnRzLmNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuXHRcdFxuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogNSAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHRmdW5jdGlvbiBvdXRlcldpZHRoKGVsKSB7XG5cdFx0XHQgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cdFx0XHQgICAgcmV0dXJuIGVsLm9mZnNldFdpZHRoICtcblx0XHRcdCAgICAgICAgcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSkgK1xuXHRcdFx0ICAgICAgICBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tcmlnaHQnKSk7XG5cdFx0XHR9XG5cdFx0XHRleHBvcnRzLm91dGVyV2lkdGggPSBvdXRlcldpZHRoO1xuXHRcdFxuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogNiAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHRmdW5jdGlvbiBvdXRlckhlaWdodChlbCkge1xuXHRcdFx0ICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuXHRcdFx0ICAgIHJldHVybiBlbC5vZmZzZXRIZWlnaHQgK1xuXHRcdFx0ICAgICAgICBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpICtcblx0XHRcdCAgICAgICAgcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcblx0XHRcdH1cblx0XHRcdGV4cG9ydHMub3V0ZXJIZWlnaHQgPSBvdXRlckhlaWdodDtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9XG5cdFx0LyoqKioqKi8gXSlcblx0XHR9KTtcblx0XHQ7XG5cdFx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLXV0aWxzLnVtZC5qcy5tYXBcblx0XG5cdC8qKiovIH1cblx0LyoqKioqKi8gXSlcblx0fSk7XG5cdDtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLWluZmluaXRlLWxpc3QudW1kLmpzLm1hcFxuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdChmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdFx0aWYodHJ1ZSlcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcblx0XHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRcdGRlZmluZShbXCJAYW5ndWxhci9jb3JlXCIsIFwiQGFuZ3VsYXIvY29tbW9uXCIsIFwicnhqcy9SeFwiXSwgZmFjdG9yeSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0XHRleHBvcnRzW1wibmcyLW1hcFwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9jb21tb25cIiksIHJlcXVpcmUoXCJyeGpzL1J4XCIpKTtcblx0XHRlbHNlXG5cdFx0XHRyb290W1wibmcyLW1hcFwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9jb21tb25cIl0sIHJvb3RbXCJyeGpzL1J4XCJdKTtcblx0fSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXykge1xuXHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHQvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdC8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcblx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQvKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcblx0LyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuXHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdC8qKioqKiovIFx0XHR9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0LyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0LyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0LyoqKioqKi8gXHR9XG5cdC8qKioqKiovXG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5cdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdC8qKioqKiovIH0pXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKiovIChbXG5cdC8qIDAgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgY29tbW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdHZhciBvcHRpb25fYnVpbGRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHRleHBvcnRzLk9wdGlvbkJ1aWxkZXIgPSBvcHRpb25fYnVpbGRlcl8xLk9wdGlvbkJ1aWxkZXI7XG5cdFx0dmFyIGdlb19jb2Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XHRleHBvcnRzLkdlb0NvZGVyID0gZ2VvX2NvZGVyXzEuR2VvQ29kZXI7XG5cdFx0dmFyIG5hdmlnYXRvcl9nZW9sb2NhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XHRleHBvcnRzLk5hdmlnYXRvckdlb2xvY2F0aW9uID0gbmF2aWdhdG9yX2dlb2xvY2F0aW9uXzEuTmF2aWdhdG9yR2VvbG9jYXRpb247XG5cdFx0dmFyIG5nMl9tYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cdFx0ZXhwb3J0cy5OZzJNYXAgPSBuZzJfbWFwXzEuTmcyTWFwO1xuXHRcdHZhciBuZzJfbWFwX2NvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblx0XHRleHBvcnRzLk5nMk1hcENvbXBvbmVudCA9IG5nMl9tYXBfY29tcG9uZW50XzEuTmcyTWFwQ29tcG9uZW50O1xuXHRcdHZhciBtYXJrZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXHRcdGV4cG9ydHMuTWFya2VyID0gbWFya2VyXzEuTWFya2VyO1xuXHRcdHZhciBpbmZvX3dpbmRvd18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFx0ZXhwb3J0cy5JbmZvV2luZG93ID0gaW5mb193aW5kb3dfMS5JbmZvV2luZG93O1xuXHRcdHZhciBOZzJNYXBNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJNYXBNb2R1bGUoKSB7XG5cdFx0ICAgIH1cblx0XHQgICAgTmcyTWFwTW9kdWxlID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuTmdNb2R1bGUoe1xuXHRcdCAgICAgICAgICAgIGltcG9ydHM6IFtjb21tb25fMS5Db21tb25Nb2R1bGVdLFxuXHRcdCAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW25nMl9tYXBfY29tcG9uZW50XzEuTmcyTWFwQ29tcG9uZW50LCBtYXJrZXJfMS5NYXJrZXIsIGluZm9fd2luZG93XzEuSW5mb1dpbmRvd10sXG5cdFx0ICAgICAgICAgICAgcHJvdmlkZXJzOiBbZ2VvX2NvZGVyXzEuR2VvQ29kZXIsIG5hdmlnYXRvcl9nZW9sb2NhdGlvbl8xLk5hdmlnYXRvckdlb2xvY2F0aW9uLCBuZzJfbWFwXzEuTmcyTWFwLCBvcHRpb25fYnVpbGRlcl8xLk9wdGlvbkJ1aWxkZXJdLFxuXHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtuZzJfbWFwX2NvbXBvbmVudF8xLk5nMk1hcENvbXBvbmVudCwgbWFya2VyXzEuTWFya2VyLCBpbmZvX3dpbmRvd18xLkluZm9XaW5kb3ddXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBOZzJNYXBNb2R1bGUpO1xuXHRcdCAgICByZXR1cm4gTmcyTWFwTW9kdWxlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJNYXBNb2R1bGUgPSBOZzJNYXBNb2R1bGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAzICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0dmFyIGdlb19jb2Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XHQvKipcblx0XHQgKiBjaGFuZ2UgYW55IG9iamVjdCB0byBnb29nbGUgb2JqZWN0IG9wdGlvbnNcblx0XHQgKiBlLmcuIFsxLDJdIC0+IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoMSwyKTtcblx0XHQgKi9cblx0XHR2YXIgT3B0aW9uQnVpbGRlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE9wdGlvbkJ1aWxkZXIoZ2VvQ29kZXIpIHtcblx0XHQgICAgICAgIHRoaXMuZ2VvQ29kZXIgPSBnZW9Db2Rlcjtcblx0XHQgICAgfVxuXHRcdCAgICBPcHRpb25CdWlsZGVyLnByb3RvdHlwZS5nb29nbGl6ZUFsbElucHV0cyA9IGZ1bmN0aW9uIChkZWZpbmVkSW5wdXRzLCB1c2VySW5wdXRzKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblx0XHQgICAgICAgIGRlZmluZWRJbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcblx0XHQgICAgICAgICAgICBpZiAodXNlcklucHV0c1tpbnB1dF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdCAgICAgICAgICAgICAgICBvcHRpb25zW2lucHV0XSA9IF90aGlzLmdvb2dsaXplKHVzZXJJbnB1dHNbaW5wdXRdLCB7IGtleTogaW5wdXQgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICByZXR1cm4gb3B0aW9ucztcblx0XHQgICAgfTtcblx0XHQgICAgT3B0aW9uQnVpbGRlci5wcm90b3R5cGUuZ29vZ2xpemVNdWx0aXBsZSA9IGZ1bmN0aW9uIChpbnB1dHMsIG9wdGlvbnMpIHtcblx0XHQgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdCAgICAgICAgZm9yICh2YXIga2V5IGluIGlucHV0cykge1xuXHRcdCAgICAgICAgICAgIHZhciB2YWwgPSBpbnB1dHNba2V5XTtcblx0XHQgICAgICAgICAgICAvLyAobm9uLXN0cmluZ3MgYXJlIGZ1bGx5IGNvbnZlcnRlZClcblx0XHQgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcblx0XHQgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsO1xuXHRcdCAgICAgICAgICAgIH0gLy8gc29tZXRpbWVzICcwJyBuZWVkZWQgdG8gc3RheSBhcyBpdCBpc1xuXHRcdCAgICAgICAgICAgIGVsc2UgaWYgKCEob3B0aW9uc1snZG9Ob3RDb252ZXJTdHJpbmdUb051bWJlciddICYmIHZhbC5tYXRjaCgvXlswLTldKyQvKSkpIHtcblx0XHQgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdGhpcy5nb29nbGl6ZSh2YWwsIHsga2V5OiBrZXkgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSAvLyBmb3IodmFyIGtleSBpbiBhdHRycylcblx0XHQgICAgICAgIHJldHVybiBvcHRpb25zO1xuXHRcdCAgICB9O1xuXHRcdCAgICBPcHRpb25CdWlsZGVyLnByb3RvdHlwZS5nb29nbGl6ZSA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuXHRcdCAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0ICAgICAgICB2YXIgb3V0cHV0O1xuXHRcdCAgICAgICAgaWYgKGlucHV0ID09PSAnZmFsc2UnIHx8IGlucHV0ID09PSBmYWxzZSkge1xuXHRcdCAgICAgICAgICAgIG91dHB1dCA9IGZhbHNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSBpZiAoaW5wdXQgPT09ICcwJyB8fCBpbnB1dCA9PT0gMCkge1xuXHRcdCAgICAgICAgICAgIG91dHB1dCA9IDA7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBvdXRwdXQgPVxuXHRcdCAgICAgICAgICAgICAgICAvLyAtPiBnb29nbGl6ZSAtPiBnZXRKc29uUGFyc2VkIC0+IGdvb2dsaXplTXVsdGlwbGUgLT4gZ29vZ2xpemUgdW50aWwgYWxsIGVsZW1lbnRzIGFyZSBwYXJzZWRcblx0XHQgICAgICAgICAgICAgICAgdGhpcy5nZXRKU09OUGFyc2VkKGlucHV0LCBvcHRpb25zKVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5nZXRBbnlNYXBPYmplY3QoaW5wdXQpXG5cdFx0ICAgICAgICAgICAgICAgICAgICB8fCB0aGlzLmdldEFueU1hcENvbnN0YW50KGlucHV0LCBvcHRpb25zKVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfHwgdGhpcy5nZXREYXRlT2JqZWN0KGlucHV0KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdCAgICAgICAgICAgIGlmIChvcHRpb25zWydrZXknXSA9PT0gXCJib3VuZHNcIikge1xuXHRcdCAgICAgICAgICAgICAgICBvdXRwdXQgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKG91dHB1dFswXSwgb3V0cHV0WzFdKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uc1sna2V5J10gPT09IFwiaWNvbnNcIikge1xuXHRcdCAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmdldE1hcEljb25zKG91dHB1dCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgaWYgKG9wdGlvbnNbJ2tleSddICYmIG91dHB1dCBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdCAgICAgICAgICAgIGlmIChvcHRpb25zWydrZXknXSA9PT0gJ2ljb24nKSB7XG5cdFx0ICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMuZ2V0TWFya2VySWNvbihvdXRwdXQpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zWydrZXknXS5tYXRjaCgvQ29udHJvbE9wdGlvbnMkLykpIHtcblx0XHQgICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcy5nZXRNYXBDb250cm9sT3B0aW9uKG91dHB1dCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0XHQgICAgfTtcblx0XHQgICAgT3B0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0TGF0TG5nID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0ICAgICAgICB2YXIgb3V0cHV0O1xuXHRcdCAgICAgICAgaWYgKGlucHV0WzBdLmNvbnN0cnVjdG9yID09IEFycmF5KSB7XG5cdFx0ICAgICAgICAgICAgb3V0cHV0ID0gaW5wdXQubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhlbFswXSwgZWxbMV0pOyB9KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKCFpc05hTihwYXJzZUZsb2F0KGlucHV0WzBdKSkgJiYgaXNGaW5pdGUoaW5wdXRbMF0pKSB7XG5cdFx0ICAgICAgICAgICAgb3V0cHV0ID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhpbnB1dFswXSwgaW5wdXRbMV0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0XHQgICAgfTtcblx0XHQgICAgT3B0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0SlNPTlBhcnNlZCA9IGZ1bmN0aW9uIChpbnB1dCwgb3B0aW9ucykge1xuXHRcdCAgICAgICAgdmFyIG91dHB1dDtcblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgb3V0cHV0ID0gdXRpbF8xLmdldEpTT04oaW5wdXQpO1xuXHRcdCAgICAgICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdCAgICAgICAgICAgICAgICAvLyBbe2E6MX1dIDogbm90IGxhdC9sbmcgb25lc1xuXHRcdCAgICAgICAgICAgICAgICBpZiAob3V0cHV0WzBdLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMuZ2V0TGF0TG5nKG91dHB1dCk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSBpZiAob3V0cHV0ID09PSBPYmplY3Qob3V0cHV0KSkge1xuXHRcdCAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgbmVzdGVkIGhhc2hlcyBhbmQgY29udmVydCB0byBHb29nbGUgQVBJIG9wdGlvbnNcblx0XHQgICAgICAgICAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zO1xuXHRcdCAgICAgICAgICAgICAgICBuZXdPcHRpb25zWydkb05vdENvbnZlclN0cmluZ1RvTnVtYmVyJ10gPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLmdvb2dsaXplTXVsdGlwbGUob3V0cHV0LCBuZXdPcHRpb25zKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoZSkge1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0XHQgICAgfTtcblx0XHQgICAgT3B0aW9uQnVpbGRlci5wcm90b3R5cGUuZ2V0QW55TWFwT2JqZWN0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0ICAgICAgICB2YXIgb3V0cHV0O1xuXHRcdCAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9eW0EtWl1bYS16QS1aMC05XStcXCguKlxcKSQvKSkge1xuXHRcdCAgICAgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgICAgIHZhciBleHAgPSBcIm5ldyBnb29nbGUubWFwcy5cIiArIGlucHV0O1xuXHRcdCAgICAgICAgICAgICAgICBvdXRwdXQgPSBldmFsKGV4cCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBvdXRwdXQ7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE9wdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldEFueU1hcENvbnN0YW50ID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG5cdFx0ICAgICAgICB2YXIgb3V0cHV0O1xuXHRcdCAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9eKFtBLVpdW2EtekEtWjAtOV0rKVxcLihbQS1aXSspJC8pKSB7XG5cdFx0ICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBpbnB1dC5tYXRjaCgvXihbQS1aXVthLXpBLVowLTldKylcXC4oW0EtWl0rKSQvKTtcblx0XHQgICAgICAgICAgICAgICAgb3V0cHV0ID0gZ29vZ2xlLm1hcHNbbWF0Y2hlc1sxXV1bbWF0Y2hlc1syXV07XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKGlucHV0Lm1hdGNoKC9eW0EtWl0rJC8pKSB7XG5cdFx0ICAgICAgICAgICAgdHJ5IHtcblx0XHQgICAgICAgICAgICAgICAgdmFyIGNhcGl0YWxpemVkS2V5ID0gb3B0aW9uc1sna2V5J10uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuXHRcdCAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1sna2V5J10uc2xpY2UoMSk7XG5cdFx0ICAgICAgICAgICAgICAgIG91dHB1dCA9IGdvb2dsZS5tYXBzW2NhcGl0YWxpemVkS2V5XVtpbnB1dF07XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBvdXRwdXQ7XG5cdFx0ICAgIH07XG5cdFx0ICAgIC8qKlxuXHRcdCAgICAgKiBzdHJlZXR2aWV3Q29udHJvbCwgcGFuQ29udHJvbCwgZXRjLCBub3QgYSBnZW5lcmFsIGNvbnRyb2xcblx0XHQgICAgICovXG5cdFx0ICAgIE9wdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldE1hcENvbnRyb2xPcHRpb24gPSBmdW5jdGlvbiAoY29udHJvbE9wdGlvbnMpIHtcblx0XHQgICAgICAgIHZhciBuZXdDb250cm9sT3B0aW9ucyA9IGNvbnRyb2xPcHRpb25zO1xuXHRcdCAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld0NvbnRyb2xPcHRpb25zKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKG5ld0NvbnRyb2xPcHRpb25zW2tleV0pIHtcblx0XHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3Q29udHJvbE9wdGlvbnNba2V5XTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9VcHBlckNhc2UoKTtcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwibWFwVHlwZUlkc1wiKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChmdW5jdGlvbiAoc3RyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5tYXRjaCgvXltBLVpdKyQvKSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ29vZ2xlLm1hcHMuTWFwVHlwZUlkW3N0ci50b1VwcGVyQ2FzZSgpXTtcblx0XHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzdHlsZVwiKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB2YXIgb2JqTmFtZSA9IGtleS5yZXBsYWNlKC9PcHRpb25zJC8sICcnKSArIFwiU3R5bGVcIjtcblx0XHQgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyb2xPcHRpb25zW2tleV0gPSBnb29nbGUubWFwc1tvYmpOYW1lXVt2YWx1ZV07XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcInBvc2l0aW9uXCIpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyb2xPcHRpb25zW2tleV0gPSBnb29nbGUubWFwcy5Db250cm9sUG9zaXRpb25bdmFsdWVdO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJvbE9wdGlvbnNba2V5XSA9IHZhbHVlO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xPcHRpb25zO1xuXHRcdCAgICB9O1xuXHRcdCAgICBPcHRpb25CdWlsZGVyLnByb3RvdHlwZS5nZXREYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0ICAgICAgICB2YXIgb3V0cHV0O1xuXHRcdCAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9eKFxcZHs0fVxcLVxcZFxcZFxcLVxcZFxcZChbdFRdW1xcZDpcXC5dKik/KShbelpdfChbK1xcLV0pKFxcZFxcZCk6PyhcXGRcXGQpKT8kLykpIHtcblx0XHQgICAgICAgICAgICB0cnkge1xuXHRcdCAgICAgICAgICAgICAgICBvdXRwdXQgPSBuZXcgRGF0ZShpbnB1dCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBvdXRwdXQ7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE9wdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldE1hcEljb25zID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0ICAgICAgICByZXR1cm4gaW5wdXQubWFwKGZ1bmN0aW9uIChlbCkge1xuXHRcdCAgICAgICAgICAgIGlmIChlbC5pY29uLnBhdGgubWF0Y2goL15bQS1aX10rJC8pKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGVsLmljb24ucGF0aCA9IGdvb2dsZS5tYXBzLlN5bWJvbFBhdGhbZWwuaWNvbi5wYXRoXTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgcmV0dXJuIGVsO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE9wdGlvbkJ1aWxkZXIucHJvdG90eXBlLmdldE1hcmtlckljb24gPSBmdW5jdGlvbiAoaW5wdXQpIHtcblx0XHQgICAgICAgIHZhciBvdXRwdXQgPSBpbnB1dDtcblx0XHQgICAgICAgIGlmICgoXCJcIiArIG91dHB1dC5wYXRoKS5tYXRjaCgvXltBLVpfXSskLykpIHtcblx0XHQgICAgICAgICAgICBvdXRwdXQucGF0aCA9IGdvb2dsZS5tYXBzLlN5bWJvbFBhdGhbb3V0cHV0LnBhdGhdO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZm9yICh2YXIga2V5IGluIG91dHB1dCkge1xuXHRcdCAgICAgICAgICAgIHZhciBhcnIgPSBvdXRwdXRba2V5XTtcblx0XHQgICAgICAgICAgICBpZiAoa2V5ID09IFwiYW5jaG9yXCIgfHwga2V5ID09IFwib3JpZ2luXCIgfHwga2V5ID09IFwibGFiZWxPcmlnaW5cIikge1xuXHRcdCAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IG5ldyBnb29nbGUubWFwcy5Qb2ludChhcnJbMF0sIGFyclsxXSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PSBcInNpemVcIiB8fCBrZXkgPT0gXCJzY2FsZWRTaXplXCIpIHtcblx0XHQgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBuZXcgZ29vZ2xlLm1hcHMuU2l6ZShhcnJbMF0sIGFyclsxXSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0XHQgICAgfTtcblx0XHQgICAgT3B0aW9uQnVpbGRlciA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkluamVjdGFibGUoKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtnZW9fY29kZXJfMS5HZW9Db2Rlcl0pXG5cdFx0ICAgIF0sIE9wdGlvbkJ1aWxkZXIpO1xuXHRcdCAgICByZXR1cm4gT3B0aW9uQnVpbGRlcjtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuT3B0aW9uQnVpbGRlciA9IE9wdGlvbkJ1aWxkZXI7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0LyoqXG5cdFx0ICogcmV0dXJuIGpzb24gc3RyaW5nIGZyb20ganNvbi1saWtlIHN0cmluZ1xuXHRcdCAqL1xuXHRcdHZhciBqc29uaXplID0gZnVuY3Rpb24gKHN0cikge1xuXHRcdCAgICB0cnkge1xuXHRcdCAgICAgICAgSlNPTi5wYXJzZShzdHIpO1xuXHRcdCAgICAgICAgcmV0dXJuIHN0cjtcblx0XHQgICAgfVxuXHRcdCAgICBjYXRjaCAoZSkge1xuXHRcdCAgICAgICAgcmV0dXJuIHN0clxuXHRcdCAgICAgICAgICAgIC5yZXBsYWNlKC8oW1xcJFxcd10rKVxccyo6L2csIC8vIHdyYXAga2V5cyB3aXRob3V0IGRvdWJsZSBxdW90ZVxuXHRcdCAgICAgICAgZnVuY3Rpb24gKF8sICQxKSB7XG5cdFx0ICAgICAgICAgICAgcmV0dXJuICdcIicgKyAkMSArICdcIjonO1xuXHRcdCAgICAgICAgfSlcblx0XHQgICAgICAgICAgICAucmVwbGFjZSgvJyhbXiddKyknL2csIC8vIHJlcGxhY2luZyBzaW5nbGUgcXVvdGUgdG8gZG91YmxlIHF1b3RlXG5cdFx0ICAgICAgICBmdW5jdGlvbiAoXywgJDEpIHtcblx0XHQgICAgICAgICAgICByZXR1cm4gJ1wiJyArICQxICsgJ1wiJztcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9XG5cdFx0fTtcblx0XHRleHBvcnRzLmpzb25pemUgPSBqc29uaXplO1xuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgc3RyaW5nIHRvIGFuIG9iamVjdCBieSB1c2luZyBKU09OLnBhcnNlKClcblx0XHQgKi9cblx0XHR2YXIgZ2V0SlNPTiA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHRcdCAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuXHRcdCAgICAgICAgdmFyIHJlID0gL15bXFwrXFwtXT9bMC05XFwuXSssWyBdKlxcID9bXFwrXFwtXT9bMC05XFwuXSskLzsgLy9sYXQsbG5nXG5cdFx0ICAgICAgICBpZiAoaW5wdXQubWF0Y2gocmUpKSB7XG5cdFx0ICAgICAgICAgICAgaW5wdXQgPSBcIltcIiArIGlucHV0ICsgXCJdXCI7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uaXplKGlucHV0KSk7XG5cdFx0ICAgIH1cblx0XHQgICAgZWxzZSB7XG5cdFx0ICAgICAgICByZXR1cm4gaW5wdXQ7XG5cdFx0ICAgIH1cblx0XHR9O1xuXHRcdGV4cG9ydHMuZ2V0SlNPTiA9IGdldEpTT047XG5cdFx0LyogdHNsaW50OmVuYWJsZSAqL1xuXHRcblx0XG5cdC8qKiovIH0sXG5cdC8qIDUgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgUnhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFx0LyoqXG5cdFx0ICogICBQcm92aWRlcyBbZGVmZXJlZC9wcm9taXNlIEFQSV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nL3NlcnZpY2UvJHEpXG5cdFx0ICogICBzZXJ2aWNlIGZvciBHb29nbGUgR2VvY29kZXIgc2VydmljZVxuXHRcdCAqL1xuXHRcdHZhciBHZW9Db2RlciA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIEdlb0NvZGVyKCkge1xuXHRcdCAgICB9XG5cdFx0ICAgIEdlb0NvZGVyLnByb3RvdHlwZS5nZW9jb2RlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHQgICAgICAgIHZhciBnZW9jb2RlJCA9IG5ldyBSeF8xLlN1YmplY3QoKTtcblx0XHQgICAgICAgIHZhciBnZW9jb2RlciA9IG5ldyBnb29nbGUubWFwcy5HZW9jb2RlcigpO1xuXHRcdCAgICAgICAgZ2VvY29kZXIuZ2VvY29kZShvcHRpb25zLCBmdW5jdGlvbiAocmVzdWx0cywgc3RhdHVzKSB7XG5cdFx0ICAgICAgICAgICAgaWYgKHN0YXR1cyA9PSBnb29nbGUubWFwcy5HZW9jb2RlclN0YXR1cy5PSykge1xuXHRcdCAgICAgICAgICAgICAgICBnZW9jb2RlJC5uZXh0KHJlc3VsdHMpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICAgICAgZ2VvY29kZSQuZXJyb3IocmVzdWx0cyk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgICAgICByZXR1cm4gZ2VvY29kZSQ7XG5cdFx0ICAgIH07XG5cdFx0ICAgIDtcblx0XHQgICAgR2VvQ29kZXIgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKCksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0XHQgICAgXSwgR2VvQ29kZXIpO1xuXHRcdCAgICByZXR1cm4gR2VvQ29kZXI7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLkdlb0NvZGVyID0gR2VvQ29kZXI7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDcgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgUnhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFx0LyoqXG5cdFx0ICogIHNlcnZpY2UgZm9yIG5hdmlnYXRvci5nZW9sb2NhdGlvbiBtZXRob2RzXG5cdFx0ICovXG5cdFx0dmFyIE5hdmlnYXRvckdlb2xvY2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTmF2aWdhdG9yR2VvbG9jYXRpb24oKSB7XG5cdFx0ICAgIH1cblx0XHQgICAgTmF2aWdhdG9yR2VvbG9jYXRpb24ucHJvdG90eXBlLmdldEN1cnJlbnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChnZW9Mb2NhdGlvbk9wdGlvbnMpIHtcblx0XHQgICAgICAgIGdlb0xvY2F0aW9uT3B0aW9ucyA9IGdlb0xvY2F0aW9uT3B0aW9ucyB8fCB7IHRpbWVvdXQ6IDUwMDAgfTtcblx0XHQgICAgICAgIHZhciBnZXRDdXJyZW50UG9zaXRpb24kID0gbmV3IFJ4XzEuU3ViamVjdCgpO1xuXHRcdCAgICAgICAgaWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xuXHRcdCAgICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG5cdFx0ICAgICAgICAgICAgICAgIGdldEN1cnJlbnRQb3NpdGlvbiQubmV4dChwb3NpdGlvbik7XG5cdFx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGV2dCkge1xuXHRcdCAgICAgICAgICAgICAgICBnZXRDdXJyZW50UG9zaXRpb24kLmVycm9yKGV2dCk7XG5cdFx0ICAgICAgICAgICAgfSwgZ2VvTG9jYXRpb25PcHRpb25zKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIGdldEN1cnJlbnRQb3NpdGlvbiQuZXJyb3IoXCJCcm93c2VyIEdlb2xvY2F0aW9uIHNlcnZpY2UgZmFpbGVkLlwiKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIHJldHVybiBnZXRDdXJyZW50UG9zaXRpb24kO1xuXHRcdCAgICB9O1xuXHRcdCAgICA7XG5cdFx0ICAgIE5hdmlnYXRvckdlb2xvY2F0aW9uID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuSW5qZWN0YWJsZSgpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG5cdFx0ICAgIF0sIE5hdmlnYXRvckdlb2xvY2F0aW9uKTtcblx0XHQgICAgcmV0dXJuIE5hdmlnYXRvckdlb2xvY2F0aW9uO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OYXZpZ2F0b3JHZW9sb2NhdGlvbiA9IE5hdmlnYXRvckdlb2xvY2F0aW9uO1xuXHRcblx0XG5cdC8qKiovIH0sXG5cdC8qIDggKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgUnhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFx0dmFyIG9wdGlvbl9idWlsZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcdHZhciBnZW9fY29kZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFx0LyoqXG5cdFx0ICogY29sbGVjdGlvbiBvZiBtYXAgaW5zdGFuY2UtcmVsYXRlZCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG5cdFx0ICovXG5cdFx0dmFyIE5nMk1hcCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMk1hcChnZW9Db2Rlciwgb3B0aW9uQnVpbGRlcikge1xuXHRcdCAgICAgICAgdGhpcy5nZW9Db2RlciA9IGdlb0NvZGVyO1xuXHRcdCAgICAgICAgdGhpcy5vcHRpb25CdWlsZGVyID0gb3B0aW9uQnVpbGRlcjtcblx0XHQgICAgICAgIHRoaXMubWFwUmVhZHkkID0gbmV3IFJ4XzEuU3ViamVjdCgpO1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMk1hcC5wcm90b3R5cGUuc2V0T2JqZWN0RXZlbnRzID0gZnVuY3Rpb24gKGRlZmluZWRFdmVudHMsIHRoaXNPYmosIHByZWZpeCkge1xuXHRcdCAgICAgICAgZGVmaW5lZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkZWZpbmVkRXZlbnQpIHtcblx0XHQgICAgICAgICAgICB2YXIgZXZlbnROYW1lID0gZGVmaW5lZEV2ZW50XG5cdFx0ICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG5cdFx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCJeXCIgKyBwcmVmaXgpLCAnJyk7XG5cdFx0ICAgICAgICAgICAgdGhpc09ialtwcmVmaXhdLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICAgICAgICAgICAgICAgIHRoaXNPYmpbZGVmaW5lZEV2ZW50XS5lbWl0KHRoaXMpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMk1hcC5wcm90b3R5cGUudXBkYXRlR29vZ2xlT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCwgY2hhbmdlcykge1xuXHRcdCAgICAgICAgdmFyIHZhbCwgY3VycmVudFZhbHVlLCBzZXRNZXRob2ROYW1lO1xuXHRcdCAgICAgICAgaWYgKG9iamVjdCkge1xuXHRcdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjaGFuZ2VzKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHNldE1ldGhvZE5hbWUgPSBcInNldFwiICsga2V5LnJlcGxhY2UoL15bYS16XS8sIGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnRvVXBwZXJDYXNlKCk7IH0pO1xuXHRcdCAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBjaGFuZ2VzW2tleV0uY3VycmVudFZhbHVlO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoWydwb3NpdGlvbicsICdjZW50ZXInXS5pbmRleE9mKGtleSkgIT09IC0xICYmIHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmdlb0NvZGVyLmdlb2NvZGUoeyBhZGRyZXNzOiBjdXJyZW50VmFsdWUgfSkuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W3NldE1ldGhvZE5hbWVdKHJlc3VsdHNbMF0uZ2VvbWV0cnkubG9jYXRpb24pO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICB2YWwgPSB0aGlzLm9wdGlvbkJ1aWxkZXIuZ29vZ2xpemUoY3VycmVudFZhbHVlKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIG9iamVjdFtzZXRNZXRob2ROYW1lXSh2YWwpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJNYXAucHJvdG90eXBlLnVwZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCBjdXJyZW50VmFsdWUpIHtcblx0XHQgICAgICAgIHZhciB2YWwsIHNldE1ldGhvZE5hbWU7XG5cdFx0ICAgICAgICBzZXRNZXRob2ROYW1lID0gXCJzZXRcIiArIGtleS5yZXBsYWNlKC9eW2Etel0vLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1VwcGVyQ2FzZSgpOyB9KTtcblx0XHQgICAgICAgIGlmIChbJ3Bvc2l0aW9uJywgJ2NlbnRlciddLmluZGV4T2Yoa2V5KSAhPT0gLTEgJiYgdHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHQgICAgICAgICAgICB0aGlzLmdlb0NvZGVyLmdlb2NvZGUoeyBhZGRyZXNzOiBjdXJyZW50VmFsdWUgfSkuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG5cdFx0ICAgICAgICAgICAgICAgIG9iamVjdFtzZXRNZXRob2ROYW1lXShyZXN1bHRzWzBdLmdlb21ldHJ5LmxvY2F0aW9uKTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIHZhbCA9IHRoaXMub3B0aW9uQnVpbGRlci5nb29nbGl6ZShjdXJyZW50VmFsdWUpO1xuXHRcdCAgICAgICAgICAgIG9iamVjdFtzZXRNZXRob2ROYW1lXSh2YWwpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJNYXAgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKCksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbZ2VvX2NvZGVyXzEuR2VvQ29kZXIsIG9wdGlvbl9idWlsZGVyXzEuT3B0aW9uQnVpbGRlcl0pXG5cdFx0ICAgIF0sIE5nMk1hcCk7XG5cdFx0ICAgIHJldHVybiBOZzJNYXA7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMk1hcCA9IE5nMk1hcDtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA5ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIG9wdGlvbl9idWlsZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcdHZhciBuYXZpZ2F0b3JfZ2VvbG9jYXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFx0dmFyIGdlb19jb2Rlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XHR2YXIgbmcyX21hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblx0XHR2YXIgUnhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFx0dmFyIElOUFVUUyA9IFwiXFxuICBiYWNrZ3JvdW5kQ29sb3IsIGNlbnRlciwgZGlzYWJsZURlZmF1bHRVSSwgZGlzYWJsZURvdWJsZUNsaWNrWm9vbSwgZHJhZ2dhYmxlLCBkcmFnZ2FibGVDdXJzb3IsXFxuICBkcmFnZ2luZ0N1cnNvciwgaGVhZGluZywga2V5Ym9hcmRTaG9ydGN1dHMsIG1hcE1ha2VyLCBtYXBUeXBlQ29udHJvbCwgbWFwVHlwZUlkLCBtYXhab29tLCBtaW5ab29tLFxcbiAgbm9DbGVhciwgb3ZlcnZpZXdNYXBDb250cm9sLCBwYW5Db250cm9sLCBwYW5Db250cm9sT3B0aW9ucywgcm90YXRlQ29udHJvbCwgc2NhbGVDb250cm9sLCBzY3JvbGx3aGVlbCxcXG4gIHN0cmVldFZpZXcsIHN0eWxlcywgdGlsdCwgem9vbSwgc3RyZWV0Vmlld0NvbnRyb2wsIHpvb21Db250cm9sLCBtYXBUeXBlQ29udHJvbE9wdGlvbnMsXFxuICBvdmVydmlld01hcENvbnRyb2xPcHRpb25zLCByb3RhdGVDb250cm9sT3B0aW9ucywgc2NhbGVDb250cm9sT3B0aW9ucywgc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zLFxcbiAgem9vbUNvbnRyb2xPcHRpb25zXCIuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC50cmltKCk7IH0pO1xuXHRcdHZhciBPVVRQVVRTID0gXCJcXG4gIGJvdW5kc19jaGFuZ2VkLCBjZW50ZXJfY2hhbmdlZCwgY2xpY2ssIGRibGNsaWNrLCBkcmFnLCBkcmFnZW5kLCBkcmFnc3RhcnQsIGhlYWRpbmdfY2hhbmdlZCwgaWRsZVxcbiAgbWFwdHlwZWlkX2NoYW5nZWQsIG1vdXNlbW92ZSwgbW91c2VvdXQsIG1vdXNlb3ZlciwgcHJvamVjdGlvbl9jaGFuZ2VkLCByZXNpemUsIHJpZ2h0Y2xpY2ssIFxcbiAgdGlsZXNsb2FkZWQsIHRpbGVfY2hhbmdlZCwgem9vbV9jaGFuZ2VkXCJcblx0XHQgICAgLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKFwibWFwXCIgKyBlbC50cmltKCkucmVwbGFjZSgvXlthLXpdLywgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9VcHBlckNhc2UoKTsgfSkpOyB9KTtcblx0XHR2YXIgTmcyTWFwQ29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTmcyTWFwQ29tcG9uZW50KG9wdGlvbkJ1aWxkZXIsIGVsZW1lbnRSZWYsIHpvbmUsIGdlb2xvY2F0aW9uLCBnZW9Db2RlciwgbmcyTWFwKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdGhpcy5vcHRpb25CdWlsZGVyID0gb3B0aW9uQnVpbGRlcjtcblx0XHQgICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG5cdFx0ICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuXHRcdCAgICAgICAgdGhpcy5nZW9sb2NhdGlvbiA9IGdlb2xvY2F0aW9uO1xuXHRcdCAgICAgICAgdGhpcy5nZW9Db2RlciA9IGdlb0NvZGVyO1xuXHRcdCAgICAgICAgdGhpcy5uZzJNYXAgPSBuZzJNYXA7XG5cdFx0ICAgICAgICB0aGlzLm1hcE9wdGlvbnMgPSB7fTtcblx0XHQgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VzJCA9IG5ldyBSeF8xLlN1YmplY3QoKTtcblx0XHQgICAgICAgIC8vbWFwIG9iamVjdHMgYnkgZ3JvdXBcblx0XHQgICAgICAgIHRoaXMuaW5mb1dpbmRvd3MgPSB7fTtcblx0XHQgICAgICAgIGlmICh0eXBlb2YgZ29vZ2xlID09PSAndW5kZWZpbmVkJyB8fCAhZ29vZ2xlLm1hcHMuTWFwKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5tYXBJbml0UGF0aCA9IDE7XG5cdFx0ICAgICAgICAgICAgdGhpcy5hZGRHb29nbGVNYXBzQXBpKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBhbGwgb3V0cHV0cyBuZWVkcyB0byBiZSBpbml0aWFsaXplZCxcblx0XHQgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc3NjU1MTkvYW5ndWxhcjItZGlyZWN0aXZlLWNhbm5vdC1yZWFkLXByb3BlcnR5LXN1YnNjcmliZS1vZi11bmRlZmluZWQtd2l0aC1vdXRwdXRzXG5cdFx0ICAgICAgICBPVVRQVVRTLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkgeyByZXR1cm4gX3RoaXNbb3V0cHV0XSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7IH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMk1hcENvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgaWYgKHRoaXMubWFwSW5pdFBhdGggIT09IDEpIHtcblx0XHQgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVNYXAoKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgfTtcblx0XHQgICAgTmcyTWFwQ29tcG9uZW50LnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG5cdFx0ICAgICAgICB0aGlzLmlucHV0Q2hhbmdlcyQubmV4dChjaGFuZ2VzKTtcblx0XHQgICAgfTtcblx0XHQgICAgTmcyTWFwQ29tcG9uZW50LnByb3RvdHlwZS5hZGRHb29nbGVNYXBzQXBpID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XHQgICAgICAgIHdpbmRvd1snbmcyTWFwQ29tcG9uZW50UmVmJ10gPSB7IHpvbmU6IHRoaXMuem9uZSwgY29tcG9uZW50Rm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmluaXRpYWxpemVNYXAoKTsgfSB9O1xuXHRcdCAgICAgICAgd2luZG93Wydpbml0TmcyTWFwJ10gPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgd2luZG93WyduZzJNYXBDb21wb25lbnRSZWYnXS56b25lLnJ1bihmdW5jdGlvbiAoKSB7IHdpbmRvd1snbmcyTWFwQ29tcG9uZW50UmVmJ10uY29tcG9uZW50Rm4oKTsgfSk7XG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgaWYgKCF3aW5kb3dbJ2dvb2dsZSddICYmICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbmcyLW1hcC1hcGknKSkge1xuXHRcdCAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHQgICAgICAgICAgICBzY3JpcHQuaWQgPSBcIm5nMi1tYXAtYXBpXCI7XG5cdFx0ICAgICAgICAgICAgLy8gc2NyaXB0LnNyYyA9IFwiaHR0cHM6Ly9tYXBzLmdvb2dsZS5jb20vbWFwcy9hcGkvanM/Y2FsbGJhY2s9aW5pdE5nMk1hcFwiO1xuXHRcdCAgICAgICAgICAgIHZhciBhcGlVcmwgPSBOZzJNYXBDb21wb25lbnRbJ2FwaVVybCddIHx8IFwiaHR0cHM6Ly9tYXBzLmdvb2dsZS5jb20vbWFwcy9hcGkvanNcIjtcblx0XHQgICAgICAgICAgICBhcGlVcmwgKz0gYXBpVXJsLmluZGV4T2YoJz8nKSA/ICcmJyA6ICc/Jztcblx0XHQgICAgICAgICAgICBzY3JpcHQuc3JjID0gYXBpVXJsICsgXCJjYWxsYmFjaz1pbml0TmcyTWFwXCI7XG5cdFx0ICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMk1hcENvbXBvbmVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZU1hcCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICB0aGlzLmVsID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmdvb2dsZS1tYXAnKTtcblx0XHQgICAgICAgIGNvbnNvbGUubG9nKCd0aGlzLmVsLi4uLi4uLi4uLi4uLi4uJywgdGhpcy5lbCk7XG5cdFx0ICAgICAgICB0aGlzLm1hcE9wdGlvbnMgPSB0aGlzLm9wdGlvbkJ1aWxkZXIuZ29vZ2xpemVBbGxJbnB1dHMoSU5QVVRTLCB0aGlzKTtcblx0XHQgICAgICAgIGNvbnNvbGUubG9nKCd0aGlzLm1hcE9wdGlvbnMnLCB0aGlzLm1hcE9wdGlvbnMpO1xuXHRcdCAgICAgICAgdGhpcy5tYXBPcHRpb25zLnpvb20gPSB0aGlzLm1hcE9wdGlvbnMuem9vbSB8fCAxNTtcblx0XHQgICAgICAgIHR5cGVvZiB0aGlzLm1hcE9wdGlvbnMuY2VudGVyID09PSAnc3RyaW5nJyAmJiAoZGVsZXRlIHRoaXMubWFwT3B0aW9ucy5jZW50ZXIpO1xuXHRcdCAgICAgICAgdGhpcy5tYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKHRoaXMuZWwsIHRoaXMubWFwT3B0aW9ucyk7XG5cdFx0ICAgICAgICB0aGlzLnNldENlbnRlcigpO1xuXHRcdCAgICAgICAgLy9zZXQgZ29vZ2xlIGV2ZW50cyBsaXN0ZW5lcnMgYW5kIGVtaXRzIHRvIHRoaXMgb3V0cHV0cyBsaXN0ZW5lcnNcblx0XHQgICAgICAgIHRoaXMubmcyTWFwLnNldE9iamVjdEV2ZW50cyhPVVRQVVRTLCB0aGlzLCAnbWFwJyk7XG5cdFx0ICAgICAgICAvLyBicm9hZGNhc3QgbWFwIHJlYWR5IG1lc3NhZ2Vcblx0XHQgICAgICAgIHRoaXMubmcyTWFwLm1hcCA9IHRoaXMubWFwO1xuXHRcdCAgICAgICAgdGhpcy5uZzJNYXAubWFwQ29tcG9uZW50ID0gdGhpcztcblx0XHQgICAgICAgIHRoaXMubmcyTWFwLm1hcFsnbWFwQ29tcG9uZW50J10gPSB0aGlzO1xuXHRcdCAgICAgICAgLy8gLi4uLi4uLi5cblx0XHQgICAgICAgIGNvbnNvbGUubG9nKCdtYXAgaXMgcmVhZHkuLi4uLi4uJyk7XG5cdFx0ICAgICAgICB0aGlzLm5nMk1hcC5tYXBSZWFkeSQubmV4dCh0aGlzLm1hcCk7XG5cdFx0ICAgICAgICAvLyB1cGRhdGUgbWFwIHdoZW4gaW5wdXQgY2hhbmdlc1xuXHRcdCAgICAgICAgdGhpcy5pbnB1dENoYW5nZXMkXG5cdFx0ICAgICAgICAgICAgLmRlYm91bmNlVGltZSgxMDAwKVxuXHRcdCAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZXMpIHsgcmV0dXJuIF90aGlzLm5nMk1hcC51cGRhdGVHb29nbGVPYmplY3QoX3RoaXMubWFwLCBjaGFuZ2VzKTsgfSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMk1hcENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XHQgICAgICAgIGlmICghdGhpc1snY2VudGVyJ10pIHtcblx0XHQgICAgICAgICAgICB0aGlzLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbigpLnN1YnNjcmliZShmdW5jdGlvbiAocG9zaXRpb24pIHtcblx0XHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3NldHRpbmcgbWFwIGNlbnRlciBmcm9tIGN1cnJlbnQgbG9jYXRpb24nKTtcblx0XHQgICAgICAgICAgICAgICAgdmFyIGxhdExuZyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcocG9zaXRpb24uY29vcmRzLmxhdGl0dWRlLCBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlKTtcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMubWFwLnNldENlbnRlcihsYXRMbmcpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRoaXNbJ2NlbnRlciddID09PSAnc3RyaW5nJykge1xuXHRcdCAgICAgICAgICAgIHRoaXMuZ2VvQ29kZXIuZ2VvY29kZSh7IGFkZHJlc3M6IHRoaXNbJ2NlbnRlciddIH0pLnN1YnNjcmliZShmdW5jdGlvbiAocmVzdWx0cykge1xuXHRcdCAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2V0dGluZyBtYXAgY2VudGVyIGZyb20gYWRkcmVzcycsIF90aGlzWydjZW50ZXInXSk7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLm1hcC5zZXRDZW50ZXIocmVzdWx0c1swXS5nZW9tZXRyeS5sb2NhdGlvbik7XG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMk1hcENvbXBvbmVudC5wcm90b3R5cGUub3BlbkluZm9XaW5kb3cgPSBmdW5jdGlvbiAoaWQsIGFuY2hvciwgZGF0YSkge1xuXHRcdCAgICAgICAgdGhpcy5pbmZvV2luZG93c1tpZF0ub3BlbihhbmNob3IsIGRhdGEpO1xuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJNYXBDb21wb25lbnQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XHQgICAgICAgIE9VVFBVVFMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0KSB7IHJldHVybiBnb29nbGUubWFwcy5ldmVudC5jbGVhckxpc3RlbmVycyhfdGhpcy5tYXAsIG91dHB1dCk7IH0pO1xuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJNYXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5Db21wb25lbnQoe1xuXHRcdCAgICAgICAgICAgIHNlbGVjdG9yOiAnbmcyLW1hcCwganVpLW1hcCcsXG5cdFx0ICAgICAgICAgICAgcHJvdmlkZXJzOiBbbmcyX21hcF8xLk5nMk1hcCwgb3B0aW9uX2J1aWxkZXJfMS5PcHRpb25CdWlsZGVyLCBnZW9fY29kZXJfMS5HZW9Db2RlciwgbmF2aWdhdG9yX2dlb2xvY2F0aW9uXzEuTmF2aWdhdG9yR2VvbG9jYXRpb25dLFxuXHRcdCAgICAgICAgICAgIHN0eWxlczogW1wiXFxuICAgIG5nMi1tYXAge2Rpc3BsYXk6IGJsb2NrOyBoZWlnaHQ6IDMwMHB4O31cXG4gICAgLmdvb2dsZS1tYXAge3dpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCV9XFxuICBcIl0sXG5cdFx0ICAgICAgICAgICAgaW5wdXRzOiBJTlBVVFMsXG5cdFx0ICAgICAgICAgICAgb3V0cHV0czogT1VUUFVUUyxcblx0XHQgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBjb3JlXzEuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcblx0XHQgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ29vZ2xlLW1hcFxcXCI+PC9kaXY+XFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gIFwiXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtvcHRpb25fYnVpbGRlcl8xLk9wdGlvbkJ1aWxkZXIsIGNvcmVfMS5FbGVtZW50UmVmLCBjb3JlXzEuTmdab25lLCBuYXZpZ2F0b3JfZ2VvbG9jYXRpb25fMS5OYXZpZ2F0b3JHZW9sb2NhdGlvbiwgZ2VvX2NvZGVyXzEuR2VvQ29kZXIsIG5nMl9tYXBfMS5OZzJNYXBdKVxuXHRcdCAgICBdLCBOZzJNYXBDb21wb25lbnQpO1xuXHRcdCAgICByZXR1cm4gTmcyTWFwQ29tcG9uZW50O1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJNYXBDb21wb25lbnQgPSBOZzJNYXBDb21wb25lbnQ7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMTAgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgb3B0aW9uX2J1aWxkZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFx0dmFyIG5hdmlnYXRvcl9nZW9sb2NhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblx0XHR2YXIgZ2VvX2NvZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcdHZhciBuZzJfbWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHRcdHZhciBSeF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XHR2YXIgSU5QVVRTID0gXCJcXG4gIGFuY2hvclBvaW50LCBhbmltYXRpb24sIGNsaWNrYWJsZSwgY3Vyc29yLCBkcmFnZ2FibGUsIGljb24sIGxhYmVsLCBvcGFjaXR5XFxuICAsb3B0aW1pemVkLHBsYWNlLCBwb3NpdGlvbiwgc2hhcGUsIHRpdGxlLCB2aXNpYmxlLCB6SW5kZXhcIi5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsLnRyaW0oKTsgfSk7XG5cdFx0dmFyIE9VVFBVVFMgPSBcIlxcbiAgYW5pbWF0aW9uX2NoYW5nZWQsIGNsaWNrLCBjbGlja2FibGVfY2hhbmdlZCwgY3Vyc29yX2NoYW5nZWQsIGRibGNsaWNrLCBkcmFnLCBkcmFnZW5kLCBkcmFnZ2FibGVfY2hhbmdlZCxcXG4gIGRyYWdzdGFydCwgZmxhdF9jaGFuZ2VkLCBpY29uX2NoYW5nZWQsIG1vdXNlZG93biwgbW91c2VvdXQsIG1vdXNlb3ZlciwgbW91c2V1cCwgcG9zaXRpb25fY2hhbmdlZCwgcmlnaHRjbGljayxcXG4gIHNoYXBlX2NoYW5nZWQsIHRpdGxlX2NoYW5nZWQsIHZpc2libGVfY2hhbmdlZCwgemluZGV4X2NoYW5nZWRcXG4gIFwiLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gKFwibWFya2VyXCIgKyBlbC50cmltKCkucmVwbGFjZSgvXlthLXpdLywgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9VcHBlckNhc2UoKTsgfSkpOyB9KTtcblx0XHR2YXIgTWFya2VyID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTWFya2VyKG5nMk1hcCwgb3B0aW9uQnVpbGRlciwgZ2VvbG9jYXRpb24sIGdlb0NvZGVyKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdGhpcy5uZzJNYXAgPSBuZzJNYXA7XG5cdFx0ICAgICAgICB0aGlzLm9wdGlvbkJ1aWxkZXIgPSBvcHRpb25CdWlsZGVyO1xuXHRcdCAgICAgICAgdGhpcy5nZW9sb2NhdGlvbiA9IGdlb2xvY2F0aW9uO1xuXHRcdCAgICAgICAgdGhpcy5nZW9Db2RlciA9IGdlb0NvZGVyO1xuXHRcdCAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG5cdFx0ICAgICAgICB0aGlzLmlucHV0Q2hhbmdlcyQgPSBuZXcgUnhfMS5TdWJqZWN0KCk7XG5cdFx0ICAgICAgICBpZiAodGhpcy5uZzJNYXAubWFwKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplKHRoaXMubmcyTWFwLm1hcCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICB0aGlzLm5nMk1hcC5tYXBSZWFkeSQuc3Vic2NyaWJlKGZ1bmN0aW9uIChtYXApIHsgcmV0dXJuIF90aGlzLmluaXRpYWxpemUobWFwKTsgfSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvLyBhbGwgb3V0cHV0cyBuZWVkcyB0byBiZSBpbml0aWFsaXplZCxcblx0XHQgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzc3NjU1MTkvYW5ndWxhcjItZGlyZWN0aXZlLWNhbm5vdC1yZWFkLXByb3BlcnR5LXN1YnNjcmliZS1vZi11bmRlZmluZWQtd2l0aC1vdXRwdXRzXG5cdFx0ICAgICAgICBPVVRQVVRTLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkgeyByZXR1cm4gX3RoaXNbb3V0cHV0XSA9IG5ldyBjb3JlXzEuRXZlbnRFbWl0dGVyKCk7IH0pO1xuXHRcdCAgICB9XG5cdFx0ICAgIE1hcmtlci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuXHRcdCAgICAgICAgdGhpcy5pbnB1dENoYW5nZXMkLm5leHQoY2hhbmdlcyk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIC8vIGNhbGxlZCB3aGVuIG1hcCBpcyByZWFkeVxuXHRcdCAgICBNYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAobWFwKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgY29uc29sZS5sb2coJ21hcmtlciBpcyBiZWluZyBpbml0aWFsaXplZCcpO1xuXHRcdCAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25CdWlsZGVyLmdvb2dsaXplQWxsSW5wdXRzKElOUFVUUywgdGhpcyk7XG5cdFx0ICAgICAgICBjb25zb2xlLmxvZygnTUFSS0VSIG9wdGlvbnMnLCB0aGlzLm9wdGlvbnMpO1xuXHRcdCAgICAgICAgdGhpcy5vcHRpb25zLm1hcCA9IG1hcDtcblx0XHQgICAgICAgIC8vIHdpbGwgYmUgc2V0IGFmdGVyIGdlb2NvZGVkXG5cdFx0ICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnc3RyaW5nJyAmJiAoZGVsZXRlIHRoaXMub3B0aW9ucy5wb3NpdGlvbik7XG5cdFx0ICAgICAgICB0aGlzLm1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIodGhpcy5vcHRpb25zKTtcblx0XHQgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oKTtcblx0XHQgICAgICAgIC8vc2V0IGdvb2dsZSBldmVudHMgbGlzdGVuZXJzIGFuZCBlbWl0cyB0byB0aGlzIG91dHB1dHMgbGlzdGVuZXJzXG5cdFx0ICAgICAgICB0aGlzLm5nMk1hcC5zZXRPYmplY3RFdmVudHMoT1VUUFVUUywgdGhpcywgJ21hcmtlcicpO1xuXHRcdCAgICAgICAgLy8gdXBkYXRlIG1hcmtlciB3aGVuIGlucHV0IGNoYW5nZXNcblx0XHQgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VzJFxuXHRcdCAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZXMpIHtcblx0XHQgICAgICAgICAgICBjb25zb2xlLmxvZygnbWFya2VyIG9wdGlvbnMgYXJlIGNoYW5nZWQnLCBjaGFuZ2VzKTtcblx0XHQgICAgICAgICAgICBfdGhpcy5uZzJNYXAudXBkYXRlR29vZ2xlT2JqZWN0KF90aGlzLm1hcmtlciwgY2hhbmdlcyk7XG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgfTtcblx0XHQgICAgTWFya2VyLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgICBpZiAoIV90aGlzWydwb3NpdGlvbiddKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbigpLnN1YnNjcmliZShmdW5jdGlvbiAocG9zaXRpb24pIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdzZXR0aW5nIG1hcmtlciBwb3NpdGlvbiBmcm9tIGN1cnJlbnQgbG9jYXRpb24nKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIHZhciBsYXRMbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwgcG9zaXRpb24uY29vcmRzLmxvbmdpdHVkZSk7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXJrZXIuc2V0UG9zaXRpb24obGF0TG5nKTtcblx0XHQgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBfdGhpc1sncG9zaXRpb24nXSA9PT0gJ3N0cmluZycpIHtcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMuZ2VvQ29kZXIuZ2VvY29kZSh7IGFkZHJlc3M6IF90aGlzWydwb3NpdGlvbiddIH0pLnN1YnNjcmliZShmdW5jdGlvbiAocmVzdWx0cykge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3NldHRpbmcgbWFya2VyIHBvc2l0aW9uIGZyb20gYWRkcmVzcycsIF90aGlzWydwb3NpdGlvbiddKTtcblx0XHQgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcmtlci5zZXRQb3NpdGlvbihyZXN1bHRzWzBdLmdlb21ldHJ5LmxvY2F0aW9uKTtcblx0XHQgICAgICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSwgNTAwKTtcblx0XHQgICAgfTtcblx0XHQgICAgTWFya2VyLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICBPVVRQVVRTLmZvckVhY2goZnVuY3Rpb24gKG91dHB1dCkgeyByZXR1cm4gZ29vZ2xlLm1hcHMuZXZlbnQuY2xlYXJMaXN0ZW5lcnMoX3RoaXMubWFya2VyLCBvdXRwdXQpOyB9KTtcblx0XHQgICAgICAgIGRlbGV0ZSB0aGlzLm1hcmtlci5zZXRNYXAobnVsbCk7XG5cdFx0ICAgICAgICBkZWxldGUgdGhpcy5tYXJrZXI7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE1hcmtlciA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkRpcmVjdGl2ZSh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICdtYXJrZXInLFxuXHRcdCAgICAgICAgICAgIGlucHV0czogSU5QVVRTLFxuXHRcdCAgICAgICAgICAgIG91dHB1dHM6IE9VVFBVVFNcblx0XHQgICAgICAgIH0pLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW25nMl9tYXBfMS5OZzJNYXAsIG9wdGlvbl9idWlsZGVyXzEuT3B0aW9uQnVpbGRlciwgbmF2aWdhdG9yX2dlb2xvY2F0aW9uXzEuTmF2aWdhdG9yR2VvbG9jYXRpb24sIGdlb19jb2Rlcl8xLkdlb0NvZGVyXSlcblx0XHQgICAgXSwgTWFya2VyKTtcblx0XHQgICAgcmV0dXJuIE1hcmtlcjtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuTWFya2VyID0gTWFya2VyO1xuXHRcblx0XG5cdC8qKiovIH0sXG5cdC8qIDExICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIG9wdGlvbl9idWlsZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcdHZhciBuZzJfbWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXHRcdHZhciBSeF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XHR2YXIgSU5QVVRTID0gXCJcXG4gIGNvbnRlbnQsIGRpc2FibGVBdXRvUGFuLCBtYXhXaWR0aCwgcGl4ZWxPZmZzZXQsIHBvc2l0aW9uLCB6SW5kZXhcXG4gIFwiLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwudHJpbSgpOyB9KTtcblx0XHR2YXIgT1VUUFVUUyA9IFwiXFxuICBjbG9zZWNsaWNrLCBjb250ZW50X2NoYW5nZWQsIGRvbXJlYWR5LCBwb3NpdGlvbl9jaGFuZ2VkLCB6aW5kZXhfY2hhbmdlZFxcbiAgXCIuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGVsKSB7IHJldHVybiAoXCJpbmZvV2luZG93XCIgKyBlbC50cmltKCkucmVwbGFjZSgvXlthLXpdLywgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudG9VcHBlckNhc2UoKTsgfSkpOyB9KTtcblx0XHR2YXIgSW5mb1dpbmRvdyA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIEluZm9XaW5kb3cob3B0aW9uQnVpbGRlciwgZWxlbWVudFJlZiwgbmcyTWFwKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdGhpcy5vcHRpb25CdWlsZGVyID0gb3B0aW9uQnVpbGRlcjtcblx0XHQgICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG5cdFx0ICAgICAgICB0aGlzLm5nMk1hcCA9IG5nMk1hcDtcblx0XHQgICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuXHRcdCAgICAgICAgdGhpcy5pbnB1dENoYW5nZXMkID0gbmV3IFJ4XzEuU3ViamVjdCgpO1xuXHRcdCAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHQgICAgICAgIGlmICh0aGlzLm5nMk1hcC5tYXApIHtcblx0XHQgICAgICAgICAgICB0aGlzLmluaXRpYWxpemUodGhpcy5uZzJNYXAubWFwKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgIHRoaXMubmcyTWFwLm1hcFJlYWR5JC5zdWJzY3JpYmUoZnVuY3Rpb24gKG1hcCkgeyByZXR1cm4gX3RoaXMuaW5pdGlhbGl6ZShtYXApOyB9KTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIGFsbCBvdXRwdXRzIG5lZWRzIHRvIGJlIGluaXRpYWxpemVkLFxuXHRcdCAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNzc2NTUxOS9hbmd1bGFyMi1kaXJlY3RpdmUtY2Fubm90LXJlYWQtcHJvcGVydHktc3Vic2NyaWJlLW9mLXVuZGVmaW5lZC13aXRoLW91dHB1dHNcblx0XHQgICAgICAgIE9VVFBVVFMuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0KSB7IHJldHVybiBfdGhpc1tvdXRwdXRdID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTsgfSk7XG5cdFx0ICAgIH1cblx0XHQgICAgSW5mb1dpbmRvdy5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuXHRcdCAgICAgICAgdGhpcy5pbnB1dENoYW5nZXMkLm5leHQoY2hhbmdlcyk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIC8vIGNhbGxlZCB3aGVuIG1hcCBpcyByZWFkeVxuXHRcdCAgICBJbmZvV2luZG93LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKG1hcCkge1xuXHRcdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XHQgICAgICAgIGNvbnNvbGUubG9nKCdpbmZvd2luZG93IGlzIGJlaW5nIGluaXRpYWxpemVkJyk7XG5cdFx0ICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuaW5uZXJIVE1MO1xuXHRcdCAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5vcHRpb25CdWlsZGVyLmdvb2dsaXplQWxsSW5wdXRzKElOUFVUUywgdGhpcyk7XG5cdFx0ICAgICAgICB0aGlzLmluZm9XaW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyh0aGlzLm9wdGlvbnMpO1xuXHRcdCAgICAgICAgY29uc29sZS5sb2coJ0lORk9XSU5ET1cgb3B0aW9ucycsIHRoaXMub3B0aW9ucyk7XG5cdFx0ICAgICAgICAvL3JlZ2lzdGVyIGluZm9XaW5kb3cgaWRzIHRvIE5nMk1hcCwgc28gdGhhdCBpdCBjYW4gYmUgb3BlbmVkIGJ5IGlkXG5cdFx0ICAgICAgICB0aGlzLmVsID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG5cdFx0ICAgICAgICBpZiAodGhpcy5lbC5pZCkge1xuXHRcdCAgICAgICAgICAgIHRoaXMubmcyTWFwLm1hcENvbXBvbmVudC5pbmZvV2luZG93c1t0aGlzLmVsLmlkXSA9IHRoaXM7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBbiBJbmZvV2luZG93IG11c3QgaGF2ZSBhbiBpZC4gZS5nLiBpZD1cImRldGFpbFwiJyk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvL3NldCBnb29nbGUgZXZlbnRzIGxpc3RlbmVycyBhbmQgZW1pdHMgdG8gdGhpcyBvdXRwdXRzIGxpc3RlbmVyc1xuXHRcdCAgICAgICAgdGhpcy5uZzJNYXAuc2V0T2JqZWN0RXZlbnRzKE9VVFBVVFMsIHRoaXMsICdpbmZvV2luZG93Jyk7XG5cdFx0ICAgICAgICAvLyB1cGRhdGUgb2JqZWN0IHdoZW4gaW5wdXQgY2hhbmdlc1xuXHRcdCAgICAgICAgdGhpcy5pbnB1dENoYW5nZXMkXG5cdFx0ICAgICAgICAgICAgLmRlYm91bmNlVGltZSgxMDAwKVxuXHRcdCAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKGNoYW5nZXMpIHsgcmV0dXJuIF90aGlzLm5nMk1hcC51cGRhdGVHb29nbGVPYmplY3QoX3RoaXMuaW5mb1dpbmRvdywgY2hhbmdlcyk7IH0pO1xuXHRcdCAgICB9O1xuXHRcdCAgICBJbmZvV2luZG93LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGFuY2hvciwgZGF0YSkge1xuXHRcdCAgICAgICAgdmFyIGh0bWwgPSB0aGlzLnRlbXBsYXRlO1xuXHRcdCAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0XHQgICAgICAgICAgICB0aGlzW2tleV0gPSBkYXRhW2tleV07XG5cdFx0ICAgICAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZShcIltbXCIgKyBrZXkgKyBcIl1dXCIsIGRhdGFba2V5XSk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICAvL3NldCBjb250ZW50IGFuZCBvcGVuIGl0XG5cdFx0ICAgICAgICB0aGlzLmluZm9XaW5kb3cuc2V0Q29udGVudChodG1sKTtcblx0XHQgICAgICAgIHRoaXMuaW5mb1dpbmRvdy5vcGVuKHRoaXMubmcyTWFwLm1hcCwgYW5jaG9yKTtcblx0XHQgICAgfTtcblx0XHQgICAgSW5mb1dpbmRvdy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgT1VUUFVUUy5mb3JFYWNoKGZ1bmN0aW9uIChvdXRwdXQpIHsgcmV0dXJuIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFyTGlzdGVuZXJzKF90aGlzLmluZm9XaW5kb3csIG91dHB1dCk7IH0pO1xuXHRcdCAgICAgICAgZGVsZXRlIHRoaXMuaW5mb1dpbmRvdztcblx0XHQgICAgfTtcblx0XHQgICAgSW5mb1dpbmRvdyA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkNvbXBvbmVudCh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICdpbmZvLXdpbmRvdycsXG5cdFx0ICAgICAgICAgICAgaW5wdXRzOiBJTlBVVFMsXG5cdFx0ICAgICAgICAgICAgb3V0cHV0czogT1VUUFVUUyxcblx0XHQgICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCJcblx0XHQgICAgICAgIH0pLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW29wdGlvbl9idWlsZGVyXzEuT3B0aW9uQnVpbGRlciwgY29yZV8xLkVsZW1lbnRSZWYsIG5nMl9tYXBfMS5OZzJNYXBdKVxuXHRcdCAgICBdLCBJbmZvV2luZG93KTtcblx0XHQgICAgcmV0dXJuIEluZm9XaW5kb3c7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLkluZm9XaW5kb3cgPSBJbmZvV2luZG93O1xuXHRcblx0XG5cdC8qKiovIH1cblx0LyoqKioqKi8gXSlcblx0fSk7XG5cdDtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLW1hcC51bWQuanMubWFwXG5cbi8qKiovIH0sXG4vKiAxNCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRpZih0cnVlKVxuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMSksIF9fd2VicGFja19yZXF1aXJlX18oMiksIF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0ZGVmaW5lKFtcIkBhbmd1bGFyL2NvcmVcIiwgXCJAYW5ndWxhci9mb3Jtc1wiLCBcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0sIGZhY3RvcnkpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdFx0ZXhwb3J0c1tcIm5nMi1tZW51XCJdID0gZmFjdG9yeShyZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKSwgcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cm9vdFtcIm5nMi1tZW51XCJdID0gZmFjdG9yeShyb290W1wiQGFuZ3VsYXIvY29yZVwiXSwgcm9vdFtcIkBhbmd1bGFyL2Zvcm1zXCJdLCByb290W1wiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSk7XG5cdH0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcblx0cmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcblx0LyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdC8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0LyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0LyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG5cdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0LyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuXHQvKioqKioqLyBcdFx0fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdC8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdC8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG5cdC8qKioqKiovIFx0fVxuXHQvKioqKioqL1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHQvKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXHQvKioqKioqLyB9KVxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqLyAoW1xuXHQvKiAwICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIGZvcm1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdHZhciBwbGF0Zm9ybV9icm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcdHZhciBuZzJfbWVudV9kaXJlY3RpdmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0ZXhwb3J0cy5OZzJNZW51RGlyZWN0aXZlID0gbmcyX21lbnVfZGlyZWN0aXZlXzEuTmcyTWVudURpcmVjdGl2ZTtcblx0XHR2YXIgTmcyTWVudU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMk1lbnVNb2R1bGUoKSB7XG5cdFx0ICAgIH1cblx0XHQgICAgTmcyTWVudU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHQgICAgICAgICAgICBpbXBvcnRzOiBbcGxhdGZvcm1fYnJvd3Nlcl8xLkJyb3dzZXJNb2R1bGUsIGZvcm1zXzEuRm9ybXNNb2R1bGVdLFxuXHRcdCAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW25nMl9tZW51X2RpcmVjdGl2ZV8xLk5nMk1lbnVEaXJlY3RpdmVdLFxuXHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtuZzJfbWVudV9kaXJlY3RpdmVfMS5OZzJNZW51RGlyZWN0aXZlXVxuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0XHQgICAgXSwgTmcyTWVudU1vZHVsZSk7XG5cdFx0ICAgIHJldHVybiBOZzJNZW51TW9kdWxlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJNZW51TW9kdWxlID0gTmcyTWVudU1vZHVsZTtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAxICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogMiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDMgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA0ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIE5nMk1lbnVEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJNZW51RGlyZWN0aXZlKHZpZXdDb250YWluZXJSZWYpIHtcblx0XHQgICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG5cdFx0ICAgICAgICB0aGlzLmVsID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcblx0XHQgICAgICAgIHRoaXMuZWwucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cdFx0ICAgICAgICB0aGlzLmVsLnBhcmVudEVsZW1lbnQuY2xhc3NOYW1lICs9ICcgaGFzLW5nMi1tZW51Jztcblx0XHQgICAgfVxuXHRcdCAgICBOZzJNZW51RGlyZWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAgICAgICAgICAgIF90aGlzLmVsLnBhcmVudEVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIGFjdGl2ZVwiO1xuXHRcdCAgICAgICAgICAgIF90aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdCAgICAgICAgICAgIGlmIChfdGhpcy5lbC5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLnNldFBvc2l0aW9uKCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsc2Uge1xuXHRcdCAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnNldFBvc2l0aW9uKCk7IH0pO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICAgICAgICAgICAgX3RoaXMuZWwucGFyZW50RWxlbWVudC5jbGFzc05hbWUgPSBfdGhpcy5lbC5wYXJlbnRFbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKC9cXHM/YWN0aXZlLywgJycpO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMk1lbnVEaXJlY3RpdmUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09IFwiYm90dG9tXCIpIHtcblx0XHQgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmxlZnQgPSBcIjBcIjtcblx0XHQgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRoaXMuZWwucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQgLSAxICsgJ3B4Jztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHRoaXMucG9zaXRpb24gPT09IFwidG9wXCIpIHtcblx0XHQgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmxlZnQgPSBcIjBcIjtcblx0XHQgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLmJvdHRvbSA9IHRoaXMuZWwucGFyZW50RWxlbWVudC5vZmZzZXRIZWlnaHQgLSAxICsgJ3B4Jztcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIGVsc2UgaWYgKHRoaXMucG9zaXRpb24gPT09IFwicmlnaHRcIikge1xuXHRcdCAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IHRoaXMuZWwucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aCAtIDEgKyAncHgnO1xuXHRcdCAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gXCIwXCI7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIGlmICh0aGlzLnBvc2l0aW9uID09PSBcImxlZnRcIikge1xuXHRcdCAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUucmlnaHQgPSB0aGlzLmVsLnBhcmVudEVsZW1lbnQub2Zmc2V0V2lkdGggLSAxICsgJ3B4Jztcblx0XHQgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IFwiMFwiO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dCgnbmcyLW1lbnUnKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgTmcyTWVudURpcmVjdGl2ZS5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcblx0XHQgICAgTmcyTWVudURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkRpcmVjdGl2ZSh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmcyLW1lbnVdJ1xuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLlZpZXdDb250YWluZXJSZWZdKVxuXHRcdCAgICBdLCBOZzJNZW51RGlyZWN0aXZlKTtcblx0XHQgICAgcmV0dXJuIE5nMk1lbnVEaXJlY3RpdmU7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMk1lbnVEaXJlY3RpdmUgPSBOZzJNZW51RGlyZWN0aXZlO1xuXHRcblx0XG5cdC8qKiovIH1cblx0LyoqKioqKi8gXSlcblx0fSk7XG5cdDtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLW1lbnUudW1kLmpzLm1hcFxuXG4vKioqLyB9LFxuLyogMTUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdChmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdFx0aWYodHJ1ZSlcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcblx0XHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRcdGRlZmluZShbXCJAYW5ndWxhci9jb3JlXCIsIFwiQGFuZ3VsYXIvZm9ybXNcIiwgXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCJdLCBmYWN0b3J5KTtcblx0XHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRcdGV4cG9ydHNbXCJuZzItcGFyYWxsYXgtc2Nyb2xsXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKSwgcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cm9vdFtcIm5nMi1wYXJhbGxheC1zY3JvbGxcIl0gPSBmYWN0b3J5KHJvb3RbXCJAYW5ndWxhci9jb3JlXCJdLCByb290W1wiQGFuZ3VsYXIvZm9ybXNcIl0sIHJvb3RbXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCJdKTtcblx0fSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xuXHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHQvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdC8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcblx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQvKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcblx0LyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuXHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdC8qKioqKiovIFx0XHR9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0LyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0LyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0LyoqKioqKi8gXHR9XG5cdC8qKioqKiovXG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5cdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdC8qKioqKiovIH0pXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKiovIChbXG5cdC8qIDAgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgZm9ybXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFx0dmFyIHBsYXRmb3JtX2Jyb3dzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFx0dmFyIG5nMl9wYXJhbGxheF9zY3JvbGxfZGlyZWN0aXZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcdGV4cG9ydHMuTmcyUGFyYWxsYXhTY3JvbGxEaXJlY3RpdmUgPSBuZzJfcGFyYWxsYXhfc2Nyb2xsX2RpcmVjdGl2ZV8xLk5nMlBhcmFsbGF4U2Nyb2xsRGlyZWN0aXZlO1xuXHRcdHZhciBOZzJQYXJhbGxheFNjcm9sbE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMlBhcmFsbGF4U2Nyb2xsTW9kdWxlKCkge1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlBhcmFsbGF4U2Nyb2xsTW9kdWxlID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuTmdNb2R1bGUoe1xuXHRcdCAgICAgICAgICAgIGltcG9ydHM6IFtwbGF0Zm9ybV9icm93c2VyXzEuQnJvd3Nlck1vZHVsZSwgZm9ybXNfMS5Gb3Jtc01vZHVsZV0sXG5cdFx0ICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbbmcyX3BhcmFsbGF4X3Njcm9sbF9kaXJlY3RpdmVfMS5OZzJQYXJhbGxheFNjcm9sbERpcmVjdGl2ZV0sXG5cdFx0ICAgICAgICAgICAgZXhwb3J0czogW25nMl9wYXJhbGxheF9zY3JvbGxfZGlyZWN0aXZlXzEuTmcyUGFyYWxsYXhTY3JvbGxEaXJlY3RpdmVdXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBOZzJQYXJhbGxheFNjcm9sbE1vZHVsZSk7XG5cdFx0ICAgIHJldHVybiBOZzJQYXJhbGxheFNjcm9sbE1vZHVsZTtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuTmcyUGFyYWxsYXhTY3JvbGxNb2R1bGUgPSBOZzJQYXJhbGxheFNjcm9sbE1vZHVsZTtcblx0XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAxICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogMiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDMgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiA0ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIE5nMlBhcmFsbGF4U2Nyb2xsRGlyZWN0aXZlID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTmcyUGFyYWxsYXhTY3JvbGxEaXJlY3RpdmUodmlld0NvbnRhaW5lcikge1xuXHRcdCAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcblx0XHQgICAgICAgIHRoaXMuZWwgPSB0aGlzLnZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlBhcmFsbGF4U2Nyb2xsRGlyZWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgdGhpcy5pbWcgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoXCJpbWdcIik7XG5cdFx0ICAgICAgICB0aGlzLmltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgX3RoaXMuaW1nT3JnV2lkdGggPSBfdGhpcy5pbWdPcmdXaWR0aCB8fCBfdGhpcy5pbWcub2Zmc2V0V2lkdGg7XG5cdFx0ICAgICAgICAgICAgX3RoaXMuaW1nT3JnSGVpZ2h0ID0gX3RoaXMuaW1nT3JnSGVpZ2h0IHx8IF90aGlzLmltZy5vZmZzZXRIZWlnaHQ7XG5cdFx0ICAgICAgICAgICAgY29uc29sZS5sb2coX3RoaXMuaW1nLm9mZnNldFdpZHRoLCBfdGhpcy5pbWcub2Zmc2V0SGVpZ2h0LCBfdGhpcy5pbWcud2lkdGgsIF90aGlzLmltZy5oZWlnaHQpO1xuXHRcdCAgICAgICAgICAgIF90aGlzLnNldFBhcmFsbGF4SW1hZ2UoKTtcblx0XHQgICAgICAgICAgICBfdGhpcy51cGRhdGVQYXJhbGxheEltYWdlKCk7XG5cdFx0ICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUGFyYWxsYXhJbWFnZSgpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLnNldFBhcmFsbGF4SW1hZ2UoKTtcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUGFyYWxsYXhJbWFnZSgpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgfTtcblx0XHQgICAgfTtcblx0XHQgICAgTmcyUGFyYWxsYXhTY3JvbGxEaXJlY3RpdmUucHJvdG90eXBlLnNldFBhcmFsbGF4SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAvL3NldCBpbWcgc3R5bGVcblx0XHQgICAgICAgIHZhciBpbWdTaXplID0gdGhpcy5pbWdPcmdXaWR0aCA+IHRoaXMuZWwub2Zmc2V0V2lkdGggP1xuXHRcdCAgICAgICAgICAgIHsgd2lkdGg6IHRoaXMuZWwub2Zmc2V0V2lkdGggKyAncHgnIH0gOiB7IGhlaWdodDogdGhpcy5lbC5vZmZzZXRIZWlnaHQgKiAxLjUgKyAncHgnIH07XG5cdFx0ICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuaW1nLnN0eWxlLCB7XG5cdFx0ICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJywgcG9zaXRpb246ICdhYnNvbHV0ZScsIGJvdHRvbTogMCwgbGVmdDogMFxuXHRcdCAgICAgICAgfSwgaW1nU2l6ZSk7XG5cdFx0ICAgICAgICAvLyBzZXQgY29udGFpbmVyIHN0eWxlXG5cdFx0ICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZWwuc3R5bGUsIHtcblx0XHQgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJywgb3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIC8vIHdyYXAgaW1hZ2Ugd2l0aCBhIGRpdiwgdGhlbiBzZXQgc3R5bGVcblx0XHQgICAgICAgIHZhciBpbWdXcmFwcGVyRWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5wYXJhbGxheC1pbWctd3JhcHBlcicpO1xuXHRcdCAgICAgICAgaWYgKCFpbWdXcmFwcGVyRWwpIHtcblx0XHQgICAgICAgICAgICBpbWdXcmFwcGVyRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHQgICAgICAgICAgICBpbWdXcmFwcGVyRWwuY2xhc3NOYW1lID0gJ3BhcmFsbGF4LWltZy13cmFwcGVyJztcblx0XHQgICAgICAgICAgICBpbWdXcmFwcGVyRWwuYXBwZW5kQ2hpbGQodGhpcy5pbWcpO1xuXHRcdCAgICAgICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoaW1nV3JhcHBlckVsKTtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIE9iamVjdC5hc3NpZ24oaW1nV3JhcHBlckVsLnN0eWxlLCB7XG5cdFx0ICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsIHRvcDogMCwgbGVmdDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgekluZGV4OiAtMVxuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMlBhcmFsbGF4U2Nyb2xsRGlyZWN0aXZlLnByb3RvdHlwZS51cGRhdGVQYXJhbGxheEltYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgdmFyIGVsUmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0ICAgICAgICB2YXIgaW1nUmVjdCA9IHRoaXMuaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdCAgICAgICAgdmFyIGltZ0Rpc3QgPSBpbWdSZWN0LmhlaWdodCAtIGVsUmVjdC5oZWlnaHQ7XG5cdFx0ICAgICAgICB2YXIgYm90dG9tID0gdGhpcy5lbC5vZmZzZXRUb3AgKyBlbFJlY3QuaGVpZ2h0O1xuXHRcdCAgICAgICAgdmFyIHRvcCA9IHRoaXMuZWwub2Zmc2V0VG9wO1xuXHRcdCAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuXHRcdCAgICAgICAgdmFyIHdpbmRvd0JvdHRvbSA9IHNjcm9sbFRvcCArIHdpbmRvdy5pbm5lckhlaWdodDtcblx0XHQgICAgICAgIHZhciBwZXJjZW50U2Nyb2xsZWQgPSAod2luZG93Qm90dG9tIC0gdG9wKSAvIChlbFJlY3QuaGVpZ2h0ICsgd2luZG93LmlubmVySGVpZ2h0KTtcblx0XHQgICAgICAgIC8vY29uc29sZS5sb2coaW1nRGlzdCwgcGVyY2VudFNjcm9sbGVkLCBpbWdEaXN0ICogcGVyY2VudFNjcm9sbGVkKTtcblx0XHQgICAgICAgIHZhciBwYXJhbGxheCA9IE1hdGgucm91bmQoKGltZ0Rpc3QgKiBwZXJjZW50U2Nyb2xsZWQpKTtcblx0XHQgICAgICAgIGlmICgoYm90dG9tID4gc2Nyb2xsVG9wKSAmJiAodG9wIDwgKHNjcm9sbFRvcCArIHdpbmRvdy5pbm5lckhlaWdodCkpKSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5pbWcuc3R5bGUuYm90dG9tID0gcGFyYWxsYXggKiAtMSArICdweCc7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMlBhcmFsbGF4U2Nyb2xsRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHtcblx0XHQgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZzItcGFyYWxsYXhdLCBuZzItcGFyYWxsYXgnXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjb3JlXzEuVmlld0NvbnRhaW5lclJlZl0pXG5cdFx0ICAgIF0sIE5nMlBhcmFsbGF4U2Nyb2xsRGlyZWN0aXZlKTtcblx0XHQgICAgcmV0dXJuIE5nMlBhcmFsbGF4U2Nyb2xsRGlyZWN0aXZlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJQYXJhbGxheFNjcm9sbERpcmVjdGl2ZSA9IE5nMlBhcmFsbGF4U2Nyb2xsRGlyZWN0aXZlO1xuXHRcblx0XG5cdC8qKiovIH1cblx0LyoqKioqKi8gXSlcblx0fSk7XG5cdDtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLXBhcmFsbGF4LXNjcm9sbC51bWQuanMubWFwXG5cbi8qKiovIH0sXG4vKiAxNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRpZih0cnVlKVxuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMSksIF9fd2VicGFja19yZXF1aXJlX18oMiksIF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0ZGVmaW5lKFtcIkBhbmd1bGFyL2NvcmVcIiwgXCJAYW5ndWxhci9mb3Jtc1wiLCBcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0sIGZhY3RvcnkpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdFx0ZXhwb3J0c1tcIm5nMi1wb3B1cFwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKSwgcmVxdWlyZShcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIikpO1xuXHRcdGVsc2Vcblx0XHRcdHJvb3RbXCJuZzItcG9wdXBcIl0gPSBmYWN0b3J5KHJvb3RbXCJAYW5ndWxhci9jb3JlXCJdLCByb290W1wiQGFuZ3VsYXIvZm9ybXNcIl0sIHJvb3RbXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCJdKTtcblx0fSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xuXHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHQvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdC8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcblx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHQvKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcblx0LyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuXHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdC8qKioqKiovIFx0XHR9O1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdC8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0LyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0LyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0LyoqKioqKi8gXHR9XG5cdC8qKioqKiovXG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG5cdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdC8qKioqKiovIH0pXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKiovIChbXG5cdC8qIDAgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgZm9ybXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFx0dmFyIHBsYXRmb3JtX2Jyb3dzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFx0dmFyIG5nMl9vdmVybGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcdHZhciBuZzJfcG9wdXBfY29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcdGV4cG9ydHMuTmcyUG9wdXBDb21wb25lbnQgPSBuZzJfcG9wdXBfY29tcG9uZW50XzEuTmcyUG9wdXBDb21wb25lbnQ7XG5cdFx0dmFyIG5nMl9tZXNzYWdlX3BvcHVwX2NvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblx0XHRleHBvcnRzLk5nMk1lc3NhZ2VQb3B1cENvbXBvbmVudCA9IG5nMl9tZXNzYWdlX3BvcHVwX2NvbXBvbmVudF8xLk5nMk1lc3NhZ2VQb3B1cENvbXBvbmVudDtcblx0XHR2YXIgTmcyUG9wdXBNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJQb3B1cE1vZHVsZSgpIHtcblx0XHQgICAgfVxuXHRcdCAgICBOZzJQb3B1cE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHQgICAgICAgICAgICBpbXBvcnRzOiBbcGxhdGZvcm1fYnJvd3Nlcl8xLkJyb3dzZXJNb2R1bGUsIGZvcm1zXzEuRm9ybXNNb2R1bGUsIG5nMl9vdmVybGF5XzEuTmcyT3ZlcmxheU1vZHVsZV0sXG5cdFx0ICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbbmcyX21lc3NhZ2VfcG9wdXBfY29tcG9uZW50XzEuTmcyTWVzc2FnZVBvcHVwQ29tcG9uZW50LCBuZzJfcG9wdXBfY29tcG9uZW50XzEuTmcyUG9wdXBDb21wb25lbnRdLFxuXHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtuZzJfbWVzc2FnZV9wb3B1cF9jb21wb25lbnRfMS5OZzJNZXNzYWdlUG9wdXBDb21wb25lbnQsIG5nMl9wb3B1cF9jb21wb25lbnRfMS5OZzJQb3B1cENvbXBvbmVudF0sXG5cdFx0ICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbbmcyX21lc3NhZ2VfcG9wdXBfY29tcG9uZW50XzEuTmcyTWVzc2FnZVBvcHVwQ29tcG9uZW50XVxuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0XHQgICAgXSwgTmcyUG9wdXBNb2R1bGUpO1xuXHRcdCAgICByZXR1cm4gTmcyUG9wdXBNb2R1bGU7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMlBvcHVwTW9kdWxlID0gTmcyUG9wdXBNb2R1bGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAzICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogNCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRcdGlmKHRydWUpXG5cdFx0XHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcblx0XHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiLCBcIkBhbmd1bGFyL2Zvcm1zXCIsIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSwgZmFjdG9yeSk7XG5cdFx0XHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRcdFx0ZXhwb3J0c1tcIm5nMi1vdmVybGF5XCJdID0gZmFjdG9yeShyZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKSwgcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiKSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJvb3RbXCJuZzItb3ZlcmxheVwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9mb3Jtc1wiXSwgcm9vdFtcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0pO1xuXHRcdH0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcblx0XHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHRcdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHRcdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0XHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0XHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdFx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0XHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHRcdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHRcdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdFx0LyoqKioqKi8gXHRcdH07XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdFx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0XHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0XHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHRcdC8qKioqKiovIFx0fVxuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdFx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHRcdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0XHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHRcdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdFx0LyoqKioqKi8gfSlcblx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRcdC8qKioqKiovIChbXG5cdFx0LyogMCAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHRcdH07XG5cdFx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0XHR2YXIgZm9ybXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFx0XHR2YXIgcGxhdGZvcm1fYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHRcdHZhciBvdmVybGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcdFx0ZXhwb3J0cy5PdmVybGF5ID0gb3ZlcmxheV8xLk92ZXJsYXk7XG5cdFx0XHR2YXIgb3ZlcmxheV9tYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcdFx0ZXhwb3J0cy5PdmVybGF5TWFuYWdlciA9IG92ZXJsYXlfbWFuYWdlcl8xLk92ZXJsYXlNYW5hZ2VyO1xuXHRcdFx0dmFyIG92ZXJsYXlfZGlyZWN0aXZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcdFx0ZXhwb3J0cy5PdmVybGF5RGlyZWN0aXZlID0gb3ZlcmxheV9kaXJlY3RpdmVfMS5PdmVybGF5RGlyZWN0aXZlO1xuXHRcdFx0dmFyIE5nMk92ZXJsYXlNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgIGZ1bmN0aW9uIE5nMk92ZXJsYXlNb2R1bGUoKSB7XG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIE5nMk92ZXJsYXlNb2R1bGUgPSBfX2RlY29yYXRlKFtcblx0XHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHRcdCAgICAgICAgICAgIGltcG9ydHM6IFtwbGF0Zm9ybV9icm93c2VyXzEuQnJvd3Nlck1vZHVsZSwgZm9ybXNfMS5Gb3Jtc01vZHVsZV0sXG5cdFx0XHQgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtvdmVybGF5X2RpcmVjdGl2ZV8xLk92ZXJsYXlEaXJlY3RpdmVdLFxuXHRcdFx0ICAgICAgICAgICAgcHJvdmlkZXJzOiBbb3ZlcmxheV9tYW5hZ2VyXzEuT3ZlcmxheU1hbmFnZXJdLFxuXHRcdFx0ICAgICAgICAgICAgZXhwb3J0czogW292ZXJsYXlfZGlyZWN0aXZlXzEuT3ZlcmxheURpcmVjdGl2ZV1cblx0XHRcdCAgICAgICAgfSksIFxuXHRcdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdFx0ICAgIF0sIE5nMk92ZXJsYXlNb2R1bGUpO1xuXHRcdFx0ICAgIHJldHVybiBOZzJPdmVybGF5TW9kdWxlO1xuXHRcdFx0fSgpKTtcblx0XHRcdGV4cG9ydHMuTmcyT3ZlcmxheU1vZHVsZSA9IE5nMk92ZXJsYXlNb2R1bGU7XG5cdFx0XHQ7XG5cdFx0XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiAxICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogMiAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdFxuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDMgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiA0ICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFx0XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdHZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcdFx0dmFyIE92ZXJsYXkgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgIGZ1bmN0aW9uIE92ZXJsYXkoZWwsIG9wdGlvbnMpIHtcblx0XHRcdCAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHQgICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuXHRcdFx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdFx0XHQgICAgICAgIGlmICghdGhpcy5pZCkge1xuXHRcdFx0ICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIG92ZXJsYXkgaWRcIjtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbDsgLy8gb3ZlcmxheSB3cmFwcGVyIGVsZW1lbnQgd2l0aCB0YWJsZSBkc3BsYXlcblx0XHRcdCAgICAgICAgdGhpcy53aW5kb3dPdmVybGF5ID0gb3B0aW9ucy53aW5kb3dPdmVybGF5O1xuXHRcdFx0ICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvblByb3BlcnR5KG9wdGlvbnMucG9zaXRpb24gfHwgJ2NlbnRlciBjZW50ZXInKTtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgT3ZlcmxheS5wcm90b3R5cGUucG9zaXRpb25JdCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0ICAgICAgICBpZiAodGhpcy5wb3NpdGlvbi5pbnNpZGUpIHtcblx0XHRcdCAgICAgICAgICAgIHRoaXMucG9zaXRpb25JdEluc2lkZSh0aGlzLnBvc2l0aW9uKTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICBlbHNlIHtcblx0XHRcdCAgICAgICAgICAgIHRoaXMucG9zaXRpb25JdE91dHNpZGUodGhpcy5wb3NpdGlvbiwgZXZlbnQpO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgfTtcblx0XHRcdCAgICBPdmVybGF5LnByb3RvdHlwZS5nZXRQb3NpdGlvblByb3BlcnR5ID0gZnVuY3Rpb24gKHBvc2l0aW9uU3RyKSB7XG5cdFx0XHQgICAgICAgIHZhciBwb3NpdGlvbiA9IHt9LCBpbnNpZGU7XG5cdFx0XHQgICAgICAgIHZhciBfYSA9IHBvc2l0aW9uU3RyLnNwbGl0KCcgJyksIHZlcnRpY2FsID0gX2FbMF0sIGhvcml6b250YWwgPSBfYVsxXSwgaW5zaWRlU3RyID0gX2FbMl07XG5cdFx0XHQgICAgICAgIGhvcml6b250YWwgPSBob3Jpem9udGFsIHx8ICdjZW50ZXInO1xuXHRcdFx0ICAgICAgICB2ZXJ0aWNhbCA9IHZlcnRpY2FsIHx8ICdjZW50ZXInO1xuXHRcdFx0ICAgICAgICBpbnNpZGUgPSAoaW5zaWRlU3RyICE9PSAnb3V0c2lkZScgfHwgdGhpcy53aW5kb3dPdmVybGF5KTtcblx0XHRcdCAgICAgICAgcG9zaXRpb24uaG9yaXpvbnRhbCA9IE92ZXJsYXlbaG9yaXpvbnRhbC50b1VwcGVyQ2FzZSgpXTtcblx0XHRcdCAgICAgICAgcG9zaXRpb24udmVydGljYWwgPSBPdmVybGF5W3ZlcnRpY2FsLnRvVXBwZXJDYXNlKCldO1xuXHRcdFx0ICAgICAgICBwb3NpdGlvbi5pbnNpZGUgPSBpbnNpZGU7XG5cdFx0XHQgICAgICAgIHJldHVybiBwb3NpdGlvbjtcblx0XHRcdCAgICB9O1xuXHRcdFx0ICAgIE92ZXJsYXkucHJvdG90eXBlLnBvc2l0aW9uSXRJbnNpZGUgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcblx0XHRcdCAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG5cdFx0XHQgICAgICAgIC8vdG9wIC8gbGVmdCBwb3NpdGlvbmluZ1xuXHRcdFx0ICAgICAgICBpZiAodGhpcy53aW5kb3dPdmVybGF5KSB7XG5cdFx0XHQgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXHRcdFx0ICAgICAgICAgICAgLy93b3JrcyBhcyBibG9ja2VyXG5cdFx0XHQgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZWxlbWVudC5zdHlsZSwge1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC4yKScsXG5cdFx0XHQgICAgICAgICAgICAgICAgdG9wOiAnMCcsIGxlZnQ6ICcwJywgYm90dG9tOiAnMCcsIHJpZ2h0OiAnMCcsXG5cdFx0XHQgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSdcblx0XHRcdCAgICAgICAgICAgIH0pO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgICAgIGVsc2Uge1xuXHRcdFx0ICAgICAgICAgICAgLy9hZGp1c3QgdG9wL2xlZnQgdG8gbWF0Y2ggdG8gcGFyZW50RWxlbWVudFxuXHRcdFx0ICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHQgICAgICAgICAgICAvL3dvcmtzIGFzIGEgYmxvY2tlclxuXHRcdFx0ICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdCAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdCAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG5cdFx0XHQgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjIpJyxcblx0XHRcdCAgICAgICAgICAgICAgICB0b3A6IHBhcmVudEVsLm9mZnNldFRvcCArICdweCcsXG5cdFx0XHQgICAgICAgICAgICAgICAgbGVmdDogcGFyZW50RWwub2Zmc2V0TGVmdCArICdweCcsXG5cdFx0XHQgICAgICAgICAgICAgICAgd2lkdGg6IHBhcmVudEVsLm9mZnNldFdpZHRoICsgJ3B4Jyxcblx0XHRcdCAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcmVudEVsLm9mZnNldEhlaWdodCArICdweCdcblx0XHRcdCAgICAgICAgICAgIH0pO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgICAgIDtcblx0XHRcdCAgICAgICAgLy9ob3Jpem9udGFsIHBvc2l0aW9uXG5cdFx0XHQgICAgICAgIHN3aXRjaCAocG9zaXRpb24uaG9yaXpvbnRhbCkge1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkxFRlQ6XG5cdFx0XHQgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkNFTlRFUjpcblx0XHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnY2VudGVyJztcblx0XHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5SSUdIVDpcblx0XHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgICAgIC8vdmVydGljYWwgcG9zaXRpb25cblx0XHRcdCAgICAgICAgc3dpdGNoIChwb3NpdGlvbi52ZXJ0aWNhbCkge1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkxFRlQ6XG5cdFx0XHQgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmFsaWduSXRlbXMgPSAnZmxleC1zdGFydCc7XG5cdFx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuQ0VOVEVSOlxuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5Lk1JRERMRTpcblx0XHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlJJR0hUOlxuXHRcdFx0ICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2ZsZXgtZW5kJztcblx0XHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgIH07XG5cdFx0XHQgICAgT3ZlcmxheS5wcm90b3R5cGUucG9zaXRpb25JdE91dHNpZGUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGV2ZW50KSB7XG5cdFx0XHQgICAgICAgIC8vYWRqdXN0IHRvcC9sZWZ0IHRvIG1hdGNoIHRvIHBhcmVudEVsZW1lbnRcblx0XHRcdCAgICAgICAgdmFyIHBhcmVudEVsID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHQgICAgICAgIC8vd29ya3MgYXMgZ3VpZGUgbGluZT9cblx0XHRcdCAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdCAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0ICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuXHRcdFx0ICAgICAgICAgICAgdG9wOiBwYXJlbnRFbC5vZmZzZXRUb3AgKyAncHgnLFxuXHRcdFx0ICAgICAgICAgICAgbGVmdDogcGFyZW50RWwub2Zmc2V0TGVmdCArICdweCcsXG5cdFx0XHQgICAgICAgICAgICB3aWR0aDogcGFyZW50RWwub2Zmc2V0V2lkdGggKyAncHgnLFxuXHRcdFx0ICAgICAgICAgICAgaGVpZ2h0OiBwYXJlbnRFbC5vZmZzZXRIZWlnaHQgKyAncHgnXG5cdFx0XHQgICAgICAgIH0pO1xuXHRcdFx0ICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHQgICAgICAgIHZhciBlbFRvUG9zaXRpb24gPSAodGhpcy5lbGVtZW50LmNoaWxkcmVuWzBdKTtcblx0XHRcdCAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdCAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG5cdFx0XHQgICAgICAgIHN3aXRjaCAocG9zaXRpb24udmVydGljYWwpIHtcblx0XHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5UT1A6XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmJvdHRvbSA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkJPVFRPTTpcblx0XHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUudG9wID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCArICdweCc7XG5cdFx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuTEVGVDpcblx0XHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUucmlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGggKyAncHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlJJR0hUOlxuXHRcdFx0ICAgICAgICAgICAgICAgIGVsVG9Qb3NpdGlvbi5zdHlsZS5sZWZ0ID0gdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoICsgJ3B4Jztcblx0XHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uLmhvcml6b250YWwpIHtcblx0XHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5DRU5URVI6XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSAodGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoKSAvIDIgKyAncHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkxFRlQ6XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSAnMCc7XG5cdFx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuUklHSFQ6XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLnJpZ2h0ID0gJzAnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlRPUDpcblx0XHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUudG9wID0gJzAnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkJPVFRPTTpcblx0XHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUuYm90dG9tID0gJzAnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkNVUlNPUjpcblx0XHRcdCAgICAgICAgICAgICAgICB2YXIgbW91c2VQb3MgPSB1dGlsXzEuVXRpbC5nZXRNb3VzZVBvc2l0aW9uSW5FbGVtZW50KGV2ZW50LCB0aGlzLmVsZW1lbnQpO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGlmICgobW91c2VQb3MueCArIGVsVG9Qb3NpdGlvbi5vZmZzZXRXaWR0aCkgPiB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGgpIHtcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSAodGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoIC0gNSkgKyAncHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIH1cblx0XHRcdCAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VzZVBvcy54IDwgZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoIC8gMikge1xuXHRcdFx0ICAgICAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUubGVmdCA9ICcwcHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIH1cblx0XHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSBtb3VzZVBvcy54IC0gZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoIC8gMiArICdweCc7XG5cdFx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgfTtcblx0XHRcdCAgICBPdmVybGF5LlRPUCA9IDExO1xuXHRcdFx0ICAgIE92ZXJsYXkuTUlERExFID0gMTI7XG5cdFx0XHQgICAgT3ZlcmxheS5CT1RUT00gPSAxMztcblx0XHRcdCAgICBPdmVybGF5LkxFRlQgPSAyMTtcblx0XHRcdCAgICBPdmVybGF5LkNFTlRFUiA9IDIyO1xuXHRcdFx0ICAgIE92ZXJsYXkuUklHSFQgPSAyMztcblx0XHRcdCAgICBPdmVybGF5LkNVUlNPUiA9IDMxO1xuXHRcdFx0ICAgIHJldHVybiBPdmVybGF5O1xuXHRcdFx0fSgpKTtcblx0XHRcdGV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXk7XG5cdFx0XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiA1ICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdHZhciBVdGlsID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICBmdW5jdGlvbiBVdGlsKCkge1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBVdGlsLmdldERvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAob0VsZW1lbnQpIHtcblx0XHRcdCAgICAgICAgdmFyIHBvc1ggPSAwLCBwb3NZID0gMDtcblx0XHRcdCAgICAgICAgaWYgKG9FbGVtZW50Lm9mZnNldFBhcmVudCkge1xuXHRcdFx0ICAgICAgICAgICAgZm9yICg7IG9FbGVtZW50OyBvRWxlbWVudCA9IG9FbGVtZW50Lm9mZnNldFBhcmVudCkge1xuXHRcdFx0ICAgICAgICAgICAgICAgIHBvc1ggKz0gb0VsZW1lbnQub2Zmc2V0TGVmdDtcblx0XHRcdCAgICAgICAgICAgICAgICBwb3NZICs9IG9FbGVtZW50Lm9mZnNldFRvcDtcblx0XHRcdCAgICAgICAgICAgIH1cblx0XHRcdCAgICAgICAgICAgIHJldHVybiB7IHg6IHBvc1gsIHk6IHBvc1kgfTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICBlbHNlIHtcblx0XHRcdCAgICAgICAgICAgIHJldHVybiB7IHg6IG9FbGVtZW50Wyd4J10sIHk6IG9FbGVtZW50Wyd5J10gfTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgIH07XG5cdFx0XHQgICAgVXRpbC5nZXRNb3VzZVBvc2l0aW9uSW5FbGVtZW50ID0gZnVuY3Rpb24gKGV2dCwgZWxlbWVudCkge1xuXHRcdFx0ICAgICAgICBldnQgPSBldnQgfHwgd2luZG93LmV2ZW50O1xuXHRcdFx0ICAgICAgICB2YXIgcG9zWCA9IDAsIHBvc1kgPSAwO1xuXHRcdFx0ICAgICAgICB2YXIgZWxQb3MgPSB0aGlzLmdldERvY3VtZW50UG9zaXRpb24oZWxlbWVudCk7XG5cdFx0XHQgICAgICAgIGlmIChldnQucGFnZVggfHwgZXZ0LnBhZ2VZKSB7XG5cdFx0XHQgICAgICAgICAgICBwb3NYID0gZXZ0LnBhZ2VYO1xuXHRcdFx0ICAgICAgICAgICAgcG9zWSA9IGV2dC5wYWdlWTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICBlbHNlIGlmIChldnQuY2xpZW50WCB8fCBldnQuY2xpZW50WSkge1xuXHRcdFx0ICAgICAgICAgICAgcG9zWCA9IGV2dC5jbGllbnRYICtcblx0XHRcdCAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgK1xuXHRcdFx0ICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuXHRcdFx0ICAgICAgICAgICAgcG9zWSA9IGV2dC5jbGllbnRZICtcblx0XHRcdCAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArXG5cdFx0XHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdFx0ICAgICAgICAgICAgeDogcG9zWCAtIGVsUG9zLngsXG5cdFx0XHQgICAgICAgICAgICB5OiBwb3NZIC0gZWxQb3MueVxuXHRcdFx0ICAgICAgICB9O1xuXHRcdFx0ICAgIH07XG5cdFx0XHQgICAgcmV0dXJuIFV0aWw7XG5cdFx0XHR9KCkpO1xuXHRcdFx0ZXhwb3J0cy5VdGlsID0gVXRpbDtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDYgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdFx0dmFyIE92ZXJsYXlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICBmdW5jdGlvbiBPdmVybGF5TWFuYWdlcigpIHtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG92ZXJsYXkpIHtcblx0XHRcdCAgICAgICAgT3ZlcmxheU1hbmFnZXIub3ZlcmxheXNbb3ZlcmxheS5pZF0gPSBvdmVybGF5O1xuXHRcdFx0ICAgICAgICAvLyBjb25zb2xlLmxvZygnb3ZlcmxheS5yZWdpc3RlciwgT3ZlcmxheU1hbmFnZXIub3ZlcmxheXMnLCBPdmVybGF5TWFuYWdlci5vdmVybGF5cyk7XG5cdFx0XHQgICAgfTtcblx0XHRcdCAgICBPdmVybGF5TWFuYWdlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChhcmcsIGV2ZW50KSB7XG5cdFx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBPdmVybGF5TWFuYWdlci5vdmVybGF5c1thcmddIDogYXJnO1xuXHRcdFx0ICAgICAgICBpZiAoIW92ZXJsYXkub3BlbmVkKSB7XG5cdFx0XHQgICAgICAgICAgICBvdmVybGF5LnBvc2l0aW9uSXQoZXZlbnQpO1xuXHRcdFx0ICAgICAgICAgICAgb3ZlcmxheS5vcGVuZWQgPSB0cnVlO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgfTtcblx0XHRcdCAgICBPdmVybGF5TWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdFx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBPdmVybGF5TWFuYWdlci5vdmVybGF5c1thcmddIDogYXJnO1xuXHRcdFx0ICAgICAgICBvdmVybGF5LmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdCAgICAgICAgb3ZlcmxheS5vcGVuZWQgPSBmYWxzZTtcblx0XHRcdCAgICB9O1xuXHRcdFx0ICAgIC8vbGlzdCBvZiBvdmVybGF5IG9iamVjdHNcblx0XHRcdCAgICBPdmVybGF5TWFuYWdlci5vdmVybGF5cyA9IHt9O1xuXHRcdFx0ICAgIE92ZXJsYXlNYW5hZ2VyID0gX19kZWNvcmF0ZShbXG5cdFx0XHQgICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKCksIFxuXHRcdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdFx0ICAgIF0sIE92ZXJsYXlNYW5hZ2VyKTtcblx0XHRcdCAgICByZXR1cm4gT3ZlcmxheU1hbmFnZXI7XG5cdFx0XHR9KCkpO1xuXHRcdFx0ZXhwb3J0cy5PdmVybGF5TWFuYWdlciA9IE92ZXJsYXlNYW5hZ2VyO1xuXHRcdFxuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogNyAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHRcdH07XG5cdFx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0XHR2YXIgb3ZlcmxheV9tYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcdFx0dmFyIG92ZXJsYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0XHR2YXIgT3ZlcmxheURpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQgICAgZnVuY3Rpb24gT3ZlcmxheURpcmVjdGl2ZSh2aWV3Q29udGFpbmVyUmVmLCBvdmVybGF5TWFuYWdlcikge1xuXHRcdFx0ICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuXHRcdFx0ICAgICAgICB0aGlzLm92ZXJsYXlNYW5hZ2VyID0gb3ZlcmxheU1hbmFnZXI7XG5cdFx0XHQgICAgICAgIHRoaXMuZWwgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHQgICAgICAgIHRoaXMud3JhcEl0V2l0aE92ZXJsYXlUYWcoKTtcblx0XHRcdCAgICAgICAgdGhpcy5yZWdpc3RlclRvT3ZlcmxheU1hbmFnZXIoKTtcblx0XHRcdCAgICB9O1xuXHRcdFx0ICAgIE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLndyYXBJdFdpdGhPdmVybGF5VGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgICAgICAvL2NvbnNvbGUubG9nKCd3cmFwcGVkIG92ZXJsYXkgZGlyZWN0aXZlIGVsZW1lbnQgd2l0aCA8bmcyLW92ZXJsYXk+Jyk7XG5cdFx0XHQgICAgICAgIHRoaXMub3ZlcmxheUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmcyLW92ZXJsYXknKTtcblx0XHRcdCAgICAgICAgdGhpcy5vdmVybGF5RWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdCAgICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLm92ZXJsYXlFbCwgdGhpcy5lbC5uZXh0U2libGluZyk7XG5cdFx0XHQgICAgICAgIHRoaXMub3ZlcmxheUVsLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuXHRcdFx0ICAgIH07XG5cdFx0XHQgICAgLy9jcmVhdGUgT3ZlcmxheSBvYmplY3QsICB0aGVuIHJlZ2lzdGVyIHRoaXMgZWxlbWVudCB0byBvdmVybGF5TWFuYWdlclxuXHRcdFx0ICAgIE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLnJlZ2lzdGVyVG9PdmVybGF5TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICAgICAgdmFyIHBvc2l0aW9uU3RyID0gdGhpcy5vdmVybGF5UG9zaXRpb247XG5cdFx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gbmV3IG92ZXJsYXlfMS5PdmVybGF5KHRoaXMub3ZlcmxheUVsLCB7XG5cdFx0XHQgICAgICAgICAgICBpZDogdGhpcy5lbC5pZCxcblx0XHRcdCAgICAgICAgICAgIHdpbmRvd092ZXJsYXk6IHRoaXMub3ZlcmxheU9mID09IFwid2luZG93XCIsXG5cdFx0XHQgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25TdHJcblx0XHRcdCAgICAgICAgfSk7XG5cdFx0XHQgICAgICAgIC8vY29uc29sZS5sb2coJ3JlZ2lzdGVyaW5nIG92ZXJsYXknLCBvdmVybGF5KTtcblx0XHRcdCAgICAgICAgdGhpcy5vdmVybGF5TWFuYWdlci5yZWdpc3RlcihvdmVybGF5KTtcblx0XHRcdCAgICB9O1xuXHRcdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoJ25nMi1vdmVybGF5LW9mJyksIFxuXHRcdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHRcdCAgICBdLCBPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvdmVybGF5T2ZcIiwgdm9pZCAwKTtcblx0XHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHRcdCAgICAgICAgY29yZV8xLklucHV0KCduZzItb3ZlcmxheS1wb3NpdGlvbicpLCBcblx0XHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0XHQgICAgXSwgT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3ZlcmxheVBvc2l0aW9uXCIsIHZvaWQgMCk7XG5cdFx0XHQgICAgT3ZlcmxheURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuXHRcdFx0ICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHtcblx0XHRcdCAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nMi1vdmVybGF5XSwgW25nMi1vdmVybGF5LW9mXSwgW25nMi1vdmVybGF5LXBvc2l0aW9uXScsXG5cdFx0XHQgICAgICAgIH0pLCBcblx0XHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLlZpZXdDb250YWluZXJSZWYsIG92ZXJsYXlfbWFuYWdlcl8xLk92ZXJsYXlNYW5hZ2VyXSlcblx0XHRcdCAgICBdLCBPdmVybGF5RGlyZWN0aXZlKTtcblx0XHRcdCAgICByZXR1cm4gT3ZlcmxheURpcmVjdGl2ZTtcblx0XHRcdH0oKSk7XG5cdFx0XHRleHBvcnRzLk92ZXJsYXlEaXJlY3RpdmUgPSBPdmVybGF5RGlyZWN0aXZlO1xuXHRcdFxuXHRcdFxuXHRcdC8qKiovIH1cblx0XHQvKioqKioqLyBdKVxuXHRcdH0pO1xuXHRcdDtcblx0XHQvLyMgc291cmNlTWFwcGluZ1VSTD1uZzItb3ZlcmxheS51bWQuanMubWFwXG5cdFxuXHQvKioqLyB9LFxuXHQvKiA1ICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIG5nMl9vdmVybGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcdHZhciBOZzJQb3B1cENvbXBvbmVudCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMlBvcHVwQ29tcG9uZW50KGNvbXBvbmVudFJlc29sdmVyLCBvdmVybGF5TWFuYWdlcikge1xuXHRcdCAgICAgICAgdGhpcy5jb21wb25lbnRSZXNvbHZlciA9IGNvbXBvbmVudFJlc29sdmVyO1xuXHRcdCAgICAgICAgdGhpcy5vdmVybGF5TWFuYWdlciA9IG92ZXJsYXlNYW5hZ2VyO1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlBvcHVwQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB2YXIgb3ZlcmxheUVsID0gdGhpcy5tYXJrZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gbmV3IG5nMl9vdmVybGF5XzEuT3ZlcmxheShvdmVybGF5RWwsIHtcblx0XHQgICAgICAgICAgICBpZDogJ25nMi1wb3B1cC1vdmVybGF5Jyxcblx0XHQgICAgICAgICAgICB3aW5kb3dPdmVybGF5OiB0cnVlLFxuXHRcdCAgICAgICAgICAgIHBvc2l0aW9uOiAnY2VudGVyIGNlbnRlcidcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgdGhpcy5vdmVybGF5TWFuYWdlci5yZWdpc3RlcihvdmVybGF5KTtcblx0XHQgICAgfTtcblx0XHQgICAgTmcyUG9wdXBDb21wb25lbnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdFx0ICAgICAgICB0aGlzLmNsb3NlKCk7XG5cdFx0ICAgICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG5cdFx0ICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBvcHRpb25zLmNsYXNzTmFtZXM7XG5cdFx0ICAgICAgICB0aGlzLmNsb3NlQnV0dG9uID0gb3B0aW9ucy5jbG9zZUJ1dHRvbjtcblx0XHQgICAgICAgIHZhciBmYWN0b3J5ID0gdGhpcy5jb21wb25lbnRSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnQpO1xuXHRcdCAgICAgICAgdmFyIGNvbXBvbmVudFJlZiA9IHRoaXMubWFya2VyLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5KTtcblx0XHQgICAgICAgIGNvbXBvbmVudFJlZi5pbnN0YW5jZS5wb3B1cE9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdCAgICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlLnBvcHVwID0gdGhpcztcblx0XHQgICAgICAgIHRoaXMub3ZlcmxheU1hbmFnZXIub3BlbignbmcyLXBvcHVwLW92ZXJsYXknLCBudWxsKTsgLy8oaWQsIGV2ZW50KVxuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJQb3B1cENvbXBvbmVudC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuXHRcdCAgICAgICAgdGhpcy5vdmVybGF5TWFuYWdlci5jbG9zZSgnbmcyLXBvcHVwLW92ZXJsYXknKTtcblx0XHQgICAgICAgIHRyeSB7XG5cdFx0ICAgICAgICAgICAgdGhpcy5tYXJrZXIucmVtb3ZlKCk7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBjYXRjaCAoZSkgeyB9XG5cdFx0ICAgIH07XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLlZpZXdDaGlsZCgnbWFya2VyJywgeyByZWFkOiBjb3JlXzEuVmlld0NvbnRhaW5lclJlZiB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIE9iamVjdClcblx0XHQgICAgXSwgTmcyUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcIm1hcmtlclwiLCB2b2lkIDApO1xuXHRcdCAgICBOZzJQb3B1cENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkNvbXBvbmVudCh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICduZzItcG9wdXAnLFxuXHRcdCAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtuZzJfb3ZlcmxheV8xLk92ZXJsYXlEaXJlY3RpdmVdLFxuXHRcdCAgICAgICAgICAgIHByb3ZpZGVyczogW25nMl9vdmVybGF5XzEuT3ZlcmxheU1hbmFnZXJdLFxuXHRcdCAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICA8ZGl2IGlkPVxcXCJuZzItcG9wdXAtb3ZlcmxheVxcXCI+IDwhLS0gPC0tIHRoaXMgaXMgb3ZlcmxheSAtLT5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwb3B1cC1jb250YWluZXIge3tjbGFzc05hbWVzfX1cXFwiIFtuZ0NsYXNzXT1cXFwie29wZW5lZDogb3BlbmVkfVxcXCI+XFxuICAgICAgICA8ZGl2ICpuZ0lmPVxcXCJjbG9zZUJ1dHRvbiAhPSBmYWxzZVxcXCIgY2xhc3M9XFxcImNsb3NlLXBvcHVwXFxcIiAoY2xpY2spPVxcXCJjbG9zZSgpXFxcIj54PC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtYXJrZXJcXFwiICNtYXJrZXI+PC9kaXY+IDwhLS0gdG8gcG9zaXRpb24gcG9wdXAgY29tcG9uZW50IC0tPlxcbiAgICAgICAgPCEtLSBwb3B1cCBjb21wb25lbnQgd2lsbCBiZSBoZXJlIC0tPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIFwiLFxuXHRcdCAgICAgICAgICAgIHN0eWxlczogW1wiXFxuICAgIC5wb3B1cC1jb250YWluZXIgeyBcXG4gICAgICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XFxuICAgICAgYm94LXNoYWRvdzogMCA1cHggMTVweCByZ2JhKDAsMCwwLC41KTtcXG4gICAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICAgICAgd2lkdGg6IDYwMHB4O1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIH1cXG4gICAgLnBvcHVwLWNvbnRhaW5lci5vcGVuZWQgeyBcXG4gICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgfVxcbiAgICAuY2xvc2UtcG9wdXAge1xcbiAgICAgIGZvbnQtZmFtaWx5OiBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmO1xcbiAgICAgIGZsb2F0OiByaWdodDsgXFxuICAgICAgY3Vyc29yOiBwb2ludGVyOyBcXG4gICAgICBmb250LXNpemU6IDIxcHg7XFxuICAgICAgbGluZS1oZWlnaHQ6IDE7XFxuICAgICAgdGV4dC1zaGFkb3c6IDAgMXB4IDAgI2ZmZjtcXG4gICAgICBvcGFjaXR5OiAwLjI7XFxuICAgICAgcGFkZGluZzogMTBweDtcXG4gICAgfVxcbiAgICAvKi5tYXJrZXIgfiAqIHsgZGlzcGxheTpibG9jazsgYmFja2dyb3VuZDogI2ZmZn0qL1xcbiAgICAucG9wdXAtY29udGFpbmVyLnNtYWxsIHsgd2lkdGg6IDMwMHB4fVxcbiAgICAucG9wdXAtY29udGFpbmVyLmxhcmdlIHsgd2lkdGg6IDkwMHB4fVxcbiAgXCJdLFxuXHRcdCAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjb3JlXzEuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBuZzJfb3ZlcmxheV8xLk92ZXJsYXlNYW5hZ2VyXSlcblx0XHQgICAgXSwgTmcyUG9wdXBDb21wb25lbnQpO1xuXHRcdCAgICByZXR1cm4gTmcyUG9wdXBDb21wb25lbnQ7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMlBvcHVwQ29tcG9uZW50ID0gTmcyUG9wdXBDb21wb25lbnQ7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNiAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBOZzJNZXNzYWdlUG9wdXBDb21wb25lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJNZXNzYWdlUG9wdXBDb21wb25lbnQoKSB7XG5cdFx0ICAgIH1cblx0XHQgICAgTmcyTWVzc2FnZVBvcHVwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuQ29tcG9uZW50KHtcblx0XHQgICAgICAgICAgICBzZWxlY3RvcjogJ25nMi1tZXNzYWdlLXBvcHVwJyxcblx0XHQgICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgPGRpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwb3B1cC1oZWFkZXJcXFwiPnt7cG9wdXBPcHRpb25zLnRpdGxlfX08L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwb3B1cC1ib2R5XFxcIj57e3BvcHVwT3B0aW9ucy5tZXNzYWdlfX08L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwb3B1cC1mb290ZXJcXFwiICpuZ0lmPVxcXCJwb3B1cE9wdGlvbnMuYnV0dG9uc1xcXCI+XFxuICAgICAgICA8YnV0dG9uICpuZ0lmPVxcXCJwb3B1cE9wdGlvbnMuYnV0dG9ucy5PS1xcXCJcXG4gICAgICAgICAgKGNsaWNrKT1cXFwicG9wdXBPcHRpb25zLmJ1dHRvbnMuT0soKVxcXCI+T2s8L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gKm5nSWY9XFxcInBvcHVwT3B0aW9ucy5idXR0b25zLkNBTkNFTFxcXCJcXG4gICAgICAgICAgKGNsaWNrKT1cXFwicG9wdXBPcHRpb25zLmJ1dHRvbnMuQ0FOQ0VMKClcXFwiPkNhbmNlbDwvYnV0dG9uPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIFwiLFxuXHRcdCAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuXHRcdCAgICAgICAgICAgIHN0eWxlczogW1wiXFxuICAgIC5wb3B1cC1oZWFkZXIsIC5wb3B1cC1ib2R5LCAucG9wdXAtZm9vdGVyIHtcXG4gICAgICBwYWRkaW5nOiAxNXB4O1xcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgfVxcbiAgICAucG9wdXAtaGVhZGVyICB7XFxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgICAgZm9udC1zaXplOiAxOHB4O1xcbiAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjY2NjO1xcbiAgICB9XFxuICBcIl1cblx0XHQgICAgICAgIH0pLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG5cdFx0ICAgIF0sIE5nMk1lc3NhZ2VQb3B1cENvbXBvbmVudCk7XG5cdFx0ICAgIHJldHVybiBOZzJNZXNzYWdlUG9wdXBDb21wb25lbnQ7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMk1lc3NhZ2VQb3B1cENvbXBvbmVudCA9IE5nMk1lc3NhZ2VQb3B1cENvbXBvbmVudDtcblx0XG5cdFxuXHQvKioqLyB9XG5cdC8qKioqKiovIF0pXG5cdH0pO1xuXHQ7XG5cdC8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nMi1wb3B1cC51bWQuanMubWFwXG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRpZih0cnVlKVxuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMSksIF9fd2VicGFja19yZXF1aXJlX18oMiksIF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0ZGVmaW5lKFtcIkBhbmd1bGFyL2NvcmVcIiwgXCJAYW5ndWxhci9mb3Jtc1wiLCBcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0sIGZhY3RvcnkpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdFx0ZXhwb3J0c1tcIm5nMi1zdGlja3lcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIpKTtcblx0XHRlbHNlXG5cdFx0XHRyb290W1wibmcyLXN0aWNreVwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9mb3Jtc1wiXSwgcm9vdFtcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0pO1xuXHR9KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fKSB7XG5cdHJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG5cdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0LyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuXHQvKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdC8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG5cdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHQvKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG5cdC8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcblx0LyoqKioqKi8gXHRcdH07XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHQvKioqKioqLyBcdH1cblx0LyoqKioqKi9cblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblx0LyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblx0LyoqKioqKi8gfSlcblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKi8gKFtcblx0LyogMCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBmb3Jtc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XHR2YXIgcGxhdGZvcm1fYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHR2YXIgbmcyX3N0aWNreV9kaXJlY3RpdmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0ZXhwb3J0cy5OZzJTdGlja3lEaXJlY3RpdmUgPSBuZzJfc3RpY2t5X2RpcmVjdGl2ZV8xLk5nMlN0aWNreURpcmVjdGl2ZTtcblx0XHR2YXIgTmcyU3RpY2t5TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTmcyU3RpY2t5TW9kdWxlKCkge1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlN0aWNreU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHQgICAgICAgICAgICBpbXBvcnRzOiBbcGxhdGZvcm1fYnJvd3Nlcl8xLkJyb3dzZXJNb2R1bGUsIGZvcm1zXzEuRm9ybXNNb2R1bGVdLFxuXHRcdCAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW25nMl9zdGlja3lfZGlyZWN0aXZlXzEuTmcyU3RpY2t5RGlyZWN0aXZlXSxcblx0XHQgICAgICAgICAgICBleHBvcnRzOiBbbmcyX3N0aWNreV9kaXJlY3RpdmVfMS5OZzJTdGlja3lEaXJlY3RpdmVdXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBOZzJTdGlja3lNb2R1bGUpO1xuXHRcdCAgICByZXR1cm4gTmcyU3RpY2t5TW9kdWxlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJTdGlja3lNb2R1bGUgPSBOZzJTdGlja3lNb2R1bGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAzICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogNCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcdHZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcblx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHQgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcblx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHR9O1xuXHRcdHZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0fTtcblx0XHR2YXIgY29yZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblx0XHR2YXIgbmcyX3V0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcdHZhciBOZzJTdGlja3lEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJTdGlja3lEaXJlY3RpdmUoZWwpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICB0aGlzLnN0aWNreU9mZnNldFRvcCA9IDA7XG5cdFx0ICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgLy8gbGV0IGVsUmVjdDogQ2xpZW50UmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0ICAgICAgICAgICAgdmFyIHBhcmVudFJlY3QgPSBfdGhpcy5lbC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdCAgICAgICAgICAgIHZhciBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0ICAgICAgICAgICAgdmFyIGR5blByb3BzO1xuXHRcdCAgICAgICAgICAgIGlmIChfdGhpcy5vcmlnaW5hbC5mbG9hdCA9PT0gJ3JpZ2h0Jykge1xuXHRcdCAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBib2R5UmVjdC5yaWdodCAtIHBhcmVudFJlY3QucmlnaHQgKyBfdGhpcy5vcmlnaW5hbC5tYXJnaW5SaWdodDtcblx0XHQgICAgICAgICAgICAgICAgZHluUHJvcHMgPSB7IHJpZ2h0OiByaWdodCArICdweCcgfTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMub3JpZ2luYWwuZmxvYXQgPT09ICdsZWZ0Jykge1xuXHRcdCAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHBhcmVudFJlY3QubGVmdCAtIGJvZHlSZWN0LmxlZnQgKyBfdGhpcy5vcmlnaW5hbC5tYXJnaW5MZWZ0O1xuXHRcdCAgICAgICAgICAgICAgICBkeW5Qcm9wcyA9IHsgbGVmdDogbGVmdCArICdweCcgfTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ3BhcmVudFJlY3QuLi4uLi4uLi4uLi4uLicsIHBhcmVudFJlY3Qud2lkdGgpO1xuXHRcdCAgICAgICAgICAgICAgICBkeW5Qcm9wcyA9IHsgd2lkdGg6IHBhcmVudFJlY3Qud2lkdGggKyAncHgnIH07XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2R5blByb3BzJywgZHluUHJvcHMpO1xuXHRcdCAgICAgICAgICAgIGlmIChfdGhpcy5vcmlnaW5hbC5tYXJnaW5Ub3AgKyBfdGhpcy5vcmlnaW5hbC5tYXJnaW5Cb3R0b20gK1xuXHRcdCAgICAgICAgICAgICAgICBfdGhpcy5vcmlnaW5hbC5ib3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0ICsgX3RoaXMuc3RpY2t5T2Zmc2V0VG9wID49IHBhcmVudFJlY3QuYm90dG9tKSB7XG5cdFx0ICAgICAgICAgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICAgICAgICAgKiBzdGlrY3kgZWxlbWVudCByZWFjaGVkIHRvIHRoZSBib3R0b20gb2YgdGhlIGNvbnRhaW5lclxuXHRcdCAgICAgICAgICAgICAgICAgKi9cblx0XHQgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2Nhc2UgMSAoYWJzb2x1dGUpJywgcGFyZW50UmVjdC5ib3R0b20sIHRoaXMub3JpZ2luYWwubWFyZ2luQm90dG9tKTtcblx0XHQgICAgICAgICAgICAgICAgdmFyIGZsb2F0QWRqdXN0bWVudCA9IF90aGlzLm9yaWdpbmFsLmZsb2F0ID09PSAncmlnaHQnID8geyByaWdodDogMCB9IDpcblx0XHQgICAgICAgICAgICAgICAgICAgIF90aGlzLm9yaWdpbmFsLmZsb2F0ID09PSAnbGVmdCcgPyB7IGxlZnQ6IDAgfSA6IHt9O1xuXHRcdCAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLmVsLnN0eWxlLCB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHQgICAgICAgICAgICAgICAgICAgIGZsb2F0OiAnbm9uZScsXG5cdFx0ICAgICAgICAgICAgICAgICAgICB0b3A6ICdpbmhlcml0Jyxcblx0XHQgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogMFxuXHRcdCAgICAgICAgICAgICAgICB9LCBkeW5Qcm9wcywgZmxvYXRBZGp1c3RtZW50KTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50UmVjdC50b3AgKiAtMSArIF90aGlzLm9yaWdpbmFsLm1hcmdpblRvcCArIF90aGlzLnN0aWNreU9mZnNldFRvcCA+IF90aGlzLm9yaWdpbmFsLm9mZnNldFRvcCkge1xuXHRcdCAgICAgICAgICAgICAgICAvKipcblx0XHQgICAgICAgICAgICAgICAgICogc3Rpa2N5IGVsZW1lbnQgaXMgaW4gdGhlIG1pZGRsZSBvZiBjb250YWluZXJcblx0XHQgICAgICAgICAgICAgICAgICovXG5cdFx0ICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2Nhc2UgMiAoZml4ZWQpJywgcGFyZW50UmVjdC50b3AgKiAtMSwgdGhpcy5vcmlnaW5hbC5tYXJnaW5Ub3AsIHRoaXMub3JpZ2luYWwub2Zmc2V0VG9wKTtcblx0XHQgICAgICAgICAgICAgICAgLy8gaWYgbm90IGZsb2F0aW5nLCBhZGQgYW4gZW1wdHkgZmlsbGVyIGVsZW1lbnQsIHNpbmNlIHRoZSBvcmlnaW5hbCBlbGVtZW50cyBiZWNhbWVzICdmaXhlZCdcblx0XHQgICAgICAgICAgICAgICAgaWYgKF90aGlzLm9yaWdpbmFsLmZsb2F0ICE9PSAnbGVmdCcgJiYgX3RoaXMub3JpZ2luYWwuZmxvYXQgIT09ICdyaWdodCcgJiYgIV90aGlzLmZpbGxlckVsKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5maWxsZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlsbGVyRWwuc3R5bGUuaGVpZ2h0ID0gX3RoaXMuZWwub2Zmc2V0SGVpZ2h0ICsgJ3B4Jztcblx0XHQgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcmVudEVsLmluc2VydEJlZm9yZShfdGhpcy5maWxsZXJFbCwgX3RoaXMuZWwpO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oX3RoaXMuZWwuc3R5bGUsIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgZmxvYXQ6ICdub25lJyxcblx0XHQgICAgICAgICAgICAgICAgICAgIHRvcDogX3RoaXMuc3RpY2t5T2Zmc2V0VG9wICsgJ3B4Jyxcblx0XHQgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJ2luaGVyaXQnXG5cdFx0ICAgICAgICAgICAgICAgIH0sIGR5blByb3BzKTtcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgZWxzZSB7XG5cdFx0ICAgICAgICAgICAgICAgIC8qKlxuXHRcdCAgICAgICAgICAgICAgICAgKiBzdGlrY3kgZWxlbWVudCBpcyBpbiB0aGUgb3JpZ2luYWwgcG9zaXRpb25cblx0XHQgICAgICAgICAgICAgICAgICovXG5cdFx0ICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYXNlIDMgKG9yaWdpbmFsKScpO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZmlsbGVyRWwpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcmVudEVsLnJlbW92ZUNoaWxkKF90aGlzLmZpbGxlckVsKTsgLy9JRTExIGRvZXMgbm90IHdvcmsgd2l0aCBlbC5yZW1vdmUoKVxuXHRcdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmlsbGVyRWwgPSB1bmRlZmluZWQ7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihfdGhpcy5lbC5zdHlsZSwge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IF90aGlzLm9yaWdpbmFsLnBvc2l0aW9uLFxuXHRcdCAgICAgICAgICAgICAgICAgICAgZmxvYXQ6IF90aGlzLm9yaWdpbmFsLmZsb2F0LFxuXHRcdCAgICAgICAgICAgICAgICAgICAgdG9wOiBfdGhpcy5vcmlnaW5hbC50b3AsXG5cdFx0ICAgICAgICAgICAgICAgICAgICBib3R0b206IF90aGlzLm9yaWdpbmFsLmJvdHRvbSxcblx0XHQgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfdGhpcy5vcmlnaW5hbC53aWR0aCxcblx0XHQgICAgICAgICAgICAgICAgICAgIGxlZnQ6IF90aGlzLm9yaWdpbmFsLmxlZnRcblx0XHQgICAgICAgICAgICAgICAgfSwgZHluUHJvcHMpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICB0aGlzLmVsID0gdGhpcy5lbCA9IGVsLm5hdGl2ZUVsZW1lbnQ7XG5cdFx0ICAgICAgICB0aGlzLnBhcmVudEVsID0gdGhpcy5lbC5wYXJlbnRFbGVtZW50O1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlN0aWNreURpcmVjdGl2ZS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgdGhpcy5lbC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG5cdFx0ICAgICAgICBpZiAodGhpcy5zdGlja3lBZnRlcikge1xuXHRcdCAgICAgICAgICAgIHZhciBjZXRTdGlja3lBZnRlckVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLnN0aWNreUFmdGVyKTtcblx0XHQgICAgICAgICAgICBpZiAoY2V0U3RpY2t5QWZ0ZXJFbCkge1xuXHRcdCAgICAgICAgICAgICAgICB0aGlzLnN0aWNreU9mZnNldFRvcCA9IGNldFN0aWNreUFmdGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIHNldCB0aGUgcGFyZW50IHJlbGF0aXZlbHkgcG9zaXRpb25lZFxuXHRcdCAgICAgICAgdmFyIGFsbG93ZWRQb3NpdGlvbnMgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJywgJ3JlbGF0aXZlJ107XG5cdFx0ICAgICAgICB2YXIgcGFyZW50RWxQb3NpdGlvbiA9IG5nMl91dGlsc18xLmNvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnRFbCwgJ3Bvc2l0aW9uJyk7XG5cdFx0ICAgICAgICBpZiAoYWxsb3dlZFBvc2l0aW9ucy5pbmRleE9mKHBhcmVudEVsUG9zaXRpb24pID09PSAtMSkge1xuXHRcdCAgICAgICAgICAgIHRoaXMucGFyZW50RWwuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdGhpcy5kaWZmID0ge1xuXHRcdCAgICAgICAgICAgIHRvcDogdGhpcy5lbC5vZmZzZXRUb3AgLSB0aGlzLnBhcmVudEVsLm9mZnNldFRvcCxcblx0XHQgICAgICAgICAgICBsZWZ0OiB0aGlzLmVsLm9mZnNldExlZnQgLSB0aGlzLnBhcmVudEVsLm9mZnNldExlZnRcblx0XHQgICAgICAgIH07XG5cdFx0ICAgICAgICB2YXIgZWxSZWN0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHQgICAgICAgIHRoaXMub3JpZ2luYWwgPSB7XG5cdFx0ICAgICAgICAgICAgYm91bmRpbmdDbGllbnRSZWN0OiBlbFJlY3QsXG5cdFx0ICAgICAgICAgICAgcG9zaXRpb246IG5nMl91dGlsc18xLmNvbXB1dGVkU3R5bGUodGhpcy5lbCwgJ3Bvc2l0aW9uJyksXG5cdFx0ICAgICAgICAgICAgZmxvYXQ6IG5nMl91dGlsc18xLmNvbXB1dGVkU3R5bGUodGhpcy5lbCwgJ2Zsb2F0JyksXG5cdFx0ICAgICAgICAgICAgdG9wOiBuZzJfdXRpbHNfMS5jb21wdXRlZFN0eWxlKHRoaXMuZWwsICd0b3AnKSxcblx0XHQgICAgICAgICAgICBib3R0b206IG5nMl91dGlsc18xLmNvbXB1dGVkU3R5bGUodGhpcy5lbCwgJ2JvdHRvbScpLFxuXHRcdCAgICAgICAgICAgIGxlZnQ6IG5nMl91dGlsc18xLmNvbXB1dGVkU3R5bGUodGhpcy5lbCwgJ2xlZnQnKSxcblx0XHQgICAgICAgICAgICB3aWR0aDogbmcyX3V0aWxzXzEuY29tcHV0ZWRTdHlsZSh0aGlzLmVsLCAnd2lkdGgnKSxcblx0XHQgICAgICAgICAgICBvZmZzZXRUb3A6IHRoaXMuZWwub2Zmc2V0VG9wLFxuXHRcdCAgICAgICAgICAgIG9mZnNldExlZnQ6IHRoaXMuZWwub2Zmc2V0TGVmdCxcblx0XHQgICAgICAgICAgICBtYXJnaW5Ub3A6IHBhcnNlSW50KG5nMl91dGlsc18xLmNvbXB1dGVkU3R5bGUodGhpcy5lbCwgJ21hcmdpblRvcCcpKSxcblx0XHQgICAgICAgICAgICBtYXJnaW5Cb3R0b206IHBhcnNlSW50KG5nMl91dGlsc18xLmNvbXB1dGVkU3R5bGUodGhpcy5lbCwgJ21hcmdpbkJvdHRvbScpKSxcblx0XHQgICAgICAgICAgICBtYXJnaW5MZWZ0OiBwYXJzZUludChuZzJfdXRpbHNfMS5jb21wdXRlZFN0eWxlKHRoaXMuZWwsICdtYXJnaW5MZWZ0JykpLFxuXHRcdCAgICAgICAgICAgIG1hcmdpblJpZ2h0OiBwYXJzZUludChuZzJfdXRpbHNfMS5jb21wdXRlZFN0eWxlKHRoaXMuZWwsICdtYXJnaW5MZWZ0JykpXG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgdGhpcy5hdHRhY2goKTtcblx0XHQgICAgfTtcblx0XHQgICAgTmcyU3RpY2t5RGlyZWN0aXZlLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5zY3JvbGxIYW5kbGVyKTtcblx0XHQgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJTdGlja3lEaXJlY3RpdmUucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuXHRcdCAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG5cdFx0ICAgIH07XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLklucHV0KCdzdGlja3ktYWZ0ZXInKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgTmcyU3RpY2t5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdGlja3lBZnRlclwiLCB2b2lkIDApO1xuXHRcdCAgICBOZzJTdGlja3lEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5EaXJlY3RpdmUoe1xuXHRcdCAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nMi1zdGlja3ldJ1xuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLkVsZW1lbnRSZWZdKVxuXHRcdCAgICBdLCBOZzJTdGlja3lEaXJlY3RpdmUpO1xuXHRcdCAgICByZXR1cm4gTmcyU3RpY2t5RGlyZWN0aXZlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJTdGlja3lEaXJlY3RpdmUgPSBOZzJTdGlja3lEaXJlY3RpdmU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRcdGlmKHRydWUpXG5cdFx0XHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcblx0XHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiXSwgZmFjdG9yeSk7XG5cdFx0XHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRcdFx0ZXhwb3J0c1tcIm5nMi11dGlsc1wiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIikpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyb290W1wibmcyLXV0aWxzXCJdID0gZmFjdG9yeShyb290W1wiQGFuZ3VsYXIvY29yZVwiXSk7XG5cdFx0fSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX18pIHtcblx0XHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHRcdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHRcdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0XHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0XHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdFx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0XHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHRcdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHRcdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdFx0LyoqKioqKi8gXHRcdH07XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdFx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0XHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0XHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHRcdC8qKioqKiovIFx0fVxuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdFx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHRcdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0XHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHRcdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdFx0LyoqKioqKi8gfSlcblx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRcdC8qKioqKiovIChbXG5cdFx0LyogMCAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHRcdH07XG5cdFx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0XHR2YXIgc2Nyb2xsX3RvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdFx0ZXhwb3J0cy5zY3JvbGxUbyA9IHNjcm9sbF90b18xLnNjcm9sbFRvO1xuXHRcdFx0dmFyIGVsZW1lbnRfdmlzaWJsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHRcdGV4cG9ydHMuZWxlbWVudFZpc2libGUgPSBlbGVtZW50X3Zpc2libGVfMS5lbGVtZW50VmlzaWJsZTtcblx0XHRcdHZhciBjb21wdXRlZF9zdHlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XHRcdGV4cG9ydHMuY29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkX3N0eWxlXzEuY29tcHV0ZWRTdHlsZTtcblx0XHRcdHZhciBvdXRlcl93aWR0aF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XHRcdGV4cG9ydHMub3V0ZXJXaWR0aCA9IG91dGVyX3dpZHRoXzEub3V0ZXJXaWR0aDtcblx0XHRcdHZhciBvdXRlcl9oZWlnaHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cdFx0XHRleHBvcnRzLm91dGVySGVpZ2h0ID0gb3V0ZXJfaGVpZ2h0XzEub3V0ZXJIZWlnaHQ7XG5cdFx0XHR2YXIgTmcyVXRpbHNNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgIGZ1bmN0aW9uIE5nMlV0aWxzTW9kdWxlKCkge1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBOZzJVdGlsc01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHRcdFx0ICAgICAgICBjb3JlXzEuTmdNb2R1bGUoe1xuXHRcdFx0ICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG5cdFx0XHQgICAgICAgICAgICAgICAgc2Nyb2xsX3RvXzEuc2Nyb2xsVG8sXG5cdFx0XHQgICAgICAgICAgICAgICAgZWxlbWVudF92aXNpYmxlXzEuZWxlbWVudFZpc2libGUsXG5cdFx0XHQgICAgICAgICAgICAgICAgY29tcHV0ZWRfc3R5bGVfMS5jb21wdXRlZFN0eWxlLFxuXHRcdFx0ICAgICAgICAgICAgICAgIG91dGVyX3dpZHRoXzEub3V0ZXJXaWR0aCxcblx0XHRcdCAgICAgICAgICAgICAgICBvdXRlcl9oZWlnaHRfMS5vdXRlckhlaWdodFxuXHRcdFx0ICAgICAgICAgICAgXSxcblx0XHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtcblx0XHRcdCAgICAgICAgICAgICAgICBzY3JvbGxfdG9fMS5zY3JvbGxUbyxcblx0XHRcdCAgICAgICAgICAgICAgICBlbGVtZW50X3Zpc2libGVfMS5lbGVtZW50VmlzaWJsZSxcblx0XHRcdCAgICAgICAgICAgICAgICBjb21wdXRlZF9zdHlsZV8xLmNvbXB1dGVkU3R5bGUsXG5cdFx0XHQgICAgICAgICAgICAgICAgb3V0ZXJfd2lkdGhfMS5vdXRlcldpZHRoLFxuXHRcdFx0ICAgICAgICAgICAgICAgIG91dGVyX2hlaWdodF8xLm91dGVySGVpZ2h0XG5cdFx0XHQgICAgICAgICAgICBdXG5cdFx0XHQgICAgICAgIH0pLCBcblx0XHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0XHRcdCAgICBdLCBOZzJVdGlsc01vZHVsZSk7XG5cdFx0XHQgICAgcmV0dXJuIE5nMlV0aWxzTW9kdWxlO1xuXHRcdFx0fSgpKTtcblx0XHRcdGV4cG9ydHMuTmcyVXRpbHNNb2R1bGUgPSBOZzJVdGlsc01vZHVsZTtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDEgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8xX187XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiAyICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdC8qKlxuXHRcdFx0ICogc2Nyb2xsIHRvIHRoZSBzZWxlY3RvciB3aXRoaW4gdGhlIHBhcmVudCBzZWxlY3RvciBieSBzY3JvbGxpbmcgMTAgdGltZXMgd2l0aGluIDUwMG1zXG5cdFx0XHQgKiBAcGFyYW0gc2VsZWN0b3Jcblx0XHRcdCAqIEBwYXJhbSBwYXJlbnRTZWxlY3RvclxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBzY3JvbGxUbyhzZWxlY3RvciwgcGFyZW50U2VsZWN0b3IpIHtcblx0XHRcdCAgICBjb25zb2xlLmxvZygnc2VsZWN0b3InLCBzZWxlY3RvciwgJ3BhcmVudFNlbGVjdG9yJywgcGFyZW50U2VsZWN0b3IpO1xuXHRcdFx0ICAgIHZhciBwYXJlbnRFbCwgdGFyZ2V0RWw7XG5cdFx0XHQgICAgdGFyZ2V0RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcblx0XHRcdCAgICBpZiAoIXRhcmdldEVsKSB7XG5cdFx0XHQgICAgICAgIHRocm93IFwiSW52YWxpZCBzZWxlY3RvciBcIiArIHNlbGVjdG9yO1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBwYXJlbnRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyZW50U2VsZWN0b3IpO1xuXHRcdFx0ICAgIGlmICghcGFyZW50RWwpIHtcblx0XHRcdCAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHBhcmVudCBzZWxlY3RvciBcIiArIHBhcmVudFNlbGVjdG9yO1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICB2YXIgcGFyZW50RWxTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudEVsKTtcblx0XHRcdCAgICBwYXJlbnRFbCA9IHBhcmVudEVsU3R5bGVbJ292ZXJmbG93J10gPT09ICdhdXRvJyA/IHBhcmVudEVsIDogZG9jdW1lbnQuYm9keTtcblx0XHRcdCAgICB2YXIgY3VycmVudFNjcm9sbFRvcCA9IHBhcmVudEVsLnNjcm9sbFRvcDtcblx0XHRcdCAgICB2YXIgdGFyZ2V0T2Zmc2V0VG9wID0gdGFyZ2V0RWwub2Zmc2V0VG9wO1xuXHRcdFx0ICAgIGlmIChwYXJlbnRFbCA9PT0gZG9jdW1lbnQuYm9keSkge1xuXHRcdFx0ICAgICAgICB2YXIgYm9keVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ICAgICAgICB2YXIgdGFyZ2V0UmVjdCA9IHRhcmdldEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ICAgICAgICB0YXJnZXRPZmZzZXRUb3AgPSB0YXJnZXRSZWN0LnRvcCAtIGJvZHlSZWN0LnRvcDtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgdmFyIHN0ZXAgPSBNYXRoLmNlaWwoKHRhcmdldE9mZnNldFRvcCAtIGN1cnJlbnRTY3JvbGxUb3ApIC8gMTApO1xuXHRcdFx0ICAgIChmdW5jdGlvbiBsb29wKGkpIHtcblx0XHRcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiBtYWluKCkge1xuXHRcdFx0ICAgICAgICAgICAgcGFyZW50RWwuc2Nyb2xsVG9wICs9IHN0ZXA7XG5cdFx0XHQgICAgICAgICAgICBpID4gMSAmJiBsb29wKGkgLSAxKTtcblx0XHRcdCAgICAgICAgfSwgNTApO1xuXHRcdFx0ICAgIH0oMTApKTtcblx0XHRcdH1cblx0XHRcdGV4cG9ydHMuc2Nyb2xsVG8gPSBzY3JvbGxUbztcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDMgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIGFuIGVsZW1lbnQgaXMgdmlzaWJsZSB3aXRoaW4gb3V0ZXIgZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIGlubmVyRWxcblx0XHRcdCAqIEBwYXJhbSBvdXRlckVsXG5cdFx0XHQgKiBAcGFyYW0gYWRqdXN0bWVudFxuXHRcdFx0ICogQHJldHVybnMge3t0b3A6IGJvb2xlYW4sIGJvdHRvbTogYm9vbGVhbiwgbGVmdDogYm9vbGVhbiwgcmlnaHQ6IGJvb2xlYW59fVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBlbGVtZW50VmlzaWJsZShpbm5lckVsLCBvdXRlckVsLCBhZGp1c3RtZW50KSB7XG5cdFx0XHQgICAgdmFyIGlubmVyUmVjdCA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHQgICAgdmFyIGJvdHRvbUFkanVzdG1lbnQgPSAoYWRqdXN0bWVudCAmJiBhZGp1c3RtZW50LmJvdHRvbSB8fCAwKTtcblx0XHRcdCAgICBpZiAob3V0ZXJFbCA9PT0gd2luZG93KSB7XG5cdFx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0XHQgICAgICAgICAgICB0b3A6IGlubmVyUmVjdC5ib3R0b20gLSBib3R0b21BZGp1c3RtZW50ID4gd2luZG93LmlubmVySGVpZ2h0XG5cdFx0XHQgICAgICAgICAgICAgICAgJiYgaW5uZXJSZWN0LnRvcCA8IHdpbmRvdy5pbm5lckhlaWdodCxcblx0XHRcdCAgICAgICAgICAgIGJvdHRvbTogaW5uZXJSZWN0LmJvdHRvbSAtIGJvdHRvbUFkanVzdG1lbnQgPiAwXG5cdFx0XHQgICAgICAgICAgICAgICAgJiYgaW5uZXJSZWN0LmJvdHRvbSA8IHdpbmRvdy5pbm5lckhlaWdodCxcblx0XHRcdCAgICAgICAgICAgIGxlZnQ6IGlubmVyUmVjdC5yaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoXG5cdFx0XHQgICAgICAgICAgICAgICAgJiYgaW5uZXJSZWN0LmxlZnQgPCB3aW5kb3cuaW5uZXJXaWR0aCxcblx0XHRcdCAgICAgICAgICAgIHJpZ2h0OiBpbm5lclJlY3QucmlnaHQgPiAwXG5cdFx0XHQgICAgICAgICAgICAgICAgJiYgaW5uZXJSZWN0LnJpZ2h0IDwgd2luZG93LmlubmVyV2lkdGhcblx0XHRcdCAgICAgICAgfTtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgZWxzZSB7XG5cdFx0XHQgICAgICAgIHZhciBvdXRlclJlY3QgPSBvdXRlckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ICAgICAgICB2YXIgZGVmYXVsdFZpZXcgPSAoaW5uZXJFbC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KS5kZWZhdWx0Vmlldztcblx0XHRcdCAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG91dGVyRWwsIG51bGwpO1xuXHRcdFx0ICAgICAgICB2YXIgb3V0ZXJSZWN0Qm9yZGVyVG9wV2lkdGggPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSwgMTApO1xuXHRcdFx0ICAgICAgICB2YXIgb3V0ZXJSZWN0Qm9yZGVyTGVmdFdpZHRoID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItbGVmdC13aWR0aCcpLCAxMCk7XG5cdFx0XHQgICAgICAgIC8qIHRvcCBpcyB2aXNpYmxlIG9yIGJvdHRvbSBpcyB2aXNpYmxlICovXG5cdFx0XHQgICAgICAgIHZhciB0b3BWaXNpYmxlID0gKGlubmVyUmVjdC50b3AgPj0gb3V0ZXJSZWN0LnRvcFxuXHRcdFx0ICAgICAgICAgICAgJiYgaW5uZXJSZWN0LnRvcCA8IG91dGVyUmVjdC5ib3R0b20pO1xuXHRcdFx0ICAgICAgICB2YXIgYm90dG9tVmlzaWJsZSA9IChpbm5lclJlY3QuYm90dG9tID4gKG91dGVyUmVjdC50b3AgKyBvdXRlclJlY3RCb3JkZXJUb3BXaWR0aClcblx0XHRcdCAgICAgICAgICAgICYmIGlubmVyUmVjdC5ib3R0b20gPCBvdXRlclJlY3QuYm90dG9tKTtcblx0XHRcdCAgICAgICAgdmFyIGxlZnRWaXNpYmxlID0gKGlubmVyUmVjdC5sZWZ0ID49IG91dGVyUmVjdC5sZWZ0XG5cdFx0XHQgICAgICAgICAgICAmJiBpbm5lclJlY3QubGVmdCA8IG91dGVyUmVjdC5yaWdodCk7XG5cdFx0XHQgICAgICAgIHZhciByaWdodFZpc2libGUgPSAoaW5uZXJSZWN0LnJpZ2h0ID4gKG91dGVyUmVjdC5sZWZ0ICsgb3V0ZXJSZWN0Qm9yZGVyTGVmdFdpZHRoKVxuXHRcdFx0ICAgICAgICAgICAgJiYgaW5uZXJSZWN0LnJpZ2h0IDwgb3V0ZXJSZWN0LnJpZ2h0KTtcblx0XHRcdCAgICAgICAgcmV0dXJuIHtcblx0XHRcdCAgICAgICAgICAgIHRvcDogdG9wVmlzaWJsZSxcblx0XHRcdCAgICAgICAgICAgIGJvdHRvbTogYm90dG9tVmlzaWJsZSxcblx0XHRcdCAgICAgICAgICAgIGxlZnQ6IGxlZnRWaXNpYmxlLFxuXHRcdFx0ICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0VmlzaWJsZVxuXHRcdFx0ICAgICAgICB9O1xuXHRcdFx0ICAgIH1cblx0XHRcdH1cblx0XHRcdGV4cG9ydHMuZWxlbWVudFZpc2libGUgPSBlbGVtZW50VmlzaWJsZTtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDQgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0LyoqXG5cdFx0XHQgKiByZXR1cm5zIGNvdW1wdXRlZCBzdHlsZSBvZiBnaXZlbiBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0gZWxcblx0XHRcdCAqIEBwYXJhbSBzdHlsZVByb3Bcblx0XHRcdCAqIEByZXR1cm5zIHthbnl9XG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIGNvbXB1dGVkU3R5bGUoZWwsIHN0eWxlUHJvcCkge1xuXHRcdFx0ICAgIHZhciB2YWx1ZSwgZGVmYXVsdFZpZXcgPSAoZWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkuZGVmYXVsdFZpZXc7XG5cdFx0XHQgICAgLy8gVzNDIHN0YW5kYXJkIHdheTpcblx0XHRcdCAgICBpZiAoZGVmYXVsdFZpZXcgJiYgZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuXHRcdFx0ICAgICAgICAvLyBzYW5pdGl6ZSBwcm9wZXJ0eSBuYW1lIHRvIGNzcyBub3RhdGlvblxuXHRcdFx0ICAgICAgICAvLyAoaHlwZW4gc2VwYXJhdGVkIHdvcmRzIGVnLiBmb250LVNpemUpXG5cdFx0XHQgICAgICAgIHN0eWxlUHJvcCA9IHN0eWxlUHJvcC5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHQgICAgICAgIHJldHVybiBkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcCk7XG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIGVsc2UgaWYgKGVsWydjdXJyZW50U3R5bGUnXSkge1xuXHRcdFx0ICAgICAgICAvLyBzYW5pdGl6ZSBwcm9wZXJ0eSBuYW1lIHRvIGNhbWVsQ2FzZVxuXHRcdFx0ICAgICAgICBzdHlsZVByb3AgPSBzdHlsZVByb3AucmVwbGFjZSgvXFwtKFxcdykvZywgZnVuY3Rpb24gKHN0ciwgbGV0dGVyKSB7XG5cdFx0XHQgICAgICAgICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHQgICAgICAgIH0pO1xuXHRcdFx0ICAgICAgICB2YWx1ZSA9IGVsWydjdXJyZW50U3R5bGUnXVtzdHlsZVByb3BdO1xuXHRcdFx0ICAgICAgICAvLyBjb252ZXJ0IG90aGVyIHVuaXRzIHRvIHBpeGVscyBvbiBJRVxuXHRcdFx0ICAgICAgICBpZiAoL15cXGQrKGVtfHB0fCV8ZXgpPyQvaS50ZXN0KHZhbHVlKSkge1xuXHRcdFx0ICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdCAgICAgICAgICAgICAgICB2YXIgb2xkTGVmdCA9IGVsLnN0eWxlLmxlZnQsIG9sZFJzTGVmdCA9IGVsWydydW50aW1lU3R5bGUnXS5sZWZ0O1xuXHRcdFx0ICAgICAgICAgICAgICAgIGVsWydydW50aW1lU3R5bGUnXS5sZWZ0ID0gZWxbJ2N1cnJlbnRTdHlsZSddLmxlZnQ7XG5cdFx0XHQgICAgICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IHZhbHVlIHx8IDA7XG5cdFx0XHQgICAgICAgICAgICAgICAgdmFsdWUgPSBlbC5zdHlsZVsncGl4ZWxMZWZ0J10gKyBcInB4XCI7XG5cdFx0XHQgICAgICAgICAgICAgICAgZWwuc3R5bGUubGVmdCA9IG9sZExlZnQ7XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxbJ3J1bnRpbWVTdHlsZSddLmxlZnQgPSBvbGRSc0xlZnQ7XG5cdFx0XHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHRcdFx0ICAgICAgICAgICAgfSkodmFsdWUpO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0XHRcdCAgICB9XG5cdFx0XHR9XG5cdFx0XHRleHBvcnRzLmNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZFN0eWxlO1xuXHRcdFxuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogNSAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHRmdW5jdGlvbiBvdXRlcldpZHRoKGVsKSB7XG5cdFx0XHQgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cdFx0XHQgICAgcmV0dXJuIGVsLm9mZnNldFdpZHRoICtcblx0XHRcdCAgICAgICAgcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSkgK1xuXHRcdFx0ICAgICAgICBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tcmlnaHQnKSk7XG5cdFx0XHR9XG5cdFx0XHRleHBvcnRzLm91dGVyV2lkdGggPSBvdXRlcldpZHRoO1xuXHRcdFxuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogNiAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHRmdW5jdGlvbiBvdXRlckhlaWdodChlbCkge1xuXHRcdFx0ICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuXHRcdFx0ICAgIHJldHVybiBlbC5vZmZzZXRIZWlnaHQgK1xuXHRcdFx0ICAgICAgICBwYXJzZUludChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tdG9wJykpICtcblx0XHRcdCAgICAgICAgcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWJvdHRvbScpKTtcblx0XHRcdH1cblx0XHRcdGV4cG9ydHMub3V0ZXJIZWlnaHQgPSBvdXRlckhlaWdodDtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9XG5cdFx0LyoqKioqKi8gXSlcblx0XHR9KTtcblx0XHQ7XG5cdFx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLXV0aWxzLnVtZC5qcy5tYXBcblx0XG5cdC8qKiovIH1cblx0LyoqKioqKi8gXSlcblx0fSk7XG5cdDtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLXN0aWNreS51bWQuanMubWFwXG5cbi8qKiovIH0sXG4vKiAxOCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRpZih0cnVlKVxuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMSksIF9fd2VicGFja19yZXF1aXJlX18oMiksIF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0ZGVmaW5lKFtcIkBhbmd1bGFyL2NvcmVcIiwgXCJAYW5ndWxhci9mb3Jtc1wiLCBcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0sIGZhY3RvcnkpO1xuXHRcdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdFx0ZXhwb3J0c1tcIm5nMi10YWJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvZm9ybXNcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCIpKTtcblx0XHRlbHNlXG5cdFx0XHRyb290W1wibmcyLXRhYlwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9mb3Jtc1wiXSwgcm9vdFtcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0pO1xuXHR9KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fKSB7XG5cdHJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG5cdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0LyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuXHQvKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdC8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG5cdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHQvKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG5cdC8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcblx0LyoqKioqKi8gXHRcdH07XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHQvKioqKioqLyBcdH1cblx0LyoqKioqKi9cblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblx0LyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblx0LyoqKioqKi8gfSlcblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKi8gKFtcblx0LyogMCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBmb3Jtc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XHR2YXIgcGxhdGZvcm1fYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHR2YXIgbmcyX3RhYl9jb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0ZXhwb3J0cy5OZzJUYWJDb21wb25lbnQgPSBuZzJfdGFiX2NvbXBvbmVudF8xLk5nMlRhYkNvbXBvbmVudDtcblx0XHR2YXIgTmcyVGFiTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTmcyVGFiTW9kdWxlKCkge1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlRhYk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHQgICAgICAgICAgICBpbXBvcnRzOiBbcGxhdGZvcm1fYnJvd3Nlcl8xLkJyb3dzZXJNb2R1bGUsIGZvcm1zXzEuRm9ybXNNb2R1bGVdLFxuXHRcdCAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW25nMl90YWJfY29tcG9uZW50XzEuTmcyVGFiQ29tcG9uZW50XSxcblx0XHQgICAgICAgICAgICBleHBvcnRzOiBbbmcyX3RhYl9jb21wb25lbnRfMS5OZzJUYWJDb21wb25lbnRdXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdCAgICBdLCBOZzJUYWJNb2R1bGUpO1xuXHRcdCAgICByZXR1cm4gTmcyVGFiTW9kdWxlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJUYWJNb2R1bGUgPSBOZzJUYWJNb2R1bGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAzICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogNCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBOZzJUYWJDb21wb25lbnQgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJUYWJDb21wb25lbnQodmlld0NvbnRhaW5lcikge1xuXHRcdCAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyID0gdmlld0NvbnRhaW5lcjtcblx0XHQgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleENsYXNzID0gJ3NlbGVjdGVkJztcblx0XHQgICAgICAgIHRoaXMuc2VsZWN0ZWRDb250ZW50c0NsYXNzID0gJ3NlbGVjdGVkJztcblx0XHQgICAgICAgIHRoaXMuZWwgPSB0aGlzLnZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlRhYkNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0XHQgICAgICAgIHRoaXMuaW5kZXhFbHMgPSBbXS5zbGljZS5jYWxsKHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnW2luZGV4XScpKTtcblx0XHQgICAgICAgIHRoaXMuY29udGVudHNFbHMgPSBbXS5zbGljZS5jYWxsKHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnW2NvbnRlbnRzXScpKTtcblx0XHQgICAgICAgIHRoaXMuc2VsZWN0VGFiKHRoaXMuc2VsZWN0ZWRJbmRleCk7XG5cdFx0ICAgICAgICB0aGlzLmluZGV4RWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG5cdFx0ICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdFRhYihlbC5nZXRBdHRyaWJ1dGUoJ2luZGV4JykpO1xuXHRcdCAgICAgICAgICAgIH0pO1xuXHRcdCAgICAgICAgfSk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMlRhYkNvbXBvbmVudC5wcm90b3R5cGUuc2VsZWN0VGFiID0gZnVuY3Rpb24gKGlkKSB7XG5cdFx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdCAgICAgICAgaWQgPSBpZCB8fCB0aGlzLmluZGV4RWxzWzBdLmdldEF0dHJpYnV0ZSgnaW5kZXgnKTtcblx0XHQgICAgICAgIHRoaXMuaW5kZXhFbHMuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblx0XHQgICAgICAgICAgICBfdGhpcy5yZW1vdmVDbGFzcyhlbCwgX3RoaXMuc2VsZWN0ZWRJbmRleENsYXNzKTtcblx0XHQgICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCdpbmRleCcpID09IGlkKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLmFkZENsYXNzKGVsLCBfdGhpcy5zZWxlY3RlZEluZGV4Q2xhc3MpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICAgICAgdGhpcy5jb250ZW50c0Vscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXHRcdCAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0ICAgICAgICAgICAgX3RoaXMucmVtb3ZlQ2xhc3MoZWwsIF90aGlzLnNlbGVjdGVkQ29udGVudHNDbGFzcyk7XG5cdFx0ICAgICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnY29udGVudHMnKSA9PSBpZCkge1xuXHRcdCAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLmFkZENsYXNzKGVsLCBfdGhpcy5zZWxlY3RlZENvbnRlbnRzQ2xhc3MpO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJUYWJDb21wb25lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gKGVsLCBzdHIpIHtcblx0XHQgICAgICAgIHZhciBjbGFzc05hbWVzID0gKGVsLmNsYXNzTmFtZSB8fCAnJykuc3BsaXQoJyAnKTtcblx0XHQgICAgICAgIGNsYXNzTmFtZXMucHVzaChzdHIpO1xuXHRcdCAgICAgICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5qb2luKCcgJyk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMlRhYkNvbXBvbmVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAoZWwsIHN0cikge1xuXHRcdCAgICAgICAgZWwuY2xhc3NOYW1lID0gKGVsLmNsYXNzTmFtZSB8fCAnJykucmVwbGFjZShuZXcgUmVnRXhwKCdbIF0qJyArIHN0ciksICcnKTtcblx0XHQgICAgfTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoJ3NlbGVjdGVkJyksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIE5nMlRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dCgnc2VsZWN0ZWQtaW5kZXgtY2xhc3MnKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHQgICAgXSwgTmcyVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZEluZGV4Q2xhc3NcIiwgdm9pZCAwKTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoJ3NlbGVjdGVkLWNvbnRlbnRzLWNsYXNzJyksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIE5nMlRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRDb250ZW50c0NsYXNzXCIsIHZvaWQgMCk7XG5cdFx0ICAgIE5nMlRhYkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkNvbXBvbmVudCh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICduZzItdGFiLCBbbmcyLXRhYl0nLFxuXHRcdCAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IGNvcmVfMS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuXHRcdCAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcblx0XHQgICAgICAgICAgICBzdHlsZXM6IFtcIlxcbiAgICAudGFicyB7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgIHRvcDogMXB4O1xcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICB9XFxuICAgIC50YWJzIFtpbmRleF0ge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjOTk5O1xcbiAgICAgIHBhZGRpbmc6IDVweCAxMHB4O1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IDJweCAycHggMCAwO1xcbiAgICB9XFxuICAgIC50YWJzIFtpbmRleF0uc2VsZWN0ZWQge1xcbiAgICAgIHBhZGRpbmctdG9wOiAwO1xcbiAgICAgIGJhY2tncm91bmQ6ICNmN2Y3Zjc7XFxuICAgICAgYm9yZGVyLXRvcDogNXB4IHNvbGlkICMwMEJDRDQ7XFxuICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgICB9XFxuICAgIC50YWItY29udGVudHMge1xcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICM5OTk7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgICAgIG1pbi1oZWlnaHQ6IDNlbTtcXG4gICAgfVxcbiAgXCJdLFxuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLlZpZXdDb250YWluZXJSZWZdKVxuXHRcdCAgICBdLCBOZzJUYWJDb21wb25lbnQpO1xuXHRcdCAgICByZXR1cm4gTmcyVGFiQ29tcG9uZW50O1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJUYWJDb21wb25lbnQgPSBOZzJUYWJDb21wb25lbnQ7XG5cdFxuXHRcblx0LyoqKi8gfVxuXHQvKioqKioqLyBdKVxuXHR9KTtcblx0O1xuXHQvLyMgc291cmNlTWFwcGluZ1VSTD1uZzItdGFiLnVtZC5qcy5tYXBcblxuLyoqKi8gfSxcbi8qIDE5ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRcdGlmKHRydWUpXG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiLCBcIkBhbmd1bGFyL2Zvcm1zXCIsIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSwgZmFjdG9yeSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0XHRleHBvcnRzW1wibmcyLXRvb2x0aXAtb3ZlcmxheVwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKSwgcmVxdWlyZShcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIikpO1xuXHRcdGVsc2Vcblx0XHRcdHJvb3RbXCJuZzItdG9vbHRpcC1vdmVybGF5XCJdID0gZmFjdG9yeShyb290W1wiQGFuZ3VsYXIvY29yZVwiXSwgcm9vdFtcIkBhbmd1bGFyL2Zvcm1zXCJdLCByb290W1wiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSk7XG5cdH0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcblx0cmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcblx0LyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG5cdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdC8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0LyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0LyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG5cdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0LyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuXHQvKioqKioqLyBcdFx0fTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHQvKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdC8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdC8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG5cdC8qKioqKiovIFx0fVxuXHQvKioqKioqL1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHQvKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXHQvKioqKioqLyB9KVxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqLyAoW1xuXHQvKiAwICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG5cdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0fTtcblx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdH07XG5cdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0dmFyIGZvcm1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXHRcdHZhciBwbGF0Zm9ybV9icm93c2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcdHZhciBuZzJfdG9vbHRpcF9kaXJlY3RpdmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0ZXhwb3J0cy5OZzJUb29sdGlwRGlyZWN0aXZlID0gbmcyX3Rvb2x0aXBfZGlyZWN0aXZlXzEuTmcyVG9vbHRpcERpcmVjdGl2ZTtcblx0XHR2YXIgbmcyX292ZXJsYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFx0dmFyIE5nMlRvb2x0aXBPdmVybGF5TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcblx0XHQgICAgZnVuY3Rpb24gTmcyVG9vbHRpcE92ZXJsYXlNb2R1bGUoKSB7XG5cdFx0ICAgIH1cblx0XHQgICAgTmcyVG9vbHRpcE92ZXJsYXlNb2R1bGUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5OZ01vZHVsZSh7XG5cdFx0ICAgICAgICAgICAgaW1wb3J0czogW3BsYXRmb3JtX2Jyb3dzZXJfMS5Ccm93c2VyTW9kdWxlLCBmb3Jtc18xLkZvcm1zTW9kdWxlLCBuZzJfb3ZlcmxheV8xLk5nMk92ZXJsYXlNb2R1bGVdLFxuXHRcdCAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW25nMl90b29sdGlwX2RpcmVjdGl2ZV8xLk5nMlRvb2x0aXBEaXJlY3RpdmVdLFxuXHRcdCAgICAgICAgICAgIGV4cG9ydHM6IFtuZzJfdG9vbHRpcF9kaXJlY3RpdmVfMS5OZzJUb29sdGlwRGlyZWN0aXZlXVxuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0XHQgICAgXSwgTmcyVG9vbHRpcE92ZXJsYXlNb2R1bGUpO1xuXHRcdCAgICByZXR1cm4gTmcyVG9vbHRpcE92ZXJsYXlNb2R1bGU7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMlRvb2x0aXBPdmVybGF5TW9kdWxlID0gTmcyVG9vbHRpcE92ZXJsYXlNb2R1bGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAzICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogNCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBuZzJfb3ZlcmxheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblx0XHR2YXIgTmcyVG9vbHRpcERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMlRvb2x0aXBEaXJlY3RpdmUodmlld0NvbnRhaW5lclJlZiwgb3ZlcmxheU1hbmFnZXIpIHtcblx0XHQgICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG5cdFx0ICAgICAgICB0aGlzLm92ZXJsYXlNYW5hZ2VyID0gb3ZlcmxheU1hbmFnZXI7XG5cdFx0ICAgICAgICB0aGlzLmVsID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcblx0XHQgICAgfVxuXHRcdCAgICBOZzJUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICB0aGlzLm92ZXJsYXkgPSB0aGlzLmdldFRvb2x0aXBPdmVybGF5KHRoaXMuZWwsIHRoaXMudG9vbHRpcCk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMlRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLnNob3dUb29sdGlwID0gZnVuY3Rpb24gKCRldmVudCkge1xuXHRcdCAgICAgICAgdGhpcy5vdmVybGF5TWFuYWdlci5vcGVuKHRoaXMub3ZlcmxheSwgJGV2ZW50KTtcblx0XHQgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHQgICAgfTtcblx0XHQgICAgTmcyVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUuaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG5cdFx0ICAgICAgICB0aGlzLm92ZXJsYXlNYW5hZ2VyLmNsb3NlKHRoaXMub3ZlcmxheSk7XG5cdFx0ICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIE5nMlRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLmdldFRvb2x0aXBPdmVybGF5ID0gZnVuY3Rpb24gKGVsLCB0b29sdGlwKSB7XG5cdFx0ICAgICAgICB2YXIgdG9vbHRpcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmcyLXRvb2x0aXAnKTtcblx0XHQgICAgICAgIHRvb2x0aXBFbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdCAgICAgICAgdmFyIGRpdkVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0ICAgICAgICBkaXZFbC5pbm5lckhUTUwgPSBcIlxcbiAgICAgICA8ZGl2IGNsYXNzPSd0b29sdGlwLWNvbnRlbnRzJz5cIiArIHRvb2x0aXAgKyBcIjwvZGl2PlxcbiAgICAgICA8ZGl2IGNsYXNzPSd0b29sdGlwLWRvd24tYXJyb3cnPjwvZGl2PlxcbiAgICBcIjtcblx0XHQgICAgICAgIHRvb2x0aXBFbC5hcHBlbmRDaGlsZChkaXZFbCk7XG5cdFx0ICAgICAgICAvL2VsLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRvb2x0aXBFbCwgZWwubmV4dFNpYmxpbmcpO1xuXHRcdCAgICAgICAgZWwuYXBwZW5kQ2hpbGQodG9vbHRpcEVsKTtcblx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gbmV3IG5nMl9vdmVybGF5XzEuT3ZlcmxheSh0b29sdGlwRWwsIHtcblx0XHQgICAgICAgICAgICBpZDogJ3Rvb2x0aXAtJyArIChlbC5pZCB8fCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwKSksXG5cdFx0ICAgICAgICAgICAgcG9zaXRpb246ICd0b3AgY3Vyc29yIG91dHNpZGUnXG5cdFx0ICAgICAgICB9KTtcblx0XHQgICAgICAgIHRoaXMub3ZlcmxheU1hbmFnZXIucmVnaXN0ZXIob3ZlcmxheSk7XG5cdFx0ICAgICAgICByZXR1cm4gb3ZlcmxheTtcblx0XHQgICAgfTtcblx0XHQgICAgX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoJ25nMi10b29sdGlwJyksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0ICAgIF0sIE5nMlRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgdm9pZCAwKTtcblx0XHQgICAgTmcyVG9vbHRpcERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkRpcmVjdGl2ZSh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmcyLXRvb2x0aXBdJyxcblx0XHQgICAgICAgICAgICBob3N0OiB7XG5cdFx0ICAgICAgICAgICAgICAgICcobW91c2VvdmVyKSc6ICdzaG93VG9vbHRpcCgkZXZlbnQpJyxcblx0XHQgICAgICAgICAgICAgICAgJyhtb3VzZW91dCknOiAnaGlkZVRvb2x0aXAoJGV2ZW50KSdcblx0XHQgICAgICAgICAgICB9XG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjb3JlXzEuVmlld0NvbnRhaW5lclJlZiwgbmcyX292ZXJsYXlfMS5PdmVybGF5TWFuYWdlcl0pXG5cdFx0ICAgIF0sIE5nMlRvb2x0aXBEaXJlY3RpdmUpO1xuXHRcdCAgICByZXR1cm4gTmcyVG9vbHRpcERpcmVjdGl2ZTtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuTmcyVG9vbHRpcERpcmVjdGl2ZSA9IE5nMlRvb2x0aXBEaXJlY3RpdmU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogNSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0KGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHRcdGlmKHRydWUpXG5cdFx0XHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcblx0XHRcdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiLCBcIkBhbmd1bGFyL2Zvcm1zXCIsIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSwgZmFjdG9yeSk7XG5cdFx0XHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRcdFx0ZXhwb3J0c1tcIm5nMi1vdmVybGF5XCJdID0gZmFjdG9yeShyZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKSwgcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiKSk7XG5cdFx0XHRlbHNlXG5cdFx0XHRcdHJvb3RbXCJuZzItb3ZlcmxheVwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9mb3Jtc1wiXSwgcm9vdFtcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0pO1xuXHRcdH0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcblx0XHRyZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuXHRcdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHRcdC8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0XHQvKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0XHQvKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG5cdFx0LyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0XHQvKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuXHRcdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHRcdC8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG5cdFx0LyoqKioqKi8gXHRcdH07XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdFx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0XHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0XHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHRcdC8qKioqKiovIFx0fVxuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5cdFx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuXHRcdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cblx0XHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuXHRcdC8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cdFx0LyoqKioqKi8gfSlcblx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHRcdC8qKioqKiovIChbXG5cdFx0LyogMCAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHRcdH07XG5cdFx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0XHR2YXIgZm9ybXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cdFx0XHR2YXIgcGxhdGZvcm1fYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHRcdHZhciBvdmVybGF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcdFx0ZXhwb3J0cy5PdmVybGF5ID0gb3ZlcmxheV8xLk92ZXJsYXk7XG5cdFx0XHR2YXIgb3ZlcmxheV9tYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcdFx0ZXhwb3J0cy5PdmVybGF5TWFuYWdlciA9IG92ZXJsYXlfbWFuYWdlcl8xLk92ZXJsYXlNYW5hZ2VyO1xuXHRcdFx0dmFyIG92ZXJsYXlfZGlyZWN0aXZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXHRcdFx0ZXhwb3J0cy5PdmVybGF5RGlyZWN0aXZlID0gb3ZlcmxheV9kaXJlY3RpdmVfMS5PdmVybGF5RGlyZWN0aXZlO1xuXHRcdFx0dmFyIE5nMk92ZXJsYXlNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgIGZ1bmN0aW9uIE5nMk92ZXJsYXlNb2R1bGUoKSB7XG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIE5nMk92ZXJsYXlNb2R1bGUgPSBfX2RlY29yYXRlKFtcblx0XHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHRcdCAgICAgICAgICAgIGltcG9ydHM6IFtwbGF0Zm9ybV9icm93c2VyXzEuQnJvd3Nlck1vZHVsZSwgZm9ybXNfMS5Gb3Jtc01vZHVsZV0sXG5cdFx0XHQgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtvdmVybGF5X2RpcmVjdGl2ZV8xLk92ZXJsYXlEaXJlY3RpdmVdLFxuXHRcdFx0ICAgICAgICAgICAgcHJvdmlkZXJzOiBbb3ZlcmxheV9tYW5hZ2VyXzEuT3ZlcmxheU1hbmFnZXJdLFxuXHRcdFx0ICAgICAgICAgICAgZXhwb3J0czogW292ZXJsYXlfZGlyZWN0aXZlXzEuT3ZlcmxheURpcmVjdGl2ZV1cblx0XHRcdCAgICAgICAgfSksIFxuXHRcdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdFx0ICAgIF0sIE5nMk92ZXJsYXlNb2R1bGUpO1xuXHRcdFx0ICAgIHJldHVybiBOZzJPdmVybGF5TW9kdWxlO1xuXHRcdFx0fSgpKTtcblx0XHRcdGV4cG9ydHMuTmcyT3ZlcmxheU1vZHVsZSA9IE5nMk92ZXJsYXlNb2R1bGU7XG5cdFx0XHQ7XG5cdFx0XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiAxICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogMiAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdFxuXHRcdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzJfXztcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDMgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiA0ICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFx0XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdHZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXHRcdFx0dmFyIE92ZXJsYXkgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgIGZ1bmN0aW9uIE92ZXJsYXkoZWwsIG9wdGlvbnMpIHtcblx0XHRcdCAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0XHQgICAgICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuXHRcdFx0ICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG5cdFx0XHQgICAgICAgIGlmICghdGhpcy5pZCkge1xuXHRcdFx0ICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIG92ZXJsYXkgaWRcIjtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbDsgLy8gb3ZlcmxheSB3cmFwcGVyIGVsZW1lbnQgd2l0aCB0YWJsZSBkc3BsYXlcblx0XHRcdCAgICAgICAgdGhpcy53aW5kb3dPdmVybGF5ID0gb3B0aW9ucy53aW5kb3dPdmVybGF5O1xuXHRcdFx0ICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvblByb3BlcnR5KG9wdGlvbnMucG9zaXRpb24gfHwgJ2NlbnRlciBjZW50ZXInKTtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgT3ZlcmxheS5wcm90b3R5cGUucG9zaXRpb25JdCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0ICAgICAgICBpZiAodGhpcy5wb3NpdGlvbi5pbnNpZGUpIHtcblx0XHRcdCAgICAgICAgICAgIHRoaXMucG9zaXRpb25JdEluc2lkZSh0aGlzLnBvc2l0aW9uKTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICBlbHNlIHtcblx0XHRcdCAgICAgICAgICAgIHRoaXMucG9zaXRpb25JdE91dHNpZGUodGhpcy5wb3NpdGlvbiwgZXZlbnQpO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgfTtcblx0XHRcdCAgICBPdmVybGF5LnByb3RvdHlwZS5nZXRQb3NpdGlvblByb3BlcnR5ID0gZnVuY3Rpb24gKHBvc2l0aW9uU3RyKSB7XG5cdFx0XHQgICAgICAgIHZhciBwb3NpdGlvbiA9IHt9LCBpbnNpZGU7XG5cdFx0XHQgICAgICAgIHZhciBfYSA9IHBvc2l0aW9uU3RyLnNwbGl0KCcgJyksIHZlcnRpY2FsID0gX2FbMF0sIGhvcml6b250YWwgPSBfYVsxXSwgaW5zaWRlU3RyID0gX2FbMl07XG5cdFx0XHQgICAgICAgIGhvcml6b250YWwgPSBob3Jpem9udGFsIHx8ICdjZW50ZXInO1xuXHRcdFx0ICAgICAgICB2ZXJ0aWNhbCA9IHZlcnRpY2FsIHx8ICdjZW50ZXInO1xuXHRcdFx0ICAgICAgICBpbnNpZGUgPSAoaW5zaWRlU3RyICE9PSAnb3V0c2lkZScgfHwgdGhpcy53aW5kb3dPdmVybGF5KTtcblx0XHRcdCAgICAgICAgcG9zaXRpb24uaG9yaXpvbnRhbCA9IE92ZXJsYXlbaG9yaXpvbnRhbC50b1VwcGVyQ2FzZSgpXTtcblx0XHRcdCAgICAgICAgcG9zaXRpb24udmVydGljYWwgPSBPdmVybGF5W3ZlcnRpY2FsLnRvVXBwZXJDYXNlKCldO1xuXHRcdFx0ICAgICAgICBwb3NpdGlvbi5pbnNpZGUgPSBpbnNpZGU7XG5cdFx0XHQgICAgICAgIHJldHVybiBwb3NpdGlvbjtcblx0XHRcdCAgICB9O1xuXHRcdFx0ICAgIE92ZXJsYXkucHJvdG90eXBlLnBvc2l0aW9uSXRJbnNpZGUgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcblx0XHRcdCAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG5cdFx0XHQgICAgICAgIC8vdG9wIC8gbGVmdCBwb3NpdGlvbmluZ1xuXHRcdFx0ICAgICAgICBpZiAodGhpcy53aW5kb3dPdmVybGF5KSB7XG5cdFx0XHQgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXHRcdFx0ICAgICAgICAgICAgLy93b3JrcyBhcyBibG9ja2VyXG5cdFx0XHQgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZWxlbWVudC5zdHlsZSwge1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC4yKScsXG5cdFx0XHQgICAgICAgICAgICAgICAgdG9wOiAnMCcsIGxlZnQ6ICcwJywgYm90dG9tOiAnMCcsIHJpZ2h0OiAnMCcsXG5cdFx0XHQgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJSdcblx0XHRcdCAgICAgICAgICAgIH0pO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgICAgIGVsc2Uge1xuXHRcdFx0ICAgICAgICAgICAgLy9hZGp1c3QgdG9wL2xlZnQgdG8gbWF0Y2ggdG8gcGFyZW50RWxlbWVudFxuXHRcdFx0ICAgICAgICAgICAgdmFyIHBhcmVudEVsID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHQgICAgICAgICAgICAvL3dvcmtzIGFzIGEgYmxvY2tlclxuXHRcdFx0ICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdCAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcblx0XHRcdCAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG5cdFx0XHQgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjIpJyxcblx0XHRcdCAgICAgICAgICAgICAgICB0b3A6IHBhcmVudEVsLm9mZnNldFRvcCArICdweCcsXG5cdFx0XHQgICAgICAgICAgICAgICAgbGVmdDogcGFyZW50RWwub2Zmc2V0TGVmdCArICdweCcsXG5cdFx0XHQgICAgICAgICAgICAgICAgd2lkdGg6IHBhcmVudEVsLm9mZnNldFdpZHRoICsgJ3B4Jyxcblx0XHRcdCAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcmVudEVsLm9mZnNldEhlaWdodCArICdweCdcblx0XHRcdCAgICAgICAgICAgIH0pO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgICAgIDtcblx0XHRcdCAgICAgICAgLy9ob3Jpem9udGFsIHBvc2l0aW9uXG5cdFx0XHQgICAgICAgIHN3aXRjaCAocG9zaXRpb24uaG9yaXpvbnRhbCkge1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkxFRlQ6XG5cdFx0XHQgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkNFTlRFUjpcblx0XHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnY2VudGVyJztcblx0XHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5SSUdIVDpcblx0XHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnZmxleC1lbmQnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgICAgIC8vdmVydGljYWwgcG9zaXRpb25cblx0XHRcdCAgICAgICAgc3dpdGNoIChwb3NpdGlvbi52ZXJ0aWNhbCkge1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkxFRlQ6XG5cdFx0XHQgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmFsaWduSXRlbXMgPSAnZmxleC1zdGFydCc7XG5cdFx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuQ0VOVEVSOlxuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5Lk1JRERMRTpcblx0XHRcdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlJJR0hUOlxuXHRcdFx0ICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5hbGlnbkl0ZW1zID0gJ2ZsZXgtZW5kJztcblx0XHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgIH07XG5cdFx0XHQgICAgT3ZlcmxheS5wcm90b3R5cGUucG9zaXRpb25JdE91dHNpZGUgPSBmdW5jdGlvbiAocG9zaXRpb24sIGV2ZW50KSB7XG5cdFx0XHQgICAgICAgIC8vYWRqdXN0IHRvcC9sZWZ0IHRvIG1hdGNoIHRvIHBhcmVudEVsZW1lbnRcblx0XHRcdCAgICAgICAgdmFyIHBhcmVudEVsID0gdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHQgICAgICAgIC8vd29ya3MgYXMgZ3VpZGUgbGluZT9cblx0XHRcdCAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdCAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0ICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuXHRcdFx0ICAgICAgICAgICAgdG9wOiBwYXJlbnRFbC5vZmZzZXRUb3AgKyAncHgnLFxuXHRcdFx0ICAgICAgICAgICAgbGVmdDogcGFyZW50RWwub2Zmc2V0TGVmdCArICdweCcsXG5cdFx0XHQgICAgICAgICAgICB3aWR0aDogcGFyZW50RWwub2Zmc2V0V2lkdGggKyAncHgnLFxuXHRcdFx0ICAgICAgICAgICAgaGVpZ2h0OiBwYXJlbnRFbC5vZmZzZXRIZWlnaHQgKyAncHgnXG5cdFx0XHQgICAgICAgIH0pO1xuXHRcdFx0ICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHQgICAgICAgIHZhciBlbFRvUG9zaXRpb24gPSAodGhpcy5lbGVtZW50LmNoaWxkcmVuWzBdKTtcblx0XHRcdCAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdCAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0byc7XG5cdFx0XHQgICAgICAgIHN3aXRjaCAocG9zaXRpb24udmVydGljYWwpIHtcblx0XHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5UT1A6XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmJvdHRvbSA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQgKyAncHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkJPVFRPTTpcblx0XHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUudG9wID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodCArICdweCc7XG5cdFx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuTEVGVDpcblx0XHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUucmlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGggKyAncHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlJJR0hUOlxuXHRcdFx0ICAgICAgICAgICAgICAgIGVsVG9Qb3NpdGlvbi5zdHlsZS5sZWZ0ID0gdGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoICsgJ3B4Jztcblx0XHRcdCAgICAgICAgICAgICAgICBicmVhaztcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uLmhvcml6b250YWwpIHtcblx0XHRcdCAgICAgICAgICAgIGNhc2UgT3ZlcmxheS5DRU5URVI6XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSAodGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoKSAvIDIgKyAncHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkxFRlQ6XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSAnMCc7XG5cdFx0XHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdFx0XHQgICAgICAgICAgICBjYXNlIE92ZXJsYXkuUklHSFQ6XG5cdFx0XHQgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLnJpZ2h0ID0gJzAnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LlRPUDpcblx0XHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUudG9wID0gJzAnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkJPVFRPTTpcblx0XHRcdCAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUuYm90dG9tID0gJzAnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICAgICAgY2FzZSBPdmVybGF5LkNVUlNPUjpcblx0XHRcdCAgICAgICAgICAgICAgICB2YXIgbW91c2VQb3MgPSB1dGlsXzEuVXRpbC5nZXRNb3VzZVBvc2l0aW9uSW5FbGVtZW50KGV2ZW50LCB0aGlzLmVsZW1lbnQpO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGlmICgobW91c2VQb3MueCArIGVsVG9Qb3NpdGlvbi5vZmZzZXRXaWR0aCkgPiB0aGlzLmVsZW1lbnQub2Zmc2V0V2lkdGgpIHtcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSAodGhpcy5lbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoIC0gNSkgKyAncHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIH1cblx0XHRcdCAgICAgICAgICAgICAgICBlbHNlIGlmIChtb3VzZVBvcy54IDwgZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoIC8gMikge1xuXHRcdFx0ICAgICAgICAgICAgICAgICAgICBlbFRvUG9zaXRpb24uc3R5bGUubGVmdCA9ICcwcHgnO1xuXHRcdFx0ICAgICAgICAgICAgICAgIH1cblx0XHRcdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0XHRcdCAgICAgICAgICAgICAgICAgICAgZWxUb1Bvc2l0aW9uLnN0eWxlLmxlZnQgPSBtb3VzZVBvcy54IC0gZWxUb1Bvc2l0aW9uLm9mZnNldFdpZHRoIC8gMiArICdweCc7XG5cdFx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdFx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgfTtcblx0XHRcdCAgICBPdmVybGF5LlRPUCA9IDExO1xuXHRcdFx0ICAgIE92ZXJsYXkuTUlERExFID0gMTI7XG5cdFx0XHQgICAgT3ZlcmxheS5CT1RUT00gPSAxMztcblx0XHRcdCAgICBPdmVybGF5LkxFRlQgPSAyMTtcblx0XHRcdCAgICBPdmVybGF5LkNFTlRFUiA9IDIyO1xuXHRcdFx0ICAgIE92ZXJsYXkuUklHSFQgPSAyMztcblx0XHRcdCAgICBPdmVybGF5LkNVUlNPUiA9IDMxO1xuXHRcdFx0ICAgIHJldHVybiBPdmVybGF5O1xuXHRcdFx0fSgpKTtcblx0XHRcdGV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXk7XG5cdFx0XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiA1ICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdHZhciBVdGlsID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICBmdW5jdGlvbiBVdGlsKCkge1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBVdGlsLmdldERvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbiAob0VsZW1lbnQpIHtcblx0XHRcdCAgICAgICAgdmFyIHBvc1ggPSAwLCBwb3NZID0gMDtcblx0XHRcdCAgICAgICAgaWYgKG9FbGVtZW50Lm9mZnNldFBhcmVudCkge1xuXHRcdFx0ICAgICAgICAgICAgZm9yICg7IG9FbGVtZW50OyBvRWxlbWVudCA9IG9FbGVtZW50Lm9mZnNldFBhcmVudCkge1xuXHRcdFx0ICAgICAgICAgICAgICAgIHBvc1ggKz0gb0VsZW1lbnQub2Zmc2V0TGVmdDtcblx0XHRcdCAgICAgICAgICAgICAgICBwb3NZICs9IG9FbGVtZW50Lm9mZnNldFRvcDtcblx0XHRcdCAgICAgICAgICAgIH1cblx0XHRcdCAgICAgICAgICAgIHJldHVybiB7IHg6IHBvc1gsIHk6IHBvc1kgfTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICBlbHNlIHtcblx0XHRcdCAgICAgICAgICAgIHJldHVybiB7IHg6IG9FbGVtZW50Wyd4J10sIHk6IG9FbGVtZW50Wyd5J10gfTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgIH07XG5cdFx0XHQgICAgVXRpbC5nZXRNb3VzZVBvc2l0aW9uSW5FbGVtZW50ID0gZnVuY3Rpb24gKGV2dCwgZWxlbWVudCkge1xuXHRcdFx0ICAgICAgICBldnQgPSBldnQgfHwgd2luZG93LmV2ZW50O1xuXHRcdFx0ICAgICAgICB2YXIgcG9zWCA9IDAsIHBvc1kgPSAwO1xuXHRcdFx0ICAgICAgICB2YXIgZWxQb3MgPSB0aGlzLmdldERvY3VtZW50UG9zaXRpb24oZWxlbWVudCk7XG5cdFx0XHQgICAgICAgIGlmIChldnQucGFnZVggfHwgZXZ0LnBhZ2VZKSB7XG5cdFx0XHQgICAgICAgICAgICBwb3NYID0gZXZ0LnBhZ2VYO1xuXHRcdFx0ICAgICAgICAgICAgcG9zWSA9IGV2dC5wYWdlWTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICBlbHNlIGlmIChldnQuY2xpZW50WCB8fCBldnQuY2xpZW50WSkge1xuXHRcdFx0ICAgICAgICAgICAgcG9zWCA9IGV2dC5jbGllbnRYICtcblx0XHRcdCAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgK1xuXHRcdFx0ICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuXHRcdFx0ICAgICAgICAgICAgcG9zWSA9IGV2dC5jbGllbnRZICtcblx0XHRcdCAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArXG5cdFx0XHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdFx0ICAgICAgICAgICAgeDogcG9zWCAtIGVsUG9zLngsXG5cdFx0XHQgICAgICAgICAgICB5OiBwb3NZIC0gZWxQb3MueVxuXHRcdFx0ICAgICAgICB9O1xuXHRcdFx0ICAgIH07XG5cdFx0XHQgICAgcmV0dXJuIFV0aWw7XG5cdFx0XHR9KCkpO1xuXHRcdFx0ZXhwb3J0cy5VdGlsID0gVXRpbDtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDYgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdFx0dmFyIE92ZXJsYXlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICBmdW5jdGlvbiBPdmVybGF5TWFuYWdlcigpIHtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG92ZXJsYXkpIHtcblx0XHRcdCAgICAgICAgT3ZlcmxheU1hbmFnZXIub3ZlcmxheXNbb3ZlcmxheS5pZF0gPSBvdmVybGF5O1xuXHRcdFx0ICAgICAgICAvLyBjb25zb2xlLmxvZygnb3ZlcmxheS5yZWdpc3RlciwgT3ZlcmxheU1hbmFnZXIub3ZlcmxheXMnLCBPdmVybGF5TWFuYWdlci5vdmVybGF5cyk7XG5cdFx0XHQgICAgfTtcblx0XHRcdCAgICBPdmVybGF5TWFuYWdlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChhcmcsIGV2ZW50KSB7XG5cdFx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBPdmVybGF5TWFuYWdlci5vdmVybGF5c1thcmddIDogYXJnO1xuXHRcdFx0ICAgICAgICBpZiAoIW92ZXJsYXkub3BlbmVkKSB7XG5cdFx0XHQgICAgICAgICAgICBvdmVybGF5LnBvc2l0aW9uSXQoZXZlbnQpO1xuXHRcdFx0ICAgICAgICAgICAgb3ZlcmxheS5vcGVuZWQgPSB0cnVlO1xuXHRcdFx0ICAgICAgICB9XG5cdFx0XHQgICAgfTtcblx0XHRcdCAgICBPdmVybGF5TWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoYXJnKSB7XG5cdFx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgPyBPdmVybGF5TWFuYWdlci5vdmVybGF5c1thcmddIDogYXJnO1xuXHRcdFx0ICAgICAgICBvdmVybGF5LmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdCAgICAgICAgb3ZlcmxheS5vcGVuZWQgPSBmYWxzZTtcblx0XHRcdCAgICB9O1xuXHRcdFx0ICAgIC8vbGlzdCBvZiBvdmVybGF5IG9iamVjdHNcblx0XHRcdCAgICBPdmVybGF5TWFuYWdlci5vdmVybGF5cyA9IHt9O1xuXHRcdFx0ICAgIE92ZXJsYXlNYW5hZ2VyID0gX19kZWNvcmF0ZShbXG5cdFx0XHQgICAgICAgIGNvcmVfMS5JbmplY3RhYmxlKCksIFxuXHRcdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuXHRcdFx0ICAgIF0sIE92ZXJsYXlNYW5hZ2VyKTtcblx0XHRcdCAgICByZXR1cm4gT3ZlcmxheU1hbmFnZXI7XG5cdFx0XHR9KCkpO1xuXHRcdFx0ZXhwb3J0cy5PdmVybGF5TWFuYWdlciA9IE92ZXJsYXlNYW5hZ2VyO1xuXHRcdFxuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogNyAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHR2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG5cdFx0XHQgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdFx0ICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG5cdFx0XHQgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcblx0XHRcdH07XG5cdFx0XHR2YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcblx0XHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIGNvcmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cdFx0XHR2YXIgb3ZlcmxheV9tYW5hZ2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcdFx0dmFyIG92ZXJsYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0XHR2YXIgT3ZlcmxheURpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHQgICAgZnVuY3Rpb24gT3ZlcmxheURpcmVjdGl2ZSh2aWV3Q29udGFpbmVyUmVmLCBvdmVybGF5TWFuYWdlcikge1xuXHRcdFx0ICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuXHRcdFx0ICAgICAgICB0aGlzLm92ZXJsYXlNYW5hZ2VyID0gb3ZlcmxheU1hbmFnZXI7XG5cdFx0XHQgICAgICAgIHRoaXMuZWwgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHQgICAgICAgIHRoaXMud3JhcEl0V2l0aE92ZXJsYXlUYWcoKTtcblx0XHRcdCAgICAgICAgdGhpcy5yZWdpc3RlclRvT3ZlcmxheU1hbmFnZXIoKTtcblx0XHRcdCAgICB9O1xuXHRcdFx0ICAgIE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLndyYXBJdFdpdGhPdmVybGF5VGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ICAgICAgICAvL2NvbnNvbGUubG9nKCd3cmFwcGVkIG92ZXJsYXkgZGlyZWN0aXZlIGVsZW1lbnQgd2l0aCA8bmcyLW92ZXJsYXk+Jyk7XG5cdFx0XHQgICAgICAgIHRoaXMub3ZlcmxheUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmcyLW92ZXJsYXknKTtcblx0XHRcdCAgICAgICAgdGhpcy5vdmVybGF5RWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdCAgICAgICAgdGhpcy5lbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLm92ZXJsYXlFbCwgdGhpcy5lbC5uZXh0U2libGluZyk7XG5cdFx0XHQgICAgICAgIHRoaXMub3ZlcmxheUVsLmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuXHRcdFx0ICAgIH07XG5cdFx0XHQgICAgLy9jcmVhdGUgT3ZlcmxheSBvYmplY3QsICB0aGVuIHJlZ2lzdGVyIHRoaXMgZWxlbWVudCB0byBvdmVybGF5TWFuYWdlclxuXHRcdFx0ICAgIE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLnJlZ2lzdGVyVG9PdmVybGF5TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICAgICAgdmFyIHBvc2l0aW9uU3RyID0gdGhpcy5vdmVybGF5UG9zaXRpb247XG5cdFx0XHQgICAgICAgIHZhciBvdmVybGF5ID0gbmV3IG92ZXJsYXlfMS5PdmVybGF5KHRoaXMub3ZlcmxheUVsLCB7XG5cdFx0XHQgICAgICAgICAgICBpZDogdGhpcy5lbC5pZCxcblx0XHRcdCAgICAgICAgICAgIHdpbmRvd092ZXJsYXk6IHRoaXMub3ZlcmxheU9mID09IFwid2luZG93XCIsXG5cdFx0XHQgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25TdHJcblx0XHRcdCAgICAgICAgfSk7XG5cdFx0XHQgICAgICAgIC8vY29uc29sZS5sb2coJ3JlZ2lzdGVyaW5nIG92ZXJsYXknLCBvdmVybGF5KTtcblx0XHRcdCAgICAgICAgdGhpcy5vdmVybGF5TWFuYWdlci5yZWdpc3RlcihvdmVybGF5KTtcblx0XHRcdCAgICB9O1xuXHRcdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdFx0ICAgICAgICBjb3JlXzEuSW5wdXQoJ25nMi1vdmVybGF5LW9mJyksIFxuXHRcdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIFN0cmluZylcblx0XHRcdCAgICBdLCBPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvdmVybGF5T2ZcIiwgdm9pZCAwKTtcblx0XHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHRcdCAgICAgICAgY29yZV8xLklucHV0KCduZzItb3ZlcmxheS1wb3NpdGlvbicpLCBcblx0XHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG5cdFx0XHQgICAgXSwgT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwib3ZlcmxheVBvc2l0aW9uXCIsIHZvaWQgMCk7XG5cdFx0XHQgICAgT3ZlcmxheURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuXHRcdFx0ICAgICAgICBjb3JlXzEuRGlyZWN0aXZlKHtcblx0XHRcdCAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nMi1vdmVybGF5XSwgW25nMi1vdmVybGF5LW9mXSwgW25nMi1vdmVybGF5LXBvc2l0aW9uXScsXG5cdFx0XHQgICAgICAgIH0pLCBcblx0XHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLlZpZXdDb250YWluZXJSZWYsIG92ZXJsYXlfbWFuYWdlcl8xLk92ZXJsYXlNYW5hZ2VyXSlcblx0XHRcdCAgICBdLCBPdmVybGF5RGlyZWN0aXZlKTtcblx0XHRcdCAgICByZXR1cm4gT3ZlcmxheURpcmVjdGl2ZTtcblx0XHRcdH0oKSk7XG5cdFx0XHRleHBvcnRzLk92ZXJsYXlEaXJlY3RpdmUgPSBPdmVybGF5RGlyZWN0aXZlO1xuXHRcdFxuXHRcdFxuXHRcdC8qKiovIH1cblx0XHQvKioqKioqLyBdKVxuXHRcdH0pO1xuXHRcdDtcblx0XHQvLyMgc291cmNlTWFwcGluZ1VSTD1uZzItb3ZlcmxheS51bWQuanMubWFwXG5cdFxuXHQvKioqLyB9XG5cdC8qKioqKiovIF0pXG5cdH0pO1xuXHQ7XG5cdC8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nMi10b29sdGlwLW92ZXJsYXkudW1kLmpzLm1hcFxuXG4vKioqLyB9LFxuLyogMjAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdChmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdFx0aWYodHJ1ZSlcblx0XHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcblx0XHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRcdGRlZmluZShbXCJAYW5ndWxhci9jb3JlXCIsIFwiQGFuZ3VsYXIvZm9ybXNcIiwgXCJAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyXCJdLCBmYWN0b3J5KTtcblx0XHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRcdGV4cG9ydHNbXCJuZzItc2Nyb2xsYWJsZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcIkBhbmd1bGFyL2NvcmVcIiksIHJlcXVpcmUoXCJAYW5ndWxhci9mb3Jtc1wiKSwgcmVxdWlyZShcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIikpO1xuXHRcdGVsc2Vcblx0XHRcdHJvb3RbXCJuZzItc2Nyb2xsYWJsZVwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9mb3Jtc1wiXSwgcm9vdFtcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0pO1xuXHR9KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fKSB7XG5cdHJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG5cdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0LyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuXHQvKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdC8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG5cdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHQvKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG5cdC8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcblx0LyoqKioqKi8gXHRcdH07XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHQvKioqKioqLyBcdH1cblx0LyoqKioqKi9cblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblx0LyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblx0LyoqKioqKi8gfSlcblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKi8gKFtcblx0LyogMCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBmb3Jtc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XHR2YXIgcGxhdGZvcm1fYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHR2YXIgbmcyX3Njcm9sbGFibGVfZGlyZWN0aXZlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcdGV4cG9ydHMuTmcyU2Nyb2xsYWJsZURpcmVjdGl2ZSA9IG5nMl9zY3JvbGxhYmxlX2RpcmVjdGl2ZV8xLk5nMlNjcm9sbGFibGVEaXJlY3RpdmU7XG5cdFx0dmFyIE5nMlNjcm9sbGFibGVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJTY3JvbGxhYmxlTW9kdWxlKCkge1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlNjcm9sbGFibGVNb2R1bGUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5OZ01vZHVsZSh7XG5cdFx0ICAgICAgICAgICAgaW1wb3J0czogW3BsYXRmb3JtX2Jyb3dzZXJfMS5Ccm93c2VyTW9kdWxlLCBmb3Jtc18xLkZvcm1zTW9kdWxlXSxcblx0XHQgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtuZzJfc2Nyb2xsYWJsZV9kaXJlY3RpdmVfMS5OZzJTY3JvbGxhYmxlRGlyZWN0aXZlXSxcblx0XHQgICAgICAgICAgICBleHBvcnRzOiBbbmcyX3Njcm9sbGFibGVfZGlyZWN0aXZlXzEuTmcyU2Nyb2xsYWJsZURpcmVjdGl2ZV1cblx0XHQgICAgICAgIH0pLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG5cdFx0ICAgIF0sIE5nMlNjcm9sbGFibGVNb2R1bGUpO1xuXHRcdCAgICByZXR1cm4gTmcyU2Nyb2xsYWJsZU1vZHVsZTtcblx0XHR9KCkpO1xuXHRcdGV4cG9ydHMuTmcyU2Nyb2xsYWJsZU1vZHVsZSA9IE5nMlNjcm9sbGFibGVNb2R1bGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAzICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogNCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBuZzJfdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFx0dmFyIE5nMlNjcm9sbGFibGVEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuXHRcdCAgICBmdW5jdGlvbiBOZzJTY3JvbGxhYmxlRGlyZWN0aXZlKGVsKSB7XG5cdFx0ICAgICAgICB0aGlzLmVsZW1lbnRWaXNpYmxlID0gbmV3IGNvcmVfMS5FdmVudEVtaXR0ZXIoKTtcblx0XHQgICAgICAgIHRoaXMuc2VjdGlvbnMgPSBbXTtcblx0XHQgICAgICAgIHRoaXMudmlzaWJsZSA9IG5nMl91dGlsc18xLmVsZW1lbnRWaXNpYmxlO1xuXHRcdCAgICAgICAgdGhpcy5lbCA9IGVsLm5hdGl2ZUVsZW1lbnQ7XG5cdFx0ICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcblx0XHQgICAgfVxuXHRcdCAgICAvLyBzZXR1cCBsaXN0IG9mIHNlY3Rpb25zXG5cdFx0ICAgIE5nMlNjcm9sbGFibGVEaXJlY3RpdmUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuXHRcdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVsLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0ICAgICAgICAgICAgdmFyIGNoaWxkRWwgPSB0aGlzLmVsLmNoaWxkcmVuW2ldO1xuXHRcdCAgICAgICAgICAgIGNoaWxkRWwuaWQgJiYgdGhpcy5zZWN0aW9ucy5wdXNoKGNoaWxkRWwpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgdmFyIHRoaXNFbFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5lbCk7XG5cdFx0ICAgICAgICB2YXIgZWxUb0xpc3RlblNjcm9sbCA9IHRoaXNFbFN0eWxlLm92ZXJmbG93ID09PSAnYXV0bycgPyB0aGlzLmVsIDogd2luZG93O1xuXHRcdCAgICAgICAgdGhpcy5saXN0ZW5TY3JvbGxPbihlbFRvTGlzdGVuU2Nyb2xsKTtcblx0XHQgICAgfTtcblx0XHQgICAgTmcyU2Nyb2xsYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUubGlzdGVuU2Nyb2xsT24gPSBmdW5jdGlvbiAoZWwpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG5cdFx0ICAgICAgICAgICAgdmFyIGVsU2Nyb2xsZWRUb1Zpc2libGUgPSBudWxsO1xuXHRcdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMuc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcblx0XHQgICAgICAgICAgICAgICAgdmFyIHNlY3Rpb24gPSBfdGhpcy5zZWN0aW9uc1tpXTtcblx0XHQgICAgICAgICAgICAgICAgdmFyIHZpc2libGUgPSBfdGhpcy52aXNpYmxlKHNlY3Rpb24sIGVsKTtcblx0XHQgICAgICAgICAgICAgICAgaWYgKF90aGlzLmhvcml6b250YWwgJiYgKHZpc2libGUubGVmdCB8fCB2aXNpYmxlLnJpZ2h0KSkge1xuXHRcdCAgICAgICAgICAgICAgICAgICAgZWxTY3JvbGxlZFRvVmlzaWJsZSA9IHNlY3Rpb247XG5cdFx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0XHQgICAgICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgICAgICBlbHNlIGlmICghX3RoaXMuaG9yaXpvbnRhbCAmJiAodmlzaWJsZS50b3AgfHwgdmlzaWJsZS5ib3R0b20pKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBlbFNjcm9sbGVkVG9WaXNpYmxlID0gc2VjdGlvbjtcblx0XHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgICAgIGVsU2Nyb2xsZWRUb1Zpc2libGUgJiYgX3RoaXMuZWxlbWVudFZpc2libGUuZW1pdChlbFNjcm9sbGVkVG9WaXNpYmxlKTtcblx0XHQgICAgICAgIH0pO1xuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJTY3JvbGxhYmxlRGlyZWN0aXZlLnNjcm9sbFRvID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBwYXJlbnRTZWxlY3RvciwgaG9yaXpvbnRhbCwgZGlzdGFuY2UpIHtcblx0XHQgICAgICAgIC8vIGFyZ3VtZW50IHZhbGlkYXRpb25cblx0XHQgICAgICAgIHZhciBwYXJlbnRFbCwgdGFyZ2V0RWw7XG5cdFx0ICAgICAgICBwYXJlbnRTZWxlY3RvciA9IHBhcmVudFNlbGVjdG9yIHx8ICdib2R5Jztcblx0XHQgICAgICAgIHRhcmdldEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdFx0ICAgICAgICBpZiAoIXRhcmdldEVsKSB7XG5cdFx0ICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHNlbGVjdG9yIFwiICsgc2VsZWN0b3I7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBwYXJlbnRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyZW50U2VsZWN0b3IpO1xuXHRcdCAgICAgICAgaWYgKCFwYXJlbnRFbCkge1xuXHRcdCAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCBwYXJlbnQgc2VsZWN0b3IgXCIgKyBwYXJlbnRTZWxlY3Rvcjtcblx0XHQgICAgICAgIH1cblx0XHQgICAgICAgIC8vIGRldGVjdCB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuXHRcdCAgICAgICAgdmFyIHBhcmVudEVsU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRFbCk7XG5cdFx0ICAgICAgICB2YXIgc2Nyb2xsQ29udGFpbmVyRWwgPSBwYXJlbnRFbFN0eWxlLm92ZXJmbG93ID09PSAnYXV0bycgP1xuXHRcdCAgICAgICAgICAgIHBhcmVudEVsIDogZG9jdW1lbnQuYm9keTtcblx0XHQgICAgICAgIHZhciBjdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsQ29udGFpbmVyRWwuc2Nyb2xsVG9wO1xuXHRcdCAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGxMZWZ0ID0gc2Nyb2xsQ29udGFpbmVyRWwuc2Nyb2xsTGVmdDtcblx0XHQgICAgICAgIC8vIGRldGVybWluZSB0YXJnZXRPZmZzZXRUb3Aob3IgTGVmdCk7XG5cdFx0ICAgICAgICB2YXIgdGFyZ2V0T2Zmc2V0VG9wO1xuXHRcdCAgICAgICAgdmFyIHRhcmdldE9mZnNldExlZnQ7XG5cdFx0ICAgICAgICBpZiAoc2Nyb2xsQ29udGFpbmVyRWwgPT09IGRvY3VtZW50LmJvZHkpIHtcblx0XHQgICAgICAgICAgICB2YXIgYm9keVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdCAgICAgICAgICAgIHZhciB0YXJnZXRSZWN0ID0gdGFyZ2V0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0ICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0VG9wID0gdGFyZ2V0UmVjdC50b3AgLSBib2R5UmVjdC50b3A7XG5cdFx0ICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0TGVmdCA9IHRhcmdldFJlY3QubGVmdCAtIGJvZHlSZWN0LmxlZnQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBlbHNlIHtcblx0XHQgICAgICAgICAgICB0YXJnZXRPZmZzZXRUb3AgPSB0YXJnZXRFbC5vZmZzZXRUb3A7XG5cdFx0ICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0TGVmdCA9IHRhcmdldEVsLm9mZnNldExlZnQ7XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgICBpZiAoZGlzdGFuY2UpIHtcblx0XHQgICAgICAgICAgICBjdXJyZW50U2Nyb2xsVG9wICs9IGRpc3RhbmNlO1xuXHRcdCAgICAgICAgICAgIGN1cnJlbnRTY3JvbGxMZWZ0ICs9IGRpc3RhbmNlO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICAgICAgLy8gc3RhcnQgc2Nyb2xsaW5nXG5cdFx0ICAgICAgICB2YXIgc3RlcCA9IGhvcml6b250YWwgP1xuXHRcdCAgICAgICAgICAgIE1hdGguY2VpbCgodGFyZ2V0T2Zmc2V0TGVmdCAtIGN1cnJlbnRTY3JvbGxMZWZ0KSAvIDEwKSA6XG5cdFx0ICAgICAgICAgICAgTWF0aC5jZWlsKCh0YXJnZXRPZmZzZXRUb3AgLSBjdXJyZW50U2Nyb2xsVG9wKSAvIDEwKTtcblx0XHQgICAgICAgIHZhciBzY3JvbGxQcm9wID0gaG9yaXpvbnRhbCA/ICdzY3JvbGxMZWZ0JyA6ICdzY3JvbGxUb3AnO1xuXHRcdCAgICAgICAgKGZ1bmN0aW9uIGxvb3AoaSwgcHJvcCkge1xuXHRcdCAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gbWFpbigpIHtcblx0XHQgICAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyRWxbcHJvcF0gKz0gc3RlcDtcblx0XHQgICAgICAgICAgICAgICAgaSA+IDEgJiYgbG9vcChpIC0gMSwgcHJvcCk7XG5cdFx0ICAgICAgICAgICAgfSwgNTApO1xuXHRcdCAgICAgICAgfSgxMCwgc2Nyb2xsUHJvcCkpO1xuXHRcdCAgICB9O1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5JbnB1dCgpLCBcblx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcblx0XHQgICAgXSwgTmcyU2Nyb2xsYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbFwiLCB2b2lkIDApO1xuXHRcdCAgICBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5PdXRwdXQoKSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246dHlwZScsIE9iamVjdClcblx0XHQgICAgXSwgTmcyU2Nyb2xsYWJsZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZWxlbWVudFZpc2libGVcIiwgdm9pZCAwKTtcblx0XHQgICAgTmcyU2Nyb2xsYWJsZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgY29yZV8xLkRpcmVjdGl2ZSh7XG5cdFx0ICAgICAgICAgICAgc2VsZWN0b3I6ICdbbmcyLXNjcm9sbGFibGVdJ1xuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbY29yZV8xLkVsZW1lbnRSZWZdKVxuXHRcdCAgICBdLCBOZzJTY3JvbGxhYmxlRGlyZWN0aXZlKTtcblx0XHQgICAgcmV0dXJuIE5nMlNjcm9sbGFibGVEaXJlY3RpdmU7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMlNjcm9sbGFibGVEaXJlY3RpdmUgPSBOZzJTY3JvbGxhYmxlRGlyZWN0aXZlO1xuXHRcblx0XG5cdC8qKiovIH0sXG5cdC8qIDUgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdFxuXHRcdChmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdFx0XHRpZih0cnVlKVxuXHRcdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG5cdFx0XHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRcdFx0ZGVmaW5lKFtcIkBhbmd1bGFyL2NvcmVcIl0sIGZhY3RvcnkpO1xuXHRcdFx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0XHRcdGV4cG9ydHNbXCJuZzItdXRpbHNcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJAYW5ndWxhci9jb3JlXCIpKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cm9vdFtcIm5nMi11dGlsc1wiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0pO1xuXHRcdH0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fKSB7XG5cdFx0cmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcblx0XHQvKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcblx0XHQvKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5cdFx0LyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdFx0LyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuXHRcdC8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdFx0LyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcblx0XHQvKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcblx0XHQvKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG5cdFx0LyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuXHRcdC8qKioqKiovIFx0XHR9O1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRcdC8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdFx0LyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdFx0LyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcblx0XHQvKioqKioqLyBcdH1cblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXHRcdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblx0XHQvKioqKioqL1xuXHRcdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblx0XHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdFx0LyoqKioqKi9cblx0XHQvKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG5cdFx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXHRcdC8qKioqKiovXG5cdFx0LyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblx0XHQvKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXHRcdC8qKioqKiovIH0pXG5cdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0XHQvKioqKioqLyAoW1xuXHRcdC8qIDAgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdFx0ICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG5cdFx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcblx0XHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdFx0ICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG5cdFx0XHR9O1xuXHRcdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0XHQgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xuXHRcdFx0fTtcblx0XHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdFx0dmFyIHNjcm9sbF90b18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XHRcdGV4cG9ydHMuc2Nyb2xsVG8gPSBzY3JvbGxfdG9fMS5zY3JvbGxUbztcblx0XHRcdHZhciBlbGVtZW50X3Zpc2libGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cdFx0XHRleHBvcnRzLmVsZW1lbnRWaXNpYmxlID0gZWxlbWVudF92aXNpYmxlXzEuZWxlbWVudFZpc2libGU7XG5cdFx0XHR2YXIgY29tcHV0ZWRfc3R5bGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cdFx0XHRleHBvcnRzLmNvbXB1dGVkU3R5bGUgPSBjb21wdXRlZF9zdHlsZV8xLmNvbXB1dGVkU3R5bGU7XG5cdFx0XHR2YXIgb3V0ZXJfd2lkdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFx0XHRleHBvcnRzLm91dGVyV2lkdGggPSBvdXRlcl93aWR0aF8xLm91dGVyV2lkdGg7XG5cdFx0XHR2YXIgb3V0ZXJfaGVpZ2h0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcdFx0ZXhwb3J0cy5vdXRlckhlaWdodCA9IG91dGVyX2hlaWdodF8xLm91dGVySGVpZ2h0O1xuXHRcdFx0dmFyIE5nMlV0aWxzTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgICBmdW5jdGlvbiBOZzJVdGlsc01vZHVsZSgpIHtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgTmcyVXRpbHNNb2R1bGUgPSBfX2RlY29yYXRlKFtcblx0XHRcdCAgICAgICAgY29yZV8xLk5nTW9kdWxlKHtcblx0XHRcdCAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuXHRcdFx0ICAgICAgICAgICAgICAgIHNjcm9sbF90b18xLnNjcm9sbFRvLFxuXHRcdFx0ICAgICAgICAgICAgICAgIGVsZW1lbnRfdmlzaWJsZV8xLmVsZW1lbnRWaXNpYmxlLFxuXHRcdFx0ICAgICAgICAgICAgICAgIGNvbXB1dGVkX3N0eWxlXzEuY29tcHV0ZWRTdHlsZSxcblx0XHRcdCAgICAgICAgICAgICAgICBvdXRlcl93aWR0aF8xLm91dGVyV2lkdGgsXG5cdFx0XHQgICAgICAgICAgICAgICAgb3V0ZXJfaGVpZ2h0XzEub3V0ZXJIZWlnaHRcblx0XHRcdCAgICAgICAgICAgIF0sXG5cdFx0XHQgICAgICAgICAgICBleHBvcnRzOiBbXG5cdFx0XHQgICAgICAgICAgICAgICAgc2Nyb2xsX3RvXzEuc2Nyb2xsVG8sXG5cdFx0XHQgICAgICAgICAgICAgICAgZWxlbWVudF92aXNpYmxlXzEuZWxlbWVudFZpc2libGUsXG5cdFx0XHQgICAgICAgICAgICAgICAgY29tcHV0ZWRfc3R5bGVfMS5jb21wdXRlZFN0eWxlLFxuXHRcdFx0ICAgICAgICAgICAgICAgIG91dGVyX3dpZHRoXzEub3V0ZXJXaWR0aCxcblx0XHRcdCAgICAgICAgICAgICAgICBvdXRlcl9oZWlnaHRfMS5vdXRlckhlaWdodFxuXHRcdFx0ICAgICAgICAgICAgXVxuXHRcdFx0ICAgICAgICB9KSwgXG5cdFx0XHQgICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG5cdFx0XHQgICAgXSwgTmcyVXRpbHNNb2R1bGUpO1xuXHRcdFx0ICAgIHJldHVybiBOZzJVdGlsc01vZHVsZTtcblx0XHRcdH0oKSk7XG5cdFx0XHRleHBvcnRzLk5nMlV0aWxzTW9kdWxlID0gTmcyVXRpbHNNb2R1bGU7XG5cdFx0XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiAxICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMV9fO1xuXHRcdFxuXHRcdC8qKiovIH0sXG5cdFx0LyogMiAqL1xuXHRcdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcdFxuXHRcdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0XHQvKipcblx0XHRcdCAqIHNjcm9sbCB0byB0aGUgc2VsZWN0b3Igd2l0aGluIHRoZSBwYXJlbnQgc2VsZWN0b3IgYnkgc2Nyb2xsaW5nIDEwIHRpbWVzIHdpdGhpbiA1MDBtc1xuXHRcdFx0ICogQHBhcmFtIHNlbGVjdG9yXG5cdFx0XHQgKiBAcGFyYW0gcGFyZW50U2VsZWN0b3Jcblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gc2Nyb2xsVG8oc2VsZWN0b3IsIHBhcmVudFNlbGVjdG9yKSB7XG5cdFx0XHQgICAgY29uc29sZS5sb2coJ3NlbGVjdG9yJywgc2VsZWN0b3IsICdwYXJlbnRTZWxlY3RvcicsIHBhcmVudFNlbGVjdG9yKTtcblx0XHRcdCAgICB2YXIgcGFyZW50RWwsIHRhcmdldEVsO1xuXHRcdFx0ICAgIHRhcmdldEVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdFx0XHQgICAgaWYgKCF0YXJnZXRFbCkge1xuXHRcdFx0ICAgICAgICB0aHJvdyBcIkludmFsaWQgc2VsZWN0b3IgXCIgKyBzZWxlY3Rvcjtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgcGFyZW50RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcmVudFNlbGVjdG9yKTtcblx0XHRcdCAgICBpZiAoIXBhcmVudEVsKSB7XG5cdFx0XHQgICAgICAgIHRocm93IFwiSW52YWxpZCBwYXJlbnQgc2VsZWN0b3IgXCIgKyBwYXJlbnRTZWxlY3Rvcjtcblx0XHRcdCAgICB9XG5cdFx0XHQgICAgdmFyIHBhcmVudEVsU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnRFbCk7XG5cdFx0XHQgICAgcGFyZW50RWwgPSBwYXJlbnRFbFN0eWxlWydvdmVyZmxvdyddID09PSAnYXV0bycgPyBwYXJlbnRFbCA6IGRvY3VtZW50LmJvZHk7XG5cdFx0XHQgICAgdmFyIGN1cnJlbnRTY3JvbGxUb3AgPSBwYXJlbnRFbC5zY3JvbGxUb3A7XG5cdFx0XHQgICAgdmFyIHRhcmdldE9mZnNldFRvcCA9IHRhcmdldEVsLm9mZnNldFRvcDtcblx0XHRcdCAgICBpZiAocGFyZW50RWwgPT09IGRvY3VtZW50LmJvZHkpIHtcblx0XHRcdCAgICAgICAgdmFyIGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdCAgICAgICAgdmFyIHRhcmdldFJlY3QgPSB0YXJnZXRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdCAgICAgICAgdGFyZ2V0T2Zmc2V0VG9wID0gdGFyZ2V0UmVjdC50b3AgLSBib2R5UmVjdC50b3A7XG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIHZhciBzdGVwID0gTWF0aC5jZWlsKCh0YXJnZXRPZmZzZXRUb3AgLSBjdXJyZW50U2Nyb2xsVG9wKSAvIDEwKTtcblx0XHRcdCAgICAoZnVuY3Rpb24gbG9vcChpKSB7XG5cdFx0XHQgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gbWFpbigpIHtcblx0XHRcdCAgICAgICAgICAgIHBhcmVudEVsLnNjcm9sbFRvcCArPSBzdGVwO1xuXHRcdFx0ICAgICAgICAgICAgaSA+IDEgJiYgbG9vcChpIC0gMSk7XG5cdFx0XHQgICAgICAgIH0sIDUwKTtcblx0XHRcdCAgICB9KDEwKSk7XG5cdFx0XHR9XG5cdFx0XHRleHBvcnRzLnNjcm9sbFRvID0gc2Nyb2xsVG87XG5cdFx0XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiAzICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyBhbiBlbGVtZW50IGlzIHZpc2libGUgd2l0aGluIG91dGVyIGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSBpbm5lckVsXG5cdFx0XHQgKiBAcGFyYW0gb3V0ZXJFbFxuXHRcdFx0ICogQHBhcmFtIGFkanVzdG1lbnRcblx0XHRcdCAqIEByZXR1cm5zIHt7dG9wOiBib29sZWFuLCBib3R0b206IGJvb2xlYW4sIGxlZnQ6IGJvb2xlYW4sIHJpZ2h0OiBib29sZWFufX1cblx0XHRcdCAqL1xuXHRcdFx0ZnVuY3Rpb24gZWxlbWVudFZpc2libGUoaW5uZXJFbCwgb3V0ZXJFbCwgYWRqdXN0bWVudCkge1xuXHRcdFx0ICAgIHZhciBpbm5lclJlY3QgPSBpbm5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0ICAgIHZhciBib3R0b21BZGp1c3RtZW50ID0gKGFkanVzdG1lbnQgJiYgYWRqdXN0bWVudC5ib3R0b20gfHwgMCk7XG5cdFx0XHQgICAgaWYgKG91dGVyRWwgPT09IHdpbmRvdykge1xuXHRcdFx0ICAgICAgICByZXR1cm4ge1xuXHRcdFx0ICAgICAgICAgICAgdG9wOiBpbm5lclJlY3QuYm90dG9tIC0gYm90dG9tQWRqdXN0bWVudCA+IHdpbmRvdy5pbm5lckhlaWdodFxuXHRcdFx0ICAgICAgICAgICAgICAgICYmIGlubmVyUmVjdC50b3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQsXG5cdFx0XHQgICAgICAgICAgICBib3R0b206IGlubmVyUmVjdC5ib3R0b20gLSBib3R0b21BZGp1c3RtZW50ID4gMFxuXHRcdFx0ICAgICAgICAgICAgICAgICYmIGlubmVyUmVjdC5ib3R0b20gPCB3aW5kb3cuaW5uZXJIZWlnaHQsXG5cdFx0XHQgICAgICAgICAgICBsZWZ0OiBpbm5lclJlY3QucmlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aFxuXHRcdFx0ICAgICAgICAgICAgICAgICYmIGlubmVyUmVjdC5sZWZ0IDwgd2luZG93LmlubmVyV2lkdGgsXG5cdFx0XHQgICAgICAgICAgICByaWdodDogaW5uZXJSZWN0LnJpZ2h0ID4gMFxuXHRcdFx0ICAgICAgICAgICAgICAgICYmIGlubmVyUmVjdC5yaWdodCA8IHdpbmRvdy5pbm5lcldpZHRoXG5cdFx0XHQgICAgICAgIH07XG5cdFx0XHQgICAgfVxuXHRcdFx0ICAgIGVsc2Uge1xuXHRcdFx0ICAgICAgICB2YXIgb3V0ZXJSZWN0ID0gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdCAgICAgICAgdmFyIGRlZmF1bHRWaWV3ID0gKGlubmVyRWwub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCkuZGVmYXVsdFZpZXc7XG5cdFx0XHQgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShvdXRlckVsLCBudWxsKTtcblx0XHRcdCAgICAgICAgdmFyIG91dGVyUmVjdEJvcmRlclRvcFdpZHRoID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdib3JkZXItdG9wLXdpZHRoJyksIDEwKTtcblx0XHRcdCAgICAgICAgdmFyIG91dGVyUmVjdEJvcmRlckxlZnRXaWR0aCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLWxlZnQtd2lkdGgnKSwgMTApO1xuXHRcdFx0ICAgICAgICAvKiB0b3AgaXMgdmlzaWJsZSBvciBib3R0b20gaXMgdmlzaWJsZSAqL1xuXHRcdFx0ICAgICAgICB2YXIgdG9wVmlzaWJsZSA9IChpbm5lclJlY3QudG9wID49IG91dGVyUmVjdC50b3Bcblx0XHRcdCAgICAgICAgICAgICYmIGlubmVyUmVjdC50b3AgPCBvdXRlclJlY3QuYm90dG9tKTtcblx0XHRcdCAgICAgICAgdmFyIGJvdHRvbVZpc2libGUgPSAoaW5uZXJSZWN0LmJvdHRvbSA+IChvdXRlclJlY3QudG9wICsgb3V0ZXJSZWN0Qm9yZGVyVG9wV2lkdGgpXG5cdFx0XHQgICAgICAgICAgICAmJiBpbm5lclJlY3QuYm90dG9tIDwgb3V0ZXJSZWN0LmJvdHRvbSk7XG5cdFx0XHQgICAgICAgIHZhciBsZWZ0VmlzaWJsZSA9IChpbm5lclJlY3QubGVmdCA+PSBvdXRlclJlY3QubGVmdFxuXHRcdFx0ICAgICAgICAgICAgJiYgaW5uZXJSZWN0LmxlZnQgPCBvdXRlclJlY3QucmlnaHQpO1xuXHRcdFx0ICAgICAgICB2YXIgcmlnaHRWaXNpYmxlID0gKGlubmVyUmVjdC5yaWdodCA+IChvdXRlclJlY3QubGVmdCArIG91dGVyUmVjdEJvcmRlckxlZnRXaWR0aClcblx0XHRcdCAgICAgICAgICAgICYmIGlubmVyUmVjdC5yaWdodCA8IG91dGVyUmVjdC5yaWdodCk7XG5cdFx0XHQgICAgICAgIHJldHVybiB7XG5cdFx0XHQgICAgICAgICAgICB0b3A6IHRvcFZpc2libGUsXG5cdFx0XHQgICAgICAgICAgICBib3R0b206IGJvdHRvbVZpc2libGUsXG5cdFx0XHQgICAgICAgICAgICBsZWZ0OiBsZWZ0VmlzaWJsZSxcblx0XHRcdCAgICAgICAgICAgIHJpZ2h0OiByaWdodFZpc2libGVcblx0XHRcdCAgICAgICAgfTtcblx0XHRcdCAgICB9XG5cdFx0XHR9XG5cdFx0XHRleHBvcnRzLmVsZW1lbnRWaXNpYmxlID0gZWxlbWVudFZpc2libGU7XG5cdFx0XG5cdFx0XG5cdFx0LyoqKi8gfSxcblx0XHQvKiA0ICovXG5cdFx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFx0XG5cdFx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcdC8qKlxuXHRcdFx0ICogcmV0dXJucyBjb3VtcHV0ZWQgc3R5bGUgb2YgZ2l2ZW4gZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIGVsXG5cdFx0XHQgKiBAcGFyYW0gc3R5bGVQcm9wXG5cdFx0XHQgKiBAcmV0dXJucyB7YW55fVxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBjb21wdXRlZFN0eWxlKGVsLCBzdHlsZVByb3ApIHtcblx0XHRcdCAgICB2YXIgdmFsdWUsIGRlZmF1bHRWaWV3ID0gKGVsLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpLmRlZmF1bHRWaWV3O1xuXHRcdFx0ICAgIC8vIFczQyBzdGFuZGFyZCB3YXk6XG5cdFx0XHQgICAgaWYgKGRlZmF1bHRWaWV3ICYmIGRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcblx0XHRcdCAgICAgICAgLy8gc2FuaXRpemUgcHJvcGVydHkgbmFtZSB0byBjc3Mgbm90YXRpb25cblx0XHRcdCAgICAgICAgLy8gKGh5cGVuIHNlcGFyYXRlZCB3b3JkcyBlZy4gZm9udC1TaXplKVxuXHRcdFx0ICAgICAgICBzdHlsZVByb3AgPSBzdHlsZVByb3AucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0ICAgICAgICByZXR1cm4gZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3ApO1xuXHRcdFx0ICAgIH1cblx0XHRcdCAgICBlbHNlIGlmIChlbFsnY3VycmVudFN0eWxlJ10pIHtcblx0XHRcdCAgICAgICAgLy8gc2FuaXRpemUgcHJvcGVydHkgbmFtZSB0byBjYW1lbENhc2Vcblx0XHRcdCAgICAgICAgc3R5bGVQcm9wID0gc3R5bGVQcm9wLnJlcGxhY2UoL1xcLShcXHcpL2csIGZ1bmN0aW9uIChzdHIsIGxldHRlcikge1xuXHRcdFx0ICAgICAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0ICAgICAgICB9KTtcblx0XHRcdCAgICAgICAgdmFsdWUgPSBlbFsnY3VycmVudFN0eWxlJ11bc3R5bGVQcm9wXTtcblx0XHRcdCAgICAgICAgLy8gY29udmVydCBvdGhlciB1bml0cyB0byBwaXhlbHMgb24gSUVcblx0XHRcdCAgICAgICAgaWYgKC9eXFxkKyhlbXxwdHwlfGV4KT8kL2kudGVzdCh2YWx1ZSkpIHtcblx0XHRcdCAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQgICAgICAgICAgICAgICAgdmFyIG9sZExlZnQgPSBlbC5zdHlsZS5sZWZ0LCBvbGRSc0xlZnQgPSBlbFsncnVudGltZVN0eWxlJ10ubGVmdDtcblx0XHRcdCAgICAgICAgICAgICAgICBlbFsncnVudGltZVN0eWxlJ10ubGVmdCA9IGVsWydjdXJyZW50U3R5bGUnXS5sZWZ0O1xuXHRcdFx0ICAgICAgICAgICAgICAgIGVsLnN0eWxlLmxlZnQgPSB2YWx1ZSB8fCAwO1xuXHRcdFx0ICAgICAgICAgICAgICAgIHZhbHVlID0gZWwuc3R5bGVbJ3BpeGVsTGVmdCddICsgXCJweFwiO1xuXHRcdFx0ICAgICAgICAgICAgICAgIGVsLnN0eWxlLmxlZnQgPSBvbGRMZWZ0O1xuXHRcdFx0ICAgICAgICAgICAgICAgIGVsWydydW50aW1lU3R5bGUnXS5sZWZ0ID0gb2xkUnNMZWZ0O1xuXHRcdFx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0XHRcdCAgICAgICAgICAgIH0pKHZhbHVlKTtcblx0XHRcdCAgICAgICAgfVxuXHRcdFx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdFx0XHQgICAgfVxuXHRcdFx0fVxuXHRcdFx0ZXhwb3J0cy5jb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDUgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0ZnVuY3Rpb24gb3V0ZXJXaWR0aChlbCkge1xuXHRcdFx0ICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuXHRcdFx0ICAgIHJldHVybiBlbC5vZmZzZXRXaWR0aCArXG5cdFx0XHQgICAgICAgIHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1sZWZ0JykpICtcblx0XHRcdCAgICAgICAgcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JykpO1xuXHRcdFx0fVxuXHRcdFx0ZXhwb3J0cy5vdXRlcldpZHRoID0gb3V0ZXJXaWR0aDtcblx0XHRcblx0XHRcblx0XHQvKioqLyB9LFxuXHRcdC8qIDYgKi9cblx0XHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHRcblx0XHRcdFwidXNlIHN0cmljdFwiO1xuXHRcdFx0ZnVuY3Rpb24gb3V0ZXJIZWlnaHQoZWwpIHtcblx0XHRcdCAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcblx0XHRcdCAgICByZXR1cm4gZWwub2Zmc2V0SGVpZ2h0ICtcblx0XHRcdCAgICAgICAgcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXRvcCcpKSArXG5cdFx0XHQgICAgICAgIHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1ib3R0b20nKSk7XG5cdFx0XHR9XG5cdFx0XHRleHBvcnRzLm91dGVySGVpZ2h0ID0gb3V0ZXJIZWlnaHQ7XG5cdFx0XG5cdFx0XG5cdFx0LyoqKi8gfVxuXHRcdC8qKioqKiovIF0pXG5cdFx0fSk7XG5cdFx0O1xuXHRcdC8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nMi11dGlscy51bWQuanMubWFwXG5cdFxuXHQvKioqLyB9XG5cdC8qKioqKiovIF0pXG5cdH0pO1xuXHQ7XG5cdC8vIyBzb3VyY2VNYXBwaW5nVVJMPW5nMi1zY3JvbGxhYmxlLnVtZC5qcy5tYXBcblxuLyoqKi8gfSxcbi8qIDIxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRcdGlmKHRydWUpXG5cdFx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0XHRkZWZpbmUoW1wiQGFuZ3VsYXIvY29yZVwiLCBcIkBhbmd1bGFyL2Zvcm1zXCIsIFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiXSwgZmFjdG9yeSk7XG5cdFx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0XHRleHBvcnRzW1wibmcyLXVpLXNvcnRhYmxlXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiQGFuZ3VsYXIvY29yZVwiKSwgcmVxdWlyZShcIkBhbmd1bGFyL2Zvcm1zXCIpLCByZXF1aXJlKFwiQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlclwiKSk7XG5cdFx0ZWxzZVxuXHRcdFx0cm9vdFtcIm5nMi11aS1zb3J0YWJsZVwiXSA9IGZhY3Rvcnkocm9vdFtcIkBhbmd1bGFyL2NvcmVcIl0sIHJvb3RbXCJAYW5ndWxhci9mb3Jtc1wiXSwgcm9vdFtcIkBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXJcIl0pO1xuXHR9KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fKSB7XG5cdHJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG5cdC8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuXHQvKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0LyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuXHQvKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdC8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG5cdC8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuXHQvKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG5cdC8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcblx0LyoqKioqKi8gXHRcdH07XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0LyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHQvKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHQvKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHQvKioqKioqLyBcdH1cblx0LyoqKioqKi9cblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuXHQvKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cdC8qKioqKiovXG5cdC8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcblx0LyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXHQvKioqKioqL1xuXHQvKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG5cdC8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblx0LyoqKioqKi9cblx0LyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcblx0LyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblx0LyoqKioqKi8gfSlcblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKi8gKFtcblx0LyogMCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBmb3Jtc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblx0XHR2YXIgcGxhdGZvcm1fYnJvd3Nlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblx0XHR2YXIgbmcyX3NvcnRhYmxlX2RpcmVjdGl2ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblx0XHRleHBvcnRzLk5nMlNvcnRhYmxlRGlyZWN0aXZlID0gbmcyX3NvcnRhYmxlX2RpcmVjdGl2ZV8xLk5nMlNvcnRhYmxlRGlyZWN0aXZlO1xuXHRcdHZhciBOZzJTb3J0YWJsZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMlNvcnRhYmxlTW9kdWxlKCkge1xuXHRcdCAgICB9XG5cdFx0ICAgIE5nMlNvcnRhYmxlTW9kdWxlID0gX19kZWNvcmF0ZShbXG5cdFx0ICAgICAgICBjb3JlXzEuTmdNb2R1bGUoe1xuXHRcdCAgICAgICAgICAgIGltcG9ydHM6IFtwbGF0Zm9ybV9icm93c2VyXzEuQnJvd3Nlck1vZHVsZSwgZm9ybXNfMS5Gb3Jtc01vZHVsZV0sXG5cdFx0ICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbbmcyX3NvcnRhYmxlX2RpcmVjdGl2ZV8xLk5nMlNvcnRhYmxlRGlyZWN0aXZlXSxcblx0XHQgICAgICAgICAgICBleHBvcnRzOiBbbmcyX3NvcnRhYmxlX2RpcmVjdGl2ZV8xLk5nMlNvcnRhYmxlRGlyZWN0aXZlXVxuXHRcdCAgICAgICAgfSksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcblx0XHQgICAgXSwgTmcyU29ydGFibGVNb2R1bGUpO1xuXHRcdCAgICByZXR1cm4gTmcyU29ydGFibGVNb2R1bGU7XG5cdFx0fSgpKTtcblx0XHRleHBvcnRzLk5nMlNvcnRhYmxlTW9kdWxlID0gTmcyU29ydGFibGVNb2R1bGU7XG5cdFxuXHRcblx0LyoqKi8gfSxcblx0LyogMSAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblx0XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblx0XG5cdC8qKiovIH0sXG5cdC8qIDIgKi9cblx0LyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cdFxuXHRcdG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8yX187XG5cdFxuXHQvKioqLyB9LFxuXHQvKiAzICovXG5cdC8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcblx0XHRtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXHRcblx0LyoqKi8gfSxcblx0LyogNCAqL1xuXHQvKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblx0XG5cdFx0XCJ1c2Ugc3RyaWN0XCI7XG5cdFx0dmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuXHRcdCAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuXHRcdCAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuXHRcdCAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuXHRcdCAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xuXHRcdH07XG5cdFx0dmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG5cdFx0ICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcblx0XHR9O1xuXHRcdHZhciBjb3JlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXHRcdHZhciBOZzJTb3J0YWJsZURpcmVjdGl2ZSA9IChmdW5jdGlvbiAoKSB7XG5cdFx0ICAgIGZ1bmN0aW9uIE5nMlNvcnRhYmxlRGlyZWN0aXZlKHZpZXdDb250YWluZXJSZWYpIHtcblx0XHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0ICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuXHRcdCAgICAgICAgdGhpcy5vcmRlckNoYW5nZWQgPSBuZXcgY29yZV8xLkV2ZW50RW1pdHRlcigpO1xuXHRcdCAgICAgICAgdGhpcy5kcmFnU3RhcnRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZHJhZ1N0YXJ0SGFuZGxlcicpO1xuXHRcdCAgICAgICAgICAgIF90aGlzLmRyYWdnaW5nRWwgPSBldmVudC50YXJnZXQ7XG5cdFx0ICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihfdGhpcy5kcmFnZ2luZ0VsLnN0eWxlLCB7XG5cdFx0ICAgICAgICAgICAgICAgIHpJbmRleDogMyxcblx0XHQgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnXG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICB9O1xuXHRcdCAgICAgICAgdGhpcy5kcmFnSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RyYWdIYW5kbGVyJyk7XG5cdFx0ICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihfdGhpcy5kcmFnZ2luZ0VsLnN0eWxlLCB7XG5cdFx0ICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwcHgsJyArIGV2ZW50LmRlbHRhWSArICdweCknXG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgdmFyIG5ld0VsRHJhZ0VudGVyID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jZW50ZXIueCwgZXZlbnQuY2VudGVyLnkpO1xuXHRcdCAgICAgICAgICAgIGlmIChfdGhpcy5lbERyYWdFbnRlciAhPT0gbmV3RWxEcmFnRW50ZXIpIHtcblx0XHQgICAgICAgICAgICAgICAgaWYgKF90aGlzLmVsRHJhZ0VudGVyKSB7XG5cdFx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbERyYWdFbnRlci5jbGFzc05hbWUgPSBfdGhpcy5lbERyYWdFbnRlci5jbGFzc05hbWUucmVwbGFjZSgvXFwgZHJhZy1lbnRlci9nLCAnJyk7XG5cdFx0ICAgICAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICAgICAgX3RoaXMuZWxEcmFnRW50ZXIgPSBuZXdFbERyYWdFbnRlcjtcblx0XHQgICAgICAgICAgICAgICAgaWYgKG5ld0VsRHJhZ0VudGVyLnRhZ05hbWUgPT09ICdMSScpIHtcblx0XHQgICAgICAgICAgICAgICAgICAgIG5ld0VsRHJhZ0VudGVyLmNsYXNzTmFtZSArPSAnIGRyYWctZW50ZXInO1xuXHRcdCAgICAgICAgICAgICAgICB9XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIHRoaXMuZHJhZ0VuZEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHQgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkcmFnRW5kSGFuZGxlcicpO1xuXHRcdCAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oX3RoaXMuZHJhZ2dpbmdFbC5zdHlsZSwge1xuXHRcdCAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwwKScsXG5cdFx0ICAgICAgICAgICAgICAgIHpJbmRleDogMSxcblx0XHQgICAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ2luaGVyaXQnXG5cdFx0ICAgICAgICAgICAgfSk7XG5cdFx0ICAgICAgICAgICAgLy8gcmVtb3ZlIGNsYXNzIGFuZCBkcm9wIHRoZSBlbGVtZW50XG5cdFx0ICAgICAgICAgICAgaWYgKF90aGlzLmVsRHJhZ0VudGVyKSB7XG5cdFx0ICAgICAgICAgICAgICAgIF90aGlzLmVsRHJhZ0VudGVyLmNsYXNzTmFtZSA9IF90aGlzLmVsRHJhZ0VudGVyLmNsYXNzTmFtZS5yZXBsYWNlKC9cXCBkcmFnLWVudGVyL2csICcnKTtcblx0XHQgICAgICAgICAgICAgICAgX3RoaXMuZWxEcmFnRW50ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoX3RoaXMuZHJhZ2dpbmdFbCwgX3RoaXMuZWxEcmFnRW50ZXIpO1xuXHRcdCAgICAgICAgICAgICAgICBfdGhpcy5lbWl0T3JkZXJDaGFuZ2VkKCk7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfTtcblx0XHQgICAgICAgIHRoaXMudWxFbCA9IHRoaXMudmlld0NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG5cdFx0ICAgIH1cblx0XHQgICAgTmcyU29ydGFibGVEaXJlY3RpdmUucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHRoaXMubGlFbHMgPSB0aGlzLnVsRWwucXVlcnlTZWxlY3RvckFsbCgnbGknKTtcblx0XHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saUVscy5sZW5ndGg7IGkrKykge1xuXHRcdCAgICAgICAgICAgIHZhciBsaUVsID0gdGhpcy5saUVsc1tpXTtcblx0XHQgICAgICAgICAgICAvLyBjcmVhdGUgYSBzaW1wbGUgaW5zdGFuY2UgYnkgZGVmYXVsdCwgaXQgb25seSBhZGRzIGhvcml6b250YWwgcmVjb2duaXplcnNcblx0XHQgICAgICAgICAgICB2YXIgbWMgPSBuZXcgSGFtbWVyKGxpRWwpO1xuXHRcdCAgICAgICAgICAgIC8vIGxldCB0aGUgcGFuIGdlc3R1cmUgc3VwcG9ydCBhbGwgZGlyZWN0aW9ucy5cblx0XHQgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmxvY2sgdGhlIHZlcnRpY2FsIHNjcm9sbGluZyBvbiBhIHRvdWNoLWRldmljZSB3aGlsZSBvbiB0aGUgZWxlbWVudFxuXHRcdCAgICAgICAgICAgIG1jLmdldCgncGFuJykuc2V0KHsgZGlyZWN0aW9uOiBIYW1tZXIuRElSRUNUSU9OX0FMTCB9KTtcblx0XHQgICAgICAgICAgICBtYy5vbigncGFuc3RhcnQnLCB0aGlzLmRyYWdTdGFydEhhbmRsZXIpO1xuXHRcdCAgICAgICAgICAgIG1jLm9uKCdwYW51cCBwYW5kb3duJywgdGhpcy5kcmFnSGFuZGxlcik7XG5cdFx0ICAgICAgICAgICAgbWMub24oJ3BhbmVuZCcsIHRoaXMuZHJhZ0VuZEhhbmRsZXIpO1xuXHRcdCAgICAgICAgICAgIHRoaXMuZW1pdE9yZGVyQ2hhbmdlZCgpO1xuXHRcdCAgICAgICAgfVxuXHRcdCAgICB9O1xuXHRcdCAgICBOZzJTb3J0YWJsZURpcmVjdGl2ZS5wcm90b3R5cGUuZW1pdE9yZGVyQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcblx0XHQgICAgICAgIHZhciBsaUVscyA9IHRoaXMudWxFbC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpO1xuXHRcdCAgICAgICAgdmFyIG9yZGVycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpRWxzKS5tYXAoZnVuY3Rpb24gKGVsKSB7IHJldHVybiBlbC5pZDsgfSk7XG5cdFx0ICAgICAgICB0aGlzLm9yZGVyQ2hhbmdlZC5lbWl0KG9yZGVycyk7XG5cdFx0ICAgIH07XG5cdFx0ICAgIF9fZGVjb3JhdGUoW1xuXHRcdCAgICAgICAgLy8gb3JkZXIgb2YgTEkgaWRzXG5cdFx0ICAgICAgICBjb3JlXzEuT3V0cHV0KCksIFxuXHRcdCAgICAgICAgX19tZXRhZGF0YSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG5cdFx0ICAgIF0sIE5nMlNvcnRhYmxlRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmRlckNoYW5nZWRcIiwgdm9pZCAwKTtcblx0XHQgICAgTmcyU29ydGFibGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcblx0XHQgICAgICAgIGNvcmVfMS5EaXJlY3RpdmUoe1xuXHRcdCAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nMi1zb3J0YWJsZV0nXG5cdFx0ICAgICAgICB9KSwgXG5cdFx0ICAgICAgICBfX21ldGFkYXRhKCdkZXNpZ246cGFyYW10eXBlcycsIFtjb3JlXzEuVmlld0NvbnRhaW5lclJlZl0pXG5cdFx0ICAgIF0sIE5nMlNvcnRhYmxlRGlyZWN0aXZlKTtcblx0XHQgICAgcmV0dXJuIE5nMlNvcnRhYmxlRGlyZWN0aXZlO1xuXHRcdH0oKSk7XG5cdFx0ZXhwb3J0cy5OZzJTb3J0YWJsZURpcmVjdGl2ZSA9IE5nMlNvcnRhYmxlRGlyZWN0aXZlO1xuXHRcblx0XG5cdC8qKiovIH1cblx0LyoqKioqKi8gXSlcblx0fSk7XG5cdDtcblx0Ly8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLXVpLXNvcnRhYmxlLnVtZC5qcy5tYXBcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmcyLXVpLnVtZC5qcy5tYXBcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9uZzItdWkvZGlzdC9uZzItdWkudW1kLmpzXG4gKiogbW9kdWxlIGlkID0gNThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 357:
/***/ function(module, exports) {

	eval("module.exports = \"<header class=\\\"masthead\\\">\\n  <div class=\\\"container bg-blue border-0 w-980\\\">\\n    <a href=\\\"/\\\" class=\\\"logo left text-white\\\">\\n      <img class=\\\"v-middle\\\" src=\\\"https://avatars1.githubusercontent.com/u/20460529?v=3&s=32\\\" />\\n      <span>NG2-UI</span>\\n    </a>\\n    <repo-info class=\\\"masthead-nav right\\\" numbers-section=\\\"1\\\"></repo-info>\\n    <!--<nav class=\\\"masthead-nav right\\\">-->\\n      <!--<a class=\\\"active\\\" href=\\\"/scaffolding\\\">Docs</a>-->\\n      <!--<a href=\\\"/about\\\">About</a>-->\\n      <!--<a href=\\\"https://github.com/primer/primer\\\" target=\\\"_blank\\\">GitHub</a>-->\\n      <!--<a href=\\\"https://github.com/primer/primer/blob/master/README.md#install\\\" target=\\\"_blank\\\">Install</a>-->\\n    <!--</nav>-->\\n  </div>\\n</header>\\n<div class=\\\"main container\\\">\\n  <div class=\\\"columns\\\">\\n    <div class=\\\"drawer one-fourth column\\\">\\n      <drawer-component class=\\\"drawer shadow-1\\\"></drawer-component>\\n      <repo-info contributors-section=\\\"1\\\"></repo-info>\\n    </div>\\n    <div class=\\\"three-fourths column markdown-body\\\">\\n      <router-outlet></router-outlet>\\n    </div>\\n  </div>\\n  <footer class=\\\"footer\\\">\\n    <div>\\n      Copyright JsValley 2016.<br>\\n      Created and maintained by the Ng2-UI team.\\n    </div>\\n  </footer>\\n</div>\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvYXBwLmh0bWw/ZDg1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzNTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPGhlYWRlciBjbGFzcz1cXFwibWFzdGhlYWRcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyIGJnLWJsdWUgYm9yZGVyLTAgdy05ODBcXFwiPlxcbiAgICA8YSBocmVmPVxcXCIvXFxcIiBjbGFzcz1cXFwibG9nbyBsZWZ0IHRleHQtd2hpdGVcXFwiPlxcbiAgICAgIDxpbWcgY2xhc3M9XFxcInYtbWlkZGxlXFxcIiBzcmM9XFxcImh0dHBzOi8vYXZhdGFyczEuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3UvMjA0NjA1Mjk/dj0zJnM9MzJcXFwiIC8+XFxuICAgICAgPHNwYW4+TkcyLVVJPC9zcGFuPlxcbiAgICA8L2E+XFxuICAgIDxyZXBvLWluZm8gY2xhc3M9XFxcIm1hc3RoZWFkLW5hdiByaWdodFxcXCIgbnVtYmVycy1zZWN0aW9uPVxcXCIxXFxcIj48L3JlcG8taW5mbz5cXG4gICAgPCEtLTxuYXYgY2xhc3M9XFxcIm1hc3RoZWFkLW5hdiByaWdodFxcXCI+LS0+XFxuICAgICAgPCEtLTxhIGNsYXNzPVxcXCJhY3RpdmVcXFwiIGhyZWY9XFxcIi9zY2FmZm9sZGluZ1xcXCI+RG9jczwvYT4tLT5cXG4gICAgICA8IS0tPGEgaHJlZj1cXFwiL2Fib3V0XFxcIj5BYm91dDwvYT4tLT5cXG4gICAgICA8IS0tPGEgaHJlZj1cXFwiaHR0cHM6Ly9naXRodWIuY29tL3ByaW1lci9wcmltZXJcXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5HaXRIdWI8L2E+LS0+XFxuICAgICAgPCEtLTxhIGhyZWY9XFxcImh0dHBzOi8vZ2l0aHViLmNvbS9wcmltZXIvcHJpbWVyL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCNpbnN0YWxsXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+SW5zdGFsbDwvYT4tLT5cXG4gICAgPCEtLTwvbmF2Pi0tPlxcbiAgPC9kaXY+XFxuPC9oZWFkZXI+XFxuPGRpdiBjbGFzcz1cXFwibWFpbiBjb250YWluZXJcXFwiPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29sdW1uc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImRyYXdlciBvbmUtZm91cnRoIGNvbHVtblxcXCI+XFxuICAgICAgPGRyYXdlci1jb21wb25lbnQgY2xhc3M9XFxcImRyYXdlciBzaGFkb3ctMVxcXCI+PC9kcmF3ZXItY29tcG9uZW50PlxcbiAgICAgIDxyZXBvLWluZm8gY29udHJpYnV0b3JzLXNlY3Rpb249XFxcIjFcXFwiPjwvcmVwby1pbmZvPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwidGhyZWUtZm91cnRocyBjb2x1bW4gbWFya2Rvd24tYm9keVxcXCI+XFxuICAgICAgPHJvdXRlci1vdXRsZXQ+PC9yb3V0ZXItb3V0bGV0PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbiAgPGZvb3RlciBjbGFzcz1cXFwiZm9vdGVyXFxcIj5cXG4gICAgPGRpdj5cXG4gICAgICBDb3B5cmlnaHQgSnNWYWxsZXkgMjAxNi48YnI+XFxuICAgICAgQ3JlYXRlZCBhbmQgbWFpbnRhaW5lZCBieSB0aGUgTmcyLVVJIHRlYW0uXFxuICAgIDwvZGl2PlxcbiAgPC9mb290ZXI+XFxuPC9kaXY+XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vYXBwL2FwcC5odG1sXG4gKiogbW9kdWxlIGlkID0gMzU3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 358:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar DrawerComponent = (function () {\n    function DrawerComponent() {\n    }\n    DrawerComponent = __decorate([\n        core_1.Component({\n            selector: 'drawer-component',\n            template: \"\\n    <ul class=\\\"menu\\\">\\n      <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/getting-started\\\">Getting Started</a>\\n      <li class=\\\"menu-item components\\\">\\n        <div class=\\\"pb-3\\\">Components</div>\\n        <ul class=\\\"menu \\\">\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/auto-complete\\\">Auto Complete</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/datetime-picker\\\">Datetime Picker</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/google-map\\\">Google Map</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/infinite-list\\\">Infinite List</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/tab\\\">Tab</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/accordion\\\">Accordion </a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/tooltip\\\">Tooltip</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/menu\\\">Menu</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/parallax\\\">Parallax Scroll</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/popup\\\">Popup</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/scrollable\\\">Scrollable</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/sortable\\\">Sortable</a>\\n          <li class=\\\"menu-item\\\" routerLinkActive=\\\"selected\\\"><a routerLink=\\\"/sticky\\\">Sticky Section</a>\\n        </ul>\\n      <li class=\\\"menu-item\\\"><a href=\\\"https://github.com/ng2-ui/ng2-ui/issues\\\">Help</a>\\n    </ul>\\n  \"\n        }), \n        __metadata('design:paramtypes', [])\n    ], DrawerComponent);\n    return DrawerComponent;\n}());\nexports.DrawerComponent = DrawerComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvZHJhd2VyLmNvbXBvbmVudC50cz80ODc1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBd0IsQ0FBZSxDQUFDO0FBNEJ4QztJQUFBO0lBQ0EsQ0FBQztJQTNCRDtRQUFDLGdCQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsa0JBQWtCO1lBQzVCLFFBQVEsRUFBRSxnd0RBc0JUO1NBQ0YsQ0FBQzs7dUJBQUE7SUFFRixzQkFBQztBQUFELENBQUM7QUFEWSx1QkFBZSxrQkFDM0IiLCJmaWxlIjoiMzU4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDb21wb25lbnR9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2RyYXdlci1jb21wb25lbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDx1bCBjbGFzcz1cIm1lbnVcIj5cbiAgICAgIDxsaSBjbGFzcz1cIm1lbnUtaXRlbVwiIHJvdXRlckxpbmtBY3RpdmU9XCJzZWxlY3RlZFwiPjxhIHJvdXRlckxpbms9XCIvZ2V0dGluZy1zdGFydGVkXCI+R2V0dGluZyBTdGFydGVkPC9hPlxuICAgICAgPGxpIGNsYXNzPVwibWVudS1pdGVtIGNvbXBvbmVudHNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBiLTNcIj5Db21wb25lbnRzPC9kaXY+XG4gICAgICAgIDx1bCBjbGFzcz1cIm1lbnUgXCI+XG4gICAgICAgICAgPGxpIGNsYXNzPVwibWVudS1pdGVtXCIgcm91dGVyTGlua0FjdGl2ZT1cInNlbGVjdGVkXCI+PGEgcm91dGVyTGluaz1cIi9hdXRvLWNvbXBsZXRlXCI+QXV0byBDb21wbGV0ZTwvYT5cbiAgICAgICAgICA8bGkgY2xhc3M9XCJtZW51LWl0ZW1cIiByb3V0ZXJMaW5rQWN0aXZlPVwic2VsZWN0ZWRcIj48YSByb3V0ZXJMaW5rPVwiL2RhdGV0aW1lLXBpY2tlclwiPkRhdGV0aW1lIFBpY2tlcjwvYT5cbiAgICAgICAgICA8bGkgY2xhc3M9XCJtZW51LWl0ZW1cIiByb3V0ZXJMaW5rQWN0aXZlPVwic2VsZWN0ZWRcIj48YSByb3V0ZXJMaW5rPVwiL2dvb2dsZS1tYXBcIj5Hb29nbGUgTWFwPC9hPlxuICAgICAgICAgIDxsaSBjbGFzcz1cIm1lbnUtaXRlbVwiIHJvdXRlckxpbmtBY3RpdmU9XCJzZWxlY3RlZFwiPjxhIHJvdXRlckxpbms9XCIvaW5maW5pdGUtbGlzdFwiPkluZmluaXRlIExpc3Q8L2E+XG4gICAgICAgICAgPGxpIGNsYXNzPVwibWVudS1pdGVtXCIgcm91dGVyTGlua0FjdGl2ZT1cInNlbGVjdGVkXCI+PGEgcm91dGVyTGluaz1cIi90YWJcIj5UYWI8L2E+XG4gICAgICAgICAgPGxpIGNsYXNzPVwibWVudS1pdGVtXCIgcm91dGVyTGlua0FjdGl2ZT1cInNlbGVjdGVkXCI+PGEgcm91dGVyTGluaz1cIi9hY2NvcmRpb25cIj5BY2NvcmRpb24gPC9hPlxuICAgICAgICAgIDxsaSBjbGFzcz1cIm1lbnUtaXRlbVwiIHJvdXRlckxpbmtBY3RpdmU9XCJzZWxlY3RlZFwiPjxhIHJvdXRlckxpbms9XCIvdG9vbHRpcFwiPlRvb2x0aXA8L2E+XG4gICAgICAgICAgPGxpIGNsYXNzPVwibWVudS1pdGVtXCIgcm91dGVyTGlua0FjdGl2ZT1cInNlbGVjdGVkXCI+PGEgcm91dGVyTGluaz1cIi9tZW51XCI+TWVudTwvYT5cbiAgICAgICAgICA8bGkgY2xhc3M9XCJtZW51LWl0ZW1cIiByb3V0ZXJMaW5rQWN0aXZlPVwic2VsZWN0ZWRcIj48YSByb3V0ZXJMaW5rPVwiL3BhcmFsbGF4XCI+UGFyYWxsYXggU2Nyb2xsPC9hPlxuICAgICAgICAgIDxsaSBjbGFzcz1cIm1lbnUtaXRlbVwiIHJvdXRlckxpbmtBY3RpdmU9XCJzZWxlY3RlZFwiPjxhIHJvdXRlckxpbms9XCIvcG9wdXBcIj5Qb3B1cDwvYT5cbiAgICAgICAgICA8bGkgY2xhc3M9XCJtZW51LWl0ZW1cIiByb3V0ZXJMaW5rQWN0aXZlPVwic2VsZWN0ZWRcIj48YSByb3V0ZXJMaW5rPVwiL3Njcm9sbGFibGVcIj5TY3JvbGxhYmxlPC9hPlxuICAgICAgICAgIDxsaSBjbGFzcz1cIm1lbnUtaXRlbVwiIHJvdXRlckxpbmtBY3RpdmU9XCJzZWxlY3RlZFwiPjxhIHJvdXRlckxpbms9XCIvc29ydGFibGVcIj5Tb3J0YWJsZTwvYT5cbiAgICAgICAgICA8bGkgY2xhc3M9XCJtZW51LWl0ZW1cIiByb3V0ZXJMaW5rQWN0aXZlPVwic2VsZWN0ZWRcIj48YSByb3V0ZXJMaW5rPVwiL3N0aWNreVwiPlN0aWNreSBTZWN0aW9uPC9hPlxuICAgICAgICA8L3VsPlxuICAgICAgPGxpIGNsYXNzPVwibWVudS1pdGVtXCI+PGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9uZzItdWkvbmcyLXVpL2lzc3Vlc1wiPkhlbHA8L2E+XG4gICAgPC91bD5cbiAgYFxufSlcbmV4cG9ydCBjbGFzcyBEcmF3ZXJDb21wb25lbnQge1xufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9kcmF3ZXIuY29tcG9uZW50LnRzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 359:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar router_1 = __webpack_require__(30);\nvar http_cache_1 = __webpack_require__(360);\nvar RepoInfoComponent = (function () {\n    function RepoInfoComponent(router, httpCache) {\n        var _this = this;\n        this.router = router;\n        this.httpCache = httpCache;\n        router.events.subscribe(function (event) {\n            if (event instanceof router_1.NavigationStart) {\n                _this.currentUrl = event.url;\n                console.log('currentUrl .........', _this.currentUrl);\n                if (_this.repositories) {\n                    _this.update();\n                }\n            }\n        });\n    }\n    RepoInfoComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        this.httpCache.get('https://api.github.com/users/ng2-ui/repos')\n            .subscribe(function (resp) {\n            console.log('repositories', resp);\n            _this.repositories = resp;\n            _this.update();\n        });\n    };\n    RepoInfoComponent.prototype.update = function () {\n        var _this = this;\n        var currentRepoUrl = this.getCurrentRepoUrl();\n        console.log('current repo url', currentRepoUrl);\n        for (var i = 0; i < this.repositories.length; i++) {\n            var repo = this.repositories[i];\n            if (repo.url === currentRepoUrl) {\n                this.currentRepo = repo;\n                console.log('currentRepo', this.currentRepo);\n                break;\n            }\n        }\n        this.getContributors(currentRepoUrl).subscribe(function (resp) {\n            console.log('resp', resp);\n            _this.contributors = resp;\n        });\n    };\n    RepoInfoComponent.prototype.getContributors = function (repoUrl) {\n        return this.httpCache.get(repoUrl + '/contributors');\n    };\n    RepoInfoComponent.prototype.getCurrentRepoUrl = function () {\n        switch (this.currentUrl) {\n            case '/auto-complete': return 'https://api.github.com/repos/ng2-ui/ng2-auto-complete';\n            case '/datetime-picker': return 'https://api.github.com/repos/ng2-ui/ng2-datetime-picker';\n            case '/google-map': return 'https://api.github.com/repos/ng2-ui/ng2-map';\n            case '/infinite-list': return 'https://api.github.com/repos/ng2-ui/ng2-infinite-list';\n            case '/tab': return 'https://api.github.com/repos/ng2-ui/ng2-tab';\n            case '/accordion': return 'https://api.github.com/repos/ng2-ui/ng2-collapsable';\n            case '/tooltip': return 'https://api.github.com/repos/ng2-ui/ng2-tooltip-overlay';\n            case '/menu': return 'https://api.github.com/repos/ng2-ui/ng2-menu';\n            case '/parallax': return 'https://api.github.com/repos/ng2-ui/ng2-parallax-scroll';\n            case '/popup': return 'https://api.github.com/repos/ng2-ui/ng2-popup';\n            case '/scrollable': return 'https://api.github.com/repos/ng2-ui/ng2-scrollable';\n            case '/sortable': return 'https://api.github.com/repos/ng2-ui/ng2-ui-sortable';\n            case '/sticky': return 'https://api.github.com/repos/ng2-ui/ng2-sticky';\n            default: return 'https://api.github.com/repos/ng2-ui/ng2-ui';\n        }\n    };\n    __decorate([\n        core_1.Input('contributors-section'), \n        __metadata('design:type', String)\n    ], RepoInfoComponent.prototype, \"contributorsSection\", void 0);\n    __decorate([\n        core_1.Input('numbers-section'), \n        __metadata('design:type', String)\n    ], RepoInfoComponent.prototype, \"numbersSection\", void 0);\n    RepoInfoComponent = __decorate([\n        core_1.Component({\n            selector: 'repo-info',\n            template: \"\\n    <div *ngIf=\\\"numbersSection\\\">\\n      <div *ngIf=\\\"currentUrl && currentRepo\\\">\\n        <span class=\\\"numbers d-inline-block\\\">\\n          <button class=\\\"btn btn-sm\\\">\\n            <a href=\\\"{{currentRepo.html_url}}\\\">\\n              <span class=\\\"octicon octicon-repo\\\"></span>\\n              {{currentUrl.replace('/','')}}\\n            </a>\\n          </button>\\n        </span>\\n        \\n        <span class=\\\"numbers d-inline-block\\\">\\n          <button class=\\\"btn btn-sm btn-with-count\\\">\\n            <a href=\\\"{{currentRepo.html_url}}\\\">\\n              <span class=\\\"octicon octicon-star\\\"></span>\\n              Star           \\n            </a>\\n          </button>\\n          <a class=\\\"social-count\\\" \\n            href=\\\"{{currentRepo.html_url}}/stargazers\\\">\\n            {{currentRepo.stargazers_count}}\\n          </a>\\n        </span>\\n        \\n        <span class=\\\"numbers d-inline-block\\\">\\n          <button class=\\\"btn btn-sm\\\">\\n            <a href=\\\"{{currentRepo.html_url}}/issues\\\">\\n              <span class=\\\"octicon octicon-issue-opened\\\"></span>\\n              {{currentRepo.open_issues}}\\n              Issues\\n            </a>\\n          </button>\\n        </span>\\n      </div>\\n    </div>\\n    \\n    <div *ngIf=\\\"contributorsSection\\\"\\n      class=\\\"container p-3 border\\\">\\n      <h3>Contributors</h3> \\n      <ul *ngIf=\\\"contributors\\\">\\n        <li class=\\\"contributor\\\" *ngFor=\\\"let user of contributors\\\">\\n          <a href=\\\"{{user.html_url}}\\\">\\n           <img src=\\\"{{user.avatar_url}}\\\" height=\\\"64\\\" /> <br/>\\n           <div class=\\\"name\\\">{{user.login}}</div>\\n          </a>\\n        </li>\\n        <li class=\\\"contributor\\\">\\n          <a href=\\\"{{currentRepo.html_url}}\\\">\\n           <div class=\\\"you\\\">You</div><br/>\\n           <div class=\\\"name\\\">Your Name</div>\\n          </a>\\n        </li>\\n      </ul>\\n    </div>\\n  \"\n        }), \n        __metadata('design:paramtypes', [router_1.Router, http_cache_1.HttpCache])\n    ], RepoInfoComponent);\n    return RepoInfoComponent;\n}());\nexports.RepoInfoComponent = RepoInfoComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvcmVwby1pbmZvLmNvbXBvbmVudC50cz82MGVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBK0IsQ0FBZSxDQUFDO0FBQy9DLG1DQUFzQyxFQUFpQixDQUFDO0FBSXhELHVDQUF3QixHQUFjLENBQUM7QUE2RHZDO0lBU0UsMkJBQW9CLE1BQWMsRUFBVSxTQUFvQjtRQVRsRSxpQkF1RUM7UUE5RHFCLFdBQU0sR0FBTixNQUFNLENBQVE7UUFBVSxjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQzlELE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLGVBQUs7WUFDM0IsRUFBRSxFQUFDLEtBQUssWUFBWSx3QkFBZSxDQUFDLENBQUMsQ0FBQztnQkFDcEMsS0FBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO2dCQUM1QixPQUFPLENBQUMsR0FBRyxDQUFDLHNCQUFzQixFQUFFLEtBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDckQsRUFBRSxDQUFDLENBQUMsS0FBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7b0JBQ3RCLEtBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDaEIsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxvQ0FBUSxHQUFSO1FBQUEsaUJBT0M7UUFOQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQywyQ0FBMkMsQ0FBQzthQUM1RCxTQUFTLENBQUMsY0FBSTtZQUNiLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2xDLEtBQUksQ0FBQyxZQUFZLEdBQVEsSUFBSSxDQUFDO1lBQzlCLEtBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNoQixDQUFDLENBQUM7SUFDTixDQUFDO0lBRUQsa0NBQU0sR0FBTjtRQUFBLGlCQWlCQztRQWhCQyxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUM5QyxPQUFPLENBQUMsR0FBRyxDQUFDLGtCQUFrQixFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBRWhELEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUNsRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2hDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssY0FBYyxDQUFDLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7Z0JBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDN0MsS0FBSyxDQUFDO1lBQ1IsQ0FBQztRQUNILENBQUM7UUFFRCxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxjQUFJO1lBQ2pELE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzFCLEtBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1FBQzNCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELDJDQUFlLEdBQWYsVUFBZ0IsT0FBZTtRQUM3QixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLGVBQWUsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCw2Q0FBaUIsR0FBakI7UUFDRSxNQUFNLEVBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDdkIsS0FBSyxnQkFBZ0IsRUFBSSxNQUFNLENBQUMsdURBQXVELENBQUM7WUFDeEYsS0FBSyxrQkFBa0IsRUFBRSxNQUFNLENBQUMseURBQXlELENBQUM7WUFDMUYsS0FBSyxhQUFhLEVBQU8sTUFBTSxDQUFDLDZDQUE2QyxDQUFDO1lBQzlFLEtBQUssZ0JBQWdCLEVBQUksTUFBTSxDQUFDLHVEQUF1RCxDQUFDO1lBQ3hGLEtBQUssTUFBTSxFQUFjLE1BQU0sQ0FBQyw2Q0FBNkMsQ0FBQztZQUM5RSxLQUFLLFlBQVksRUFBUSxNQUFNLENBQUMscURBQXFELENBQUM7WUFDdEYsS0FBSyxVQUFVLEVBQVUsTUFBTSxDQUFDLHlEQUF5RCxDQUFDO1lBQzFGLEtBQUssT0FBTyxFQUFhLE1BQU0sQ0FBQyw4Q0FBOEMsQ0FBQztZQUMvRSxLQUFLLFdBQVcsRUFBUyxNQUFNLENBQUMseURBQXlELENBQUM7WUFDMUYsS0FBSyxRQUFRLEVBQVksTUFBTSxDQUFDLCtDQUErQyxDQUFDO1lBQ2hGLEtBQUssYUFBYSxFQUFPLE1BQU0sQ0FBQyxvREFBb0QsQ0FBQztZQUNyRixLQUFLLFdBQVcsRUFBUyxNQUFNLENBQUMscURBQXFELENBQUM7WUFDdEYsS0FBSyxTQUFTLEVBQVcsTUFBTSxDQUFDLGdEQUFnRCxDQUFDO1lBQ2pGLFNBQVMsTUFBTSxDQUFDLDRDQUE0QyxDQUFDO1FBQy9ELENBQUM7SUFDSCxDQUFDO0lBckVEO1FBQUMsWUFBSyxDQUFDLHNCQUFzQixDQUFDOztrRUFBQTtJQUM5QjtRQUFDLFlBQUssQ0FBQyxpQkFBaUIsQ0FBQzs7NkRBQUE7SUE3RDNCO1FBQUMsZ0JBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxXQUFXO1lBQ3JCLFFBQVEsRUFBRSxrMkRBdURUO1NBQ0YsQ0FBQzs7eUJBQUE7SUF3RUYsd0JBQUM7QUFBRCxDQUFDO0FBdkVZLHlCQUFpQixvQkF1RTdCIiwiZmlsZSI6IjM1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q29tcG9uZW50LCBJbnB1dH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7Um91dGVyLCBOYXZpZ2F0aW9uU3RhcnR9IGZyb20gXCJAYW5ndWxhci9yb3V0ZXJcIjtcbmltcG9ydCB7SHR0cCwgUmVzcG9uc2V9IGZyb20gXCJAYW5ndWxhci9odHRwXCI7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gXCJyeGpzXCI7XG5cbmltcG9ydCB7SHR0cENhY2hlfSBmcm9tICcuL2h0dHAtY2FjaGUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdyZXBvLWluZm8nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgKm5nSWY9XCJudW1iZXJzU2VjdGlvblwiPlxuICAgICAgPGRpdiAqbmdJZj1cImN1cnJlbnRVcmwgJiYgY3VycmVudFJlcG9cIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJudW1iZXJzIGQtaW5saW5lLWJsb2NrXCI+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc21cIj5cbiAgICAgICAgICAgIDxhIGhyZWY9XCJ7e2N1cnJlbnRSZXBvLmh0bWxfdXJsfX1cIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJvY3RpY29uIG9jdGljb24tcmVwb1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAge3tjdXJyZW50VXJsLnJlcGxhY2UoJy8nLCcnKX19XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgXG4gICAgICAgIDxzcGFuIGNsYXNzPVwibnVtYmVycyBkLWlubGluZS1ibG9ja1wiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi13aXRoLWNvdW50XCI+XG4gICAgICAgICAgICA8YSBocmVmPVwie3tjdXJyZW50UmVwby5odG1sX3VybH19XCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwib2N0aWNvbiBvY3RpY29uLXN0YXJcIj48L3NwYW4+XG4gICAgICAgICAgICAgIFN0YXIgICAgICAgICAgIFxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxhIGNsYXNzPVwic29jaWFsLWNvdW50XCIgXG4gICAgICAgICAgICBocmVmPVwie3tjdXJyZW50UmVwby5odG1sX3VybH19L3N0YXJnYXplcnNcIj5cbiAgICAgICAgICAgIHt7Y3VycmVudFJlcG8uc3RhcmdhemVyc19jb3VudH19XG4gICAgICAgICAgPC9hPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIFxuICAgICAgICA8c3BhbiBjbGFzcz1cIm51bWJlcnMgZC1pbmxpbmUtYmxvY2tcIj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zbVwiPlxuICAgICAgICAgICAgPGEgaHJlZj1cInt7Y3VycmVudFJlcG8uaHRtbF91cmx9fS9pc3N1ZXNcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJvY3RpY29uIG9jdGljb24taXNzdWUtb3BlbmVkXCI+PC9zcGFuPlxuICAgICAgICAgICAgICB7e2N1cnJlbnRSZXBvLm9wZW5faXNzdWVzfX1cbiAgICAgICAgICAgICAgSXNzdWVzXG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgKm5nSWY9XCJjb250cmlidXRvcnNTZWN0aW9uXCJcbiAgICAgIGNsYXNzPVwiY29udGFpbmVyIHAtMyBib3JkZXJcIj5cbiAgICAgIDxoMz5Db250cmlidXRvcnM8L2gzPiBcbiAgICAgIDx1bCAqbmdJZj1cImNvbnRyaWJ1dG9yc1wiPlxuICAgICAgICA8bGkgY2xhc3M9XCJjb250cmlidXRvclwiICpuZ0Zvcj1cImxldCB1c2VyIG9mIGNvbnRyaWJ1dG9yc1wiPlxuICAgICAgICAgIDxhIGhyZWY9XCJ7e3VzZXIuaHRtbF91cmx9fVwiPlxuICAgICAgICAgICA8aW1nIHNyYz1cInt7dXNlci5hdmF0YXJfdXJsfX1cIiBoZWlnaHQ9XCI2NFwiIC8+IDxici8+XG4gICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYW1lXCI+e3t1c2VyLmxvZ2lufX08L2Rpdj5cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG4gICAgICAgIDxsaSBjbGFzcz1cImNvbnRyaWJ1dG9yXCI+XG4gICAgICAgICAgPGEgaHJlZj1cInt7Y3VycmVudFJlcG8uaHRtbF91cmx9fVwiPlxuICAgICAgICAgICA8ZGl2IGNsYXNzPVwieW91XCI+WW91PC9kaXY+PGJyLz5cbiAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5hbWVcIj5Zb3VyIE5hbWU8L2Rpdj5cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICBgXG59KVxuZXhwb3J0IGNsYXNzIFJlcG9JbmZvQ29tcG9uZW50IHtcbiAgQElucHV0KCdjb250cmlidXRvcnMtc2VjdGlvbicpIGNvbnRyaWJ1dG9yc1NlY3Rpb246IHN0cmluZztcbiAgQElucHV0KCdudW1iZXJzLXNlY3Rpb24nKSBudW1iZXJzU2VjdGlvbjogc3RyaW5nO1xuXG4gIGN1cnJlbnRVcmw6IHN0cmluZztcbiAgcmVwb3NpdG9yaWVzOiBhbnlbXTtcbiAgY3VycmVudFJlcG86IGFueTtcbiAgY29udHJpYnV0b3JzOiBhbnk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByb3V0ZXI6IFJvdXRlciwgcHJpdmF0ZSBodHRwQ2FjaGU6IEh0dHBDYWNoZSkge1xuICAgIHJvdXRlci5ldmVudHMuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgIGlmKGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvblN0YXJ0KSB7IC8vLi5FbmQsIC4uQ2FuY2VsLCAuLkVycm9yLCBldGNcbiAgICAgICAgdGhpcy5jdXJyZW50VXJsID0gZXZlbnQudXJsO1xuICAgICAgICBjb25zb2xlLmxvZygnY3VycmVudFVybCAuLi4uLi4uLi4nLCB0aGlzLmN1cnJlbnRVcmwpO1xuICAgICAgICBpZiAodGhpcy5yZXBvc2l0b3JpZXMpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmh0dHBDYWNoZS5nZXQoJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vdXNlcnMvbmcyLXVpL3JlcG9zJylcbiAgICAgIC5zdWJzY3JpYmUocmVzcCA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZXBvc2l0b3JpZXMnLCByZXNwKTtcbiAgICAgICAgdGhpcy5yZXBvc2l0b3JpZXMgPSA8YW55PnJlc3A7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB9KVxuICB9XG5cbiAgdXBkYXRlKCk6IHZvaWQge1xuICAgIGxldCBjdXJyZW50UmVwb1VybCA9IHRoaXMuZ2V0Q3VycmVudFJlcG9VcmwoKTtcbiAgICBjb25zb2xlLmxvZygnY3VycmVudCByZXBvIHVybCcsIGN1cnJlbnRSZXBvVXJsKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZXBvc2l0b3JpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCByZXBvID0gdGhpcy5yZXBvc2l0b3JpZXNbaV07XG4gICAgICBpZiAocmVwby51cmwgPT09IGN1cnJlbnRSZXBvVXJsKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFJlcG8gPSByZXBvO1xuICAgICAgICBjb25zb2xlLmxvZygnY3VycmVudFJlcG8nLCB0aGlzLmN1cnJlbnRSZXBvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5nZXRDb250cmlidXRvcnMoY3VycmVudFJlcG9VcmwpLnN1YnNjcmliZShyZXNwID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdyZXNwJywgcmVzcCk7XG4gICAgICB0aGlzLmNvbnRyaWJ1dG9ycyA9IHJlc3A7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb250cmlidXRvcnMocmVwb1VybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxSZXNwb25zZT57XG4gICAgcmV0dXJuIHRoaXMuaHR0cENhY2hlLmdldChyZXBvVXJsICsgJy9jb250cmlidXRvcnMnKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRSZXBvVXJsKCkge1xuICAgIHN3aXRjaCh0aGlzLmN1cnJlbnRVcmwpIHtcbiAgICAgIGNhc2UgJy9hdXRvLWNvbXBsZXRlJzogICByZXR1cm4gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvbmcyLXVpL25nMi1hdXRvLWNvbXBsZXRlJztcbiAgICAgIGNhc2UgJy9kYXRldGltZS1waWNrZXInOiByZXR1cm4gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvbmcyLXVpL25nMi1kYXRldGltZS1waWNrZXInO1xuICAgICAgY2FzZSAnL2dvb2dsZS1tYXAnOiAgICAgIHJldHVybiAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9uZzItdWkvbmcyLW1hcCc7XG4gICAgICBjYXNlICcvaW5maW5pdGUtbGlzdCc6ICAgcmV0dXJuICdodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL25nMi11aS9uZzItaW5maW5pdGUtbGlzdCc7XG4gICAgICBjYXNlICcvdGFiJzogICAgICAgICAgICAgcmV0dXJuICdodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL25nMi11aS9uZzItdGFiJztcbiAgICAgIGNhc2UgJy9hY2NvcmRpb24nOiAgICAgICByZXR1cm4gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvbmcyLXVpL25nMi1jb2xsYXBzYWJsZSc7XG4gICAgICBjYXNlICcvdG9vbHRpcCc6ICAgICAgICAgcmV0dXJuICdodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL25nMi11aS9uZzItdG9vbHRpcC1vdmVybGF5JztcbiAgICAgIGNhc2UgJy9tZW51JzogICAgICAgICAgICByZXR1cm4gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvbmcyLXVpL25nMi1tZW51JztcbiAgICAgIGNhc2UgJy9wYXJhbGxheCc6ICAgICAgICByZXR1cm4gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvbmcyLXVpL25nMi1wYXJhbGxheC1zY3JvbGwnO1xuICAgICAgY2FzZSAnL3BvcHVwJzogICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9uZzItdWkvbmcyLXBvcHVwJztcbiAgICAgIGNhc2UgJy9zY3JvbGxhYmxlJzogICAgICByZXR1cm4gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvbmcyLXVpL25nMi1zY3JvbGxhYmxlJztcbiAgICAgIGNhc2UgJy9zb3J0YWJsZSc6ICAgICAgICByZXR1cm4gJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3MvbmcyLXVpL25nMi11aS1zb3J0YWJsZSc7XG4gICAgICBjYXNlICcvc3RpY2t5JzogICAgICAgICAgcmV0dXJuICdodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL25nMi11aS9uZzItc3RpY2t5JztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiAnaHR0cHM6Ly9hcGkuZ2l0aHViLmNvbS9yZXBvcy9uZzItdWkvbmcyLXVpJztcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvcmVwby1pbmZvLmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 360:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar Rx_1 = __webpack_require__(59);\nvar http_1 = __webpack_require__(28);\nvar ng2_storage_1 = __webpack_require__(361);\nvar HttpCache = (function () {\n    function HttpCache(http, storage) {\n        this.http = http;\n        this.storage = storage;\n    }\n    HttpCache.prototype.get = function (url) {\n        var _this = this;\n        var cached;\n        if (cached = this.storage.getItem(url)) {\n            return Rx_1.Observable.of(cached);\n        }\n        else {\n            return this.http.get(url)\n                .map(function (resp) {\n                console.log('HTTP RESPONSE:', url, resp);\n                _this.storage.setItem(url, resp.text());\n                return resp.json();\n            });\n        }\n    };\n    HttpCache = __decorate([\n        core_1.Injectable(), \n        __metadata('design:paramtypes', [http_1.Http, ng2_storage_1.Ng2Storage])\n    ], HttpCache);\n    return HttpCache;\n}());\nexports.HttpCache = HttpCache;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvaHR0cC1jYWNoZS50cz9hZTU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBeUIsQ0FBZSxDQUFDO0FBQ3pDLCtCQUF5QixFQUFTLENBQUM7QUFDbkMsaUNBQW1CLEVBQWUsQ0FBQztBQUNuQyx3Q0FBeUIsR0FBZSxDQUFDO0FBR3pDO0lBQ0UsbUJBQ1UsSUFBVSxFQUNWLE9BQW1CO1FBRG5CLFNBQUksR0FBSixJQUFJLENBQU07UUFDVixZQUFPLEdBQVAsT0FBTyxDQUFZO0lBQzFCLENBQUM7SUFFSix1QkFBRyxHQUFILFVBQUksR0FBVztRQUFmLGlCQVlDO1FBWEMsSUFBSSxNQUFXLENBQUM7UUFDaEIsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN2QyxNQUFNLENBQUMsZUFBVSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUMvQixDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDTixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO2lCQUN0QixHQUFHLENBQUMsY0FBSTtnQkFDUCxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDekMsS0FBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO2dCQUN2QyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3JCLENBQUMsQ0FBQyxDQUFDO1FBQ1AsQ0FBQztJQUNILENBQUM7SUFuQkg7UUFBQyxpQkFBVSxFQUFFOztpQkFBQTtJQW9CYixnQkFBQztBQUFELENBQUM7QUFuQlksaUJBQVMsWUFtQnJCIiwiZmlsZSI6IjM2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSBcInJ4anMvUnhcIjtcbmltcG9ydCB7SHR0cH0gZnJvbSBcIkBhbmd1bGFyL2h0dHBcIjtcbmltcG9ydCB7TmcyU3RvcmFnZX0gZnJvbSBcIi4vbmcyLXN0b3JhZ2VcIjtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEh0dHBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaHR0cDogSHR0cCxcbiAgICBwcml2YXRlIHN0b3JhZ2U6IE5nMlN0b3JhZ2VcbiAgKSB7fVxuXG4gIGdldCh1cmw6IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgbGV0IGNhY2hlZDogYW55O1xuICAgIGlmIChjYWNoZWQgPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh1cmwpKSB7XG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZihjYWNoZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5odHRwLmdldCh1cmwpXG4gICAgICAgIC5tYXAocmVzcCA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0hUVFAgUkVTUE9OU0U6JywgdXJsLCByZXNwKTtcbiAgICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh1cmwsIHJlc3AudGV4dCgpKTtcbiAgICAgICAgICByZXR1cm4gcmVzcC5qc29uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvaHR0cC1jYWNoZS50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 361:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar MemoryStorage = (function () {\n    function MemoryStorage() {\n        this.data = {};\n    }\n    Object.defineProperty(MemoryStorage.prototype, \"length\", {\n        get: function () { return Object.keys(this.data).length; },\n        enumerable: true,\n        configurable: true\n    });\n    MemoryStorage.prototype.getItem = function (key) { return this.data[key]; };\n    MemoryStorage.prototype.setItem = function (key, value) { this.data[key] = value; };\n    MemoryStorage.prototype.removeItem = function (key) { delete this.data[key]; };\n    MemoryStorage.prototype.clear = function () { this.data = {}; };\n    MemoryStorage.prototype.key = function (num) { return Object.keys(this.data)[num]; };\n    return MemoryStorage;\n}());\nvar Ng2Storage = (function () {\n    function Ng2Storage() {\n        // preference && (this.preference = preference);   //'localStorage' or 'sessionStorage'\n        this.preference = 'sessionStorage';\n        if (this.preference == 'localStorage' && this.hasStorage('localStorage')) {\n            this.storage = window.localStorage;\n        }\n        else if (this.preference == 'sessionStorage' && this.hasStorage('sessionStorage')) {\n            this.storage = window.sessionStorage;\n        }\n        else {\n            this.storage = new MemoryStorage();\n        }\n    }\n    Object.defineProperty(Ng2Storage.prototype, \"length\", {\n        get: function () { return this.storage.length; },\n        enumerable: true,\n        configurable: true\n    });\n    Ng2Storage.prototype.getItem = function (key) {\n        var strValue = this.storage.getItem(key);\n        try {\n            return JSON.parse(strValue);\n        }\n        catch (e) {\n            return strValue;\n        }\n    };\n    Ng2Storage.prototype.setItem = function (key, value) {\n        var strValue = typeof value === 'object' ? JSON.stringify(value) : value.toString();\n        this.storage.setItem(key, strValue);\n    };\n    Ng2Storage.prototype.removeItem = function (key) { this.storage.removeItem(key); };\n    Ng2Storage.prototype.clear = function () { this.storage.clear(); };\n    Ng2Storage.prototype.hasStorage = function (name) {\n        try {\n            window[name].setItem('test', '1');\n            window[name].removeItem('test');\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    };\n    Ng2Storage = __decorate([\n        core_1.Injectable(), \n        __metadata('design:paramtypes', [])\n    ], Ng2Storage);\n    return Ng2Storage;\n}());\nexports.Ng2Storage = Ng2Storage;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXN0b3JhZ2UudHM/MWJhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUNBQXlCLENBQWUsQ0FBQztBQUV6QztJQUFBO1FBQ0UsU0FBSSxHQUFRLEVBQUUsQ0FBQztJQU9qQixDQUFDO0lBTkMsc0JBQUksaUNBQU07YUFBVixjQUF5QyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFDaEYsK0JBQU8sR0FBUCxVQUFRLEdBQVcsSUFBc0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLCtCQUFPLEdBQVAsVUFBUSxHQUFXLEVBQUUsS0FBVSxJQUFVLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNsRSxrQ0FBVSxHQUFWLFVBQVcsR0FBVyxJQUFtQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pFLDZCQUFLLEdBQUwsY0FBeUMsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLEVBQUMsQ0FBQztJQUN6RCwyQkFBRyxHQUFILFVBQUksR0FBVyxJQUEwQixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hGLG9CQUFDO0FBQUQsQ0FBQztBQUdEO0lBSUU7UUFDRSx1RkFBdUY7UUFKekYsZUFBVSxHQUFRLGdCQUFnQixDQUFDO1FBTWpDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksY0FBYyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3pFLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLFlBQVk7UUFDcEMsQ0FBQztRQUFDLElBQUksQ0FBQyxFQUFFLEVBQUMsSUFBSSxDQUFDLFVBQVUsSUFBSSxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25GLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLGNBQWM7UUFDdEMsQ0FBQztRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLGFBQWEsRUFBRTtRQUNwQyxDQUFDO0lBQ0gsQ0FBQztJQUVELHNCQUFJLDhCQUFNO2FBQVYsY0FBeUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzs7O09BQUE7SUFDdEUsNEJBQU8sR0FBUCxVQUFRLEdBQVE7UUFDZCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUM7WUFDSCxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM5QixDQUFFO1FBQUEsS0FBSyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDVixNQUFNLENBQUMsUUFBUSxDQUFDO1FBQ2xCLENBQUM7SUFDSCxDQUFDO0lBQ0QsNEJBQU8sR0FBUCxVQUFRLEdBQVcsRUFBRSxLQUFVO1FBQzdCLElBQUksUUFBUSxHQUFHLE9BQU8sS0FBSyxLQUFLLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNwRixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUNELCtCQUFVLEdBQVYsVUFBVyxHQUFXLElBQW1CLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4RSwwQkFBSyxHQUFMLGNBQXlDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQztJQUV4RCwrQkFBVSxHQUFsQixVQUFtQixJQUFZO1FBQzdCLElBQUksQ0FBQztZQUNILE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ2xDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDaEMsTUFBTSxDQUFDLElBQUk7UUFDYixDQUFFO1FBQUEsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNYLE1BQU0sQ0FBQyxLQUFLO1FBQ2QsQ0FBQztJQUNILENBQUM7SUF6Q0g7UUFBQyxpQkFBVSxFQUFFOztrQkFBQTtJQTBDYixpQkFBQztBQUFELENBQUM7QUF6Q1ksa0JBQVUsYUF5Q3RCIiwiZmlsZSI6IjM2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcblxuY2xhc3MgTWVtb3J5U3RvcmFnZSB7XG4gIGRhdGE6IGFueSA9IHt9O1xuICBnZXQgbGVuZ3RoKCk6IG51bWJlciAgICAgICAgICAgICAgICAgICB7IHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmxlbmd0aDsgfVxuICBnZXRJdGVtKGtleTogc3RyaW5nKSAgICAgICAgICAgICAgICAgICB7IHJldHVybiB0aGlzLmRhdGFba2V5XTsgfVxuICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7IHRoaXMuZGF0YVtrZXldID0gdmFsdWU7IH1cbiAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQgICAgICAgICAgeyBkZWxldGUgdGhpcy5kYXRhW2tleV07IH1cbiAgY2xlYXIoKTogdm9pZCAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0aGlzLmRhdGEgPSB7fSB9XG4gIGtleShudW06IG51bWJlcik6IHN0cmluZyAgICAgICAgICAgICAgIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGF0YSlbbnVtXTsgfVxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmcyU3RvcmFnZSB7XG4gIHByZWZlcmVuY2U6IGFueSA9ICdzZXNzaW9uU3RvcmFnZSc7XG4gIHN0b3JhZ2U6IGFueTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBwcmVmZXJlbmNlICYmICh0aGlzLnByZWZlcmVuY2UgPSBwcmVmZXJlbmNlKTsgICAvLydsb2NhbFN0b3JhZ2UnIG9yICdzZXNzaW9uU3RvcmFnZSdcblxuICAgIGlmICh0aGlzLnByZWZlcmVuY2UgPT0gJ2xvY2FsU3RvcmFnZScgJiYgdGhpcy5oYXNTdG9yYWdlKCdsb2NhbFN0b3JhZ2UnKSkge1xuICAgICAgdGhpcy5zdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZVxuICAgIH0gZWxzZSBpZih0aGlzLnByZWZlcmVuY2UgPT0gJ3Nlc3Npb25TdG9yYWdlJyAmJiB0aGlzLmhhc1N0b3JhZ2UoJ3Nlc3Npb25TdG9yYWdlJykpIHtcbiAgICAgIHRoaXMuc3RvcmFnZSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgTWVtb3J5U3RvcmFnZSgpXG4gICAgfVxuICB9XG5cbiAgZ2V0IGxlbmd0aCgpOiBudW1iZXIgICAgICAgICAgICAgICAgICAgeyByZXR1cm4gdGhpcy5zdG9yYWdlLmxlbmd0aDsgfVxuICBnZXRJdGVtKGtleTogYW55KSAgICAgICAgICAgICAgICAgICB7XG4gICAgbGV0IHN0clZhbHVlID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyVmFsdWUpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgcmV0dXJuIHN0clZhbHVlO1xuICAgIH1cbiAgfVxuICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgbGV0IHN0clZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCBzdHJWYWx1ZSk7XG4gIH1cbiAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQgICAgICAgICAgeyB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpOyB9XG4gIGNsZWFyKCk6IHZvaWQgICAgICAgICAgICAgICAgICAgICAgICAgIHsgdGhpcy5zdG9yYWdlLmNsZWFyKCkgIH1cblxuICBwcml2YXRlIGhhc1N0b3JhZ2UobmFtZTogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvd1tuYW1lXS5zZXRJdGVtKCd0ZXN0JywgJzEnKTtcbiAgICAgIHdpbmRvd1tuYW1lXS5yZW1vdmVJdGVtKCd0ZXN0Jyk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9uZzItc3RvcmFnZS50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 362:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar router_1 = __webpack_require__(30);\nvar components_route_1 = __webpack_require__(363);\nvar getting_started_component_1 = __webpack_require__(378);\nexports.routes = [\n    { path: 'getting-started', component: getting_started_component_1.GettingStartedComponent }\n].concat(components_route_1.ComponentsRoutes, [\n    { path: '', redirectTo: '/getting-started', pathMatch: 'full' }\n]);\nexports.APP_ROUTER_PROVIDERS = router_1.RouterModule.forRoot(exports.routes);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvYXBwLnJvdXRlcy50cz8xYWUwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxtQ0FBcUMsRUFBaUIsQ0FBQztBQUd2RCw2Q0FBNEMsR0FBc0MsQ0FBQztBQUNuRixzREFBNEMsR0FBNkIsQ0FBQztBQUc3RCxjQUFNLEdBQVc7SUFDNUIsRUFBRSxJQUFJLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLG1EQUF1QixFQUFDO1NBQzNELG1DQUFnQjtJQUNuQixFQUFFLElBQUksRUFBRSxFQUFFLEVBQUcsVUFBVSxFQUFFLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUM7RUFDaEUsQ0FBQztBQUVXLDRCQUFvQixHQUF3QixxQkFBWSxDQUFDLE9BQU8sQ0FBQyxjQUFNLENBQUMsQ0FBQyIsImZpbGUiOiIzNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSb3V0ZXMsIFJvdXRlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBNb2R1bGVXaXRoUHJvdmlkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENvbXBvbmVudHNSb3V0ZXMgfSAgICAgICAgICAgIGZyb20gXCIuL25nMi11aS1jb21wb25lbnRzL2NvbXBvbmVudHMucm91dGVcIjtcbmltcG9ydCB7IEdldHRpbmdTdGFydGVkQ29tcG9uZW50IH0gICAgIGZyb20gXCIuL2dldHRpbmctc3RhcnRlZC5jb21wb25lbnRcIjtcblxuXG5leHBvcnQgY29uc3Qgcm91dGVzOiBSb3V0ZXMgPSBbXG4gIHsgcGF0aDogJ2dldHRpbmctc3RhcnRlZCcsIGNvbXBvbmVudDogR2V0dGluZ1N0YXJ0ZWRDb21wb25lbnR9LFxuICAuLi5Db21wb25lbnRzUm91dGVzLFxuICB7IHBhdGg6ICcnLCAgcmVkaXJlY3RUbzogJy9nZXR0aW5nLXN0YXJ0ZWQnLCBwYXRoTWF0Y2g6ICdmdWxsJ31cbl07XG5cbmV4cG9ydCBjb25zdCBBUFBfUk9VVEVSX1BST1ZJREVSUzogTW9kdWxlV2l0aFByb3ZpZGVycyA9IFJvdXRlck1vZHVsZS5mb3JSb290KHJvdXRlcyk7XG5cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9hcHAucm91dGVzLnRzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 363:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar accordion_component_1 = __webpack_require__(364);\nvar datetime_picker_component_1 = __webpack_require__(365);\nvar google_map_component_1 = __webpack_require__(366);\nvar infinite_list_component_1 = __webpack_require__(367);\nvar overlay_component_1 = __webpack_require__(368);\nvar parallax_scroll_component_1 = __webpack_require__(369);\nvar popup_component_1 = __webpack_require__(370);\nvar scrollable_component_1 = __webpack_require__(371);\nvar sticky_component_1 = __webpack_require__(372);\nvar tab_component_1 = __webpack_require__(373);\nvar tooltip_component_1 = __webpack_require__(374);\nvar auto_complete_component_1 = __webpack_require__(375);\nvar menu_component_1 = __webpack_require__(376);\nvar sortable_component_1 = __webpack_require__(377);\nexports.ComponentsRoutes = [\n    { path: 'auto-complete', component: auto_complete_component_1.AutoCompleteComponent },\n    { path: 'datetime-picker', component: datetime_picker_component_1.DatetimePickerComponent },\n    { path: 'google-map', component: google_map_component_1.GoogleMapComponent },\n    { path: 'infinite-list', component: infinite_list_component_1.InfiniteListComponent },\n    { path: 'tab', component: tab_component_1.TabComponent },\n    { path: 'accordion', component: accordion_component_1.AccordionComponent },\n    { path: 'tooltip', component: tooltip_component_1.TooltipComponent },\n    { path: 'menu', component: menu_component_1.MenuComponent },\n    { path: 'overlay', component: overlay_component_1.OverlayComponent },\n    { path: 'parallax', component: parallax_scroll_component_1.ParallaxScrollComponent },\n    { path: 'popup', component: popup_component_1.PopupComponent },\n    { path: 'scrollable', component: scrollable_component_1.ScrollableComponent },\n    { path: 'sticky', component: sticky_component_1.StickyComponent },\n    { path: 'sortable', component: sortable_component_1.SortableComponent }\n];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvY29tcG9uZW50cy5yb3V0ZS50cz85ZWVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFFQSxnREFBaUMsR0FBdUIsQ0FBQztBQUN6RCxzREFBc0MsR0FBNkIsQ0FBQztBQUNwRSxpREFBaUMsR0FBd0IsQ0FBQztBQUMxRCxvREFBb0MsR0FBMkIsQ0FBQztBQUNoRSw4Q0FBK0IsR0FBcUIsQ0FBQztBQUNyRCxzREFBc0MsR0FBNkIsQ0FBQztBQUNwRSw0Q0FBNkIsR0FBbUIsQ0FBQztBQUNqRCxpREFBa0MsR0FBd0IsQ0FBQztBQUMzRCw2Q0FBOEIsR0FBb0IsQ0FBQztBQUNuRCwwQ0FBMkIsR0FBaUIsQ0FBQztBQUM3Qyw4Q0FBK0IsR0FBcUIsQ0FBQztBQUNyRCxvREFBb0MsR0FBMkIsQ0FBQztBQUNoRSwyQ0FBNEIsR0FBa0IsQ0FBQztBQUMvQywrQ0FBZ0MsR0FBc0IsQ0FBQztBQUUxQyx3QkFBZ0IsR0FBVztJQUN0QyxFQUFDLElBQUksRUFBRSxlQUFlLEVBQUUsU0FBUyxFQUFFLCtDQUFxQixFQUFDO0lBQ3pELEVBQUMsSUFBSSxFQUFFLGlCQUFpQixFQUFFLFNBQVMsRUFBRSxtREFBdUIsRUFBQztJQUM3RCxFQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLHlDQUFrQixFQUFDO0lBQ25ELEVBQUMsSUFBSSxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsK0NBQXFCLEVBQUM7SUFDekQsRUFBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSw0QkFBWSxFQUFDO0lBQ3RDLEVBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsd0NBQWtCLEVBQUM7SUFDbEQsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxvQ0FBZ0IsRUFBQztJQUM5QyxFQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLDhCQUFhLEVBQUM7SUFDeEMsRUFBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxvQ0FBZ0IsRUFBQztJQUM5QyxFQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLG1EQUF1QixFQUFDO0lBQ3RELEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsZ0NBQWMsRUFBQztJQUMxQyxFQUFDLElBQUksRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLDBDQUFtQixFQUFDO0lBQ3BELEVBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsa0NBQWUsRUFBQztJQUM1QyxFQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLHNDQUFpQixFQUFDO0NBQ2pELENBQUMiLCJmaWxlIjoiMzYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUm91dGVzIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuaW1wb3J0IHtBY2NvcmRpb25Db21wb25lbnR9IGZyb20gXCIuL2FjY29yZGlvbi5jb21wb25lbnRcIjtcbmltcG9ydCB7RGF0ZXRpbWVQaWNrZXJDb21wb25lbnR9IGZyb20gXCIuL2RhdGV0aW1lLXBpY2tlci5jb21wb25lbnRcIjtcbmltcG9ydCB7R29vZ2xlTWFwQ29tcG9uZW50fSBmcm9tIFwiLi9nb29nbGUtbWFwLmNvbXBvbmVudFwiO1xuaW1wb3J0IHtJbmZpbml0ZUxpc3RDb21wb25lbnR9IGZyb20gXCIuL2luZmluaXRlLWxpc3QuY29tcG9uZW50XCI7XG5pbXBvcnQge092ZXJsYXlDb21wb25lbnR9IGZyb20gXCIuL292ZXJsYXkuY29tcG9uZW50XCI7XG5pbXBvcnQge1BhcmFsbGF4U2Nyb2xsQ29tcG9uZW50fSBmcm9tIFwiLi9wYXJhbGxheC1zY3JvbGwuY29tcG9uZW50XCI7XG5pbXBvcnQge1BvcHVwQ29tcG9uZW50fSBmcm9tIFwiLi9wb3B1cC5jb21wb25lbnRcIjtcbmltcG9ydCB7U2Nyb2xsYWJsZUNvbXBvbmVudH0gZnJvbSBcIi4vc2Nyb2xsYWJsZS5jb21wb25lbnRcIjtcbmltcG9ydCB7U3RpY2t5Q29tcG9uZW50fSBmcm9tIFwiLi9zdGlja3kuY29tcG9uZW50XCI7XG5pbXBvcnQge1RhYkNvbXBvbmVudH0gZnJvbSBcIi4vdGFiLmNvbXBvbmVudFwiO1xuaW1wb3J0IHtUb29sdGlwQ29tcG9uZW50fSBmcm9tIFwiLi90b29sdGlwLmNvbXBvbmVudFwiO1xuaW1wb3J0IHtBdXRvQ29tcGxldGVDb21wb25lbnR9IGZyb20gXCIuL2F1dG8tY29tcGxldGUuY29tcG9uZW50XCI7XG5pbXBvcnQge01lbnVDb21wb25lbnR9IGZyb20gXCIuL21lbnUuY29tcG9uZW50XCI7XG5pbXBvcnQge1NvcnRhYmxlQ29tcG9uZW50fSBmcm9tIFwiLi9zb3J0YWJsZS5jb21wb25lbnRcIjtcblxuZXhwb3J0IGNvbnN0IENvbXBvbmVudHNSb3V0ZXM6IFJvdXRlcyA9IFtcbiAge3BhdGg6ICdhdXRvLWNvbXBsZXRlJywgY29tcG9uZW50OiBBdXRvQ29tcGxldGVDb21wb25lbnR9LFxuICB7cGF0aDogJ2RhdGV0aW1lLXBpY2tlcicsIGNvbXBvbmVudDogRGF0ZXRpbWVQaWNrZXJDb21wb25lbnR9LFxuICB7cGF0aDogJ2dvb2dsZS1tYXAnLCBjb21wb25lbnQ6IEdvb2dsZU1hcENvbXBvbmVudH0sXG4gIHtwYXRoOiAnaW5maW5pdGUtbGlzdCcsIGNvbXBvbmVudDogSW5maW5pdGVMaXN0Q29tcG9uZW50fSxcbiAge3BhdGg6ICd0YWInLCBjb21wb25lbnQ6IFRhYkNvbXBvbmVudH0sXG4gIHtwYXRoOiAnYWNjb3JkaW9uJywgY29tcG9uZW50OiBBY2NvcmRpb25Db21wb25lbnR9LFxuICB7cGF0aDogJ3Rvb2x0aXAnLCBjb21wb25lbnQ6IFRvb2x0aXBDb21wb25lbnR9LFxuICB7cGF0aDogJ21lbnUnLCBjb21wb25lbnQ6IE1lbnVDb21wb25lbnR9LFxuICB7cGF0aDogJ292ZXJsYXknLCBjb21wb25lbnQ6IE92ZXJsYXlDb21wb25lbnR9LFxuICB7cGF0aDogJ3BhcmFsbGF4JywgY29tcG9uZW50OiBQYXJhbGxheFNjcm9sbENvbXBvbmVudH0sXG4gIHtwYXRoOiAncG9wdXAnLCBjb21wb25lbnQ6IFBvcHVwQ29tcG9uZW50fSxcbiAge3BhdGg6ICdzY3JvbGxhYmxlJywgY29tcG9uZW50OiBTY3JvbGxhYmxlQ29tcG9uZW50fSxcbiAge3BhdGg6ICdzdGlja3knLCBjb21wb25lbnQ6IFN0aWNreUNvbXBvbmVudH0sXG4gIHtwYXRoOiAnc29ydGFibGUnLCBjb21wb25lbnQ6IFNvcnRhYmxlQ29tcG9uZW50fVxuXTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvY29tcG9uZW50cy5yb3V0ZS50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 364:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar AccordionComponent = (function () {\n    function AccordionComponent() {\n        this.foo = 'foo';\n        this.bar = 'bar';\n    }\n    AccordionComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    AccordionComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Accordion</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n      <div ng2-collapsable\\n        selected=\\\"js\\\"\\n        selected-index-class=\\\"selected\\\"\\n        selected-contents-class=\\\"selected\\\">\\n        <div index=\\\"html\\\">HTML</div>\\n        <div contents=\\\"html\\\">HTML {{foo}}</div>\\n        \\n        <div index=\\\"js\\\">Javascript</div>\\n        <div contents=\\\"js\\\">Javascript {{bar}}</div>\\n        \\n        <div index=\\\"css\\\">Css</div>\\n        <div contents=\\\"css\\\">Style Sheet</div>\\n      </div>\\n      <div class=\\\"spacer x2\\\"></div>\\n      <div ng2-tab> \\n        <div class=\\\"tabs\\\">\\n          <div index=\\\"html\\\">HTML</div>\\n          <div index=\\\"js\\\">Javascript</div>\\n        </div>\\n        <div class=\\\"tab-contents\\\">\\n          <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;div ng2-collapsable\\n  selected=\\\"js\\\"\\n  selected-index-class=\\\"selected\\\"\\n  selected-contents-class=\\\"selected\\\">\\n  &lt;div index=\\\"html\\\">HTML&lt;/div>\\n  &lt;div contents=\\\"html\\\">HTML &123;&123;foo&125;&125;&lt;/div>\\n  \\n  &lt;div index=\\\"js\\\">Javascript&lt;/div>\\n  &lt;div contents=\\\"js\\\">Javascript &123;&123;bar&125;&125;&lt;/div>\\n  \\n  &lt;div index=\\\"css\\\">Css&lt;/div>\\n  &lt;div contents=\\\"css\\\">Style Sheet&lt;/div>\\n&lt;/div></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent &123;\\n  foo: any = 'foo';\\n  bar: any = 'bar';\\n&125;</code></pre>\\n          </div>\\n        </div>\\n      </div>\\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], AccordionComponent);\n    return AccordionComponent;\n}());\nexports.AccordionComponent = AccordionComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvYWNjb3JkaW9uLmNvbXBvbmVudC50cz83NmQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBMEIsQ0FBZSxDQUFDO0FBNEQxQztJQUFBO1FBQ0UsUUFBRyxHQUFRLEtBQUssQ0FBQztRQUNqQixRQUFHLEdBQVEsS0FBSyxDQUFDO0lBS25CLENBQUM7SUFIQyw0Q0FBZSxHQUFmO1FBQ0UsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQWhFSDtRQUFDLGdCQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsNHBEQXVERDtTQUNWLENBQUM7OzBCQUFBO0lBUUYseUJBQUM7QUFBRCxDQUFDO0FBUFksMEJBQWtCLHFCQU85QiIsImZpbGUiOiIzNjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBwYWdlLXRpdGxlXCI+XG4gICAgICA8aDE+QWNjb3JkaW9uPC9oMT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IG5nMi1jb2xsYXBzYWJsZVxuICAgICAgICBzZWxlY3RlZD1cImpzXCJcbiAgICAgICAgc2VsZWN0ZWQtaW5kZXgtY2xhc3M9XCJzZWxlY3RlZFwiXG4gICAgICAgIHNlbGVjdGVkLWNvbnRlbnRzLWNsYXNzPVwic2VsZWN0ZWRcIj5cbiAgICAgICAgPGRpdiBpbmRleD1cImh0bWxcIj5IVE1MPC9kaXY+XG4gICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+SFRNTCB7e2Zvb319PC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgIDxkaXYgY29udGVudHM9XCJqc1wiPkphdmFzY3JpcHQge3tiYXJ9fTwvZGl2PlxuICAgICAgICBcbiAgICAgICAgPGRpdiBpbmRleD1cImNzc1wiPkNzczwvZGl2PlxuICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiY3NzXCI+U3R5bGUgU2hlZXQ8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4MlwiPjwvZGl2PlxuICAgICAgPGRpdiBuZzItdGFiPiBcbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImh0bWxcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1tYXJrdXBcIlxuPiZsdDtkaXYgbmcyLWNvbGxhcHNhYmxlXG4gIHNlbGVjdGVkPVwianNcIlxuICBzZWxlY3RlZC1pbmRleC1jbGFzcz1cInNlbGVjdGVkXCJcbiAgc2VsZWN0ZWQtY29udGVudHMtY2xhc3M9XCJzZWxlY3RlZFwiPlxuICAmbHQ7ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUwmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBjb250ZW50cz1cImh0bWxcIj5IVE1MICYxMjM7JjEyMztmb28mMTI1OyYxMjU7Jmx0Oy9kaXY+XG4gIFxuICAmbHQ7ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0Jmx0Oy9kaXY+XG4gICZsdDtkaXYgY29udGVudHM9XCJqc1wiPkphdmFzY3JpcHQgJjEyMzsmMTIzO2JhciYxMjU7JjEyNTsmbHQ7L2Rpdj5cbiAgXG4gICZsdDtkaXYgaW5kZXg9XCJjc3NcIj5Dc3MmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBjb250ZW50cz1cImNzc1wiPlN0eWxlIFNoZWV0Jmx0Oy9kaXY+XG4mbHQ7L2Rpdj48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQgJjEyMztcbiAgZm9vOiBhbnkgPSAnZm9vJztcbiAgYmFyOiBhbnkgPSAnYmFyJztcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgQWNjb3JkaW9uQ29tcG9uZW50IHtcbiAgZm9vOiBhbnkgPSAnZm9vJztcbiAgYmFyOiBhbnkgPSAnYmFyJztcblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgd2luZG93LnNjcm9sbCgwLDApO1xuICB9XG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL25nMi11aS1jb21wb25lbnRzL2FjY29yZGlvbi5jb21wb25lbnQudHNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 365:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar DatetimePickerComponent = (function () {\n    function DatetimePickerComponent() {\n        this.date1 = new Date(\"2015-01-01\");\n        this.date2 = new Date(\"Thu Jan 01 2015 00:00:00 GMT-0500 (EST)\");\n        this.date3 = '2015-01-01T00:00:00-0400';\n        this.date4 = '2015-01-01';\n        this.gmtDate = '2015-01-01T00:00:00.000Z';\n    }\n    DatetimePickerComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    DatetimePickerComponent = __decorate([\n        core_1.Component({\n            styles: [\"input[ng2-datetime-picker] {width: 300px; height: 24px}\"],\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Datetime Picker</h1>\\n    </div>\\n    \\n    <div class=\\\"container\\\">\\n      <p>\\n        Datetime picker converts input field into datetime selector by simply adding \\\"ng2-datetime-picker\\\" as an attribute.\\n      </p> \\n    \\n      <div class=\\\"spacer x2\\\"></div>\\n      <p><b>myDate</b>: &123;&123;myDate&125;&125;</p>\\n      <input [(ngModel)]=\\\"myDate\\\" ng2-datetime-picker />\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input [(ngModel)]=\\\"myDate\\\" ng2-datetime-picker /&gt;</code></pre>\\n           </div>\\n           <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  myDate: string;\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n        \\n      <div class=\\\"spacer x2\\\"></div>\\n      <p><b>date1</b>: &123;&123;date1&125;&125;</p>\\n      <input [(ngModel)]=\\\"date1\\\" ng2-datetime-picker date-only=\\\"true\\\" />\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input [(ngModel)]=\\\"date1\\\" ng2-datetime-picker\\n       date-only=\\\"true\\\" /&gt;</code></pre>\\n           </div>\\n           <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  date1 = new Date(\\\"2015-01-01\\\");\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n        \\n      <div class=\\\"spacer x2\\\"></div>\\n      <p><b>date2</b>: &123;&123;date2&125;&125;</p>\\n      <input [(ngModel)]=\\\"date2\\\" ng2-datetime-picker date-only=\\\"true\\\" />\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input [(ngModel)]=\\\"date2\\\" ng2-datetime-picker\\n       date-only=\\\"true\\\" /&gt;</code></pre>\\n           </div>\\n           <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  date2 = new Date(\\\"Thu Jan 01 2015 00:00:00 GMT-0500 (EST)\\\");\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n        \\n      <div class=\\\"spacer x2\\\"></div>\\n      <p><b>date3</b>: &123;&123;date3&125;&125;</p>\\n      <input [(ngModel)]=\\\"date3\\\" ng2-datetime-picker close-on-select=\\\"false\\\" />\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input  [(ngModel)]=\\\"date3\\\" ng2-datetime-picker\\n       close-on-select=\\\"false\\\" /&gt;</code></pre>\\n           </div>\\n           <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  date3 = '2015-01-01T00:00:00-0400';\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n        \\n      <div class=\\\"spacer x2\\\"></div>\\n      <p><b>date4</b>: &123;&123;date4&125;&125;</p>\\n      <input [(ngModel)]=\\\"date4\\\" ng2-datetime-picker hour=\\\"23\\\" minute='59'/>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input ng-model=\\\"date4\\\" ng2-datetime-picker\\n       hour=\\\"23\\\"\\n       minute='59'/&gt; </code></pre>\\n           </div>\\n           <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  date4 = '2015-01-01';\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n        \\n      <div class=\\\"spacer x2\\\"></div>\\n      <p><b>gmtDate</b>: &123;&123;gmtDate&125;&125;</p>\\n      <input [(ngModel)]=\\\"gmtDate\\\" ng2-datetime-picker />\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input [(ngModel)]=\\\"gmtDate\\\" ng2-datetime-picker /&gt; </code></pre>\\n           </div>\\n           <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  gmtDate = '2015-01-01T00:00:00.000Z';\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n        \\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], DatetimePickerComponent);\n    return DatetimePickerComponent;\n}());\nexports.DatetimePickerComponent = DatetimePickerComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvZGF0ZXRpbWUtcGlja2VyLmNvbXBvbmVudC50cz81ZDk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBMEIsQ0FBZSxDQUFDO0FBdUwxQztJQUFBO1FBQ0UsVUFBSyxHQUFHLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQy9CLFVBQUssR0FBRyxJQUFJLElBQUksQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1FBQzVELFVBQUssR0FBRywwQkFBMEIsQ0FBQztRQUNuQyxVQUFLLEdBQUcsWUFBWSxDQUFDO1FBQ3JCLFlBQU8sR0FBRywwQkFBMEIsQ0FBQztJQUt2QyxDQUFDO0lBSEMsaURBQWUsR0FBZjtRQUNFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUE5TEg7UUFBQyxnQkFBUyxDQUFDO1lBQ1QsTUFBTSxFQUFFLENBQUMseURBQXlELENBQUM7WUFDbkUsUUFBUSxFQUFFLDYrS0FpTEQ7U0FDVixDQUFDOzsrQkFBQTtJQVdGLDhCQUFDO0FBQUQsQ0FBQztBQVZZLCtCQUF1QiwwQkFVbkMiLCJmaWxlIjoiMzY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzdHlsZXM6IFtgaW5wdXRbbmcyLWRhdGV0aW1lLXBpY2tlcl0ge3dpZHRoOiAzMDBweDsgaGVpZ2h0OiAyNHB4fWBdLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgcGFnZS10aXRsZVwiPlxuICAgICAgPGgxPkRhdGV0aW1lIFBpY2tlcjwvaDE+XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgPHA+XG4gICAgICAgIERhdGV0aW1lIHBpY2tlciBjb252ZXJ0cyBpbnB1dCBmaWVsZCBpbnRvIGRhdGV0aW1lIHNlbGVjdG9yIGJ5IHNpbXBseSBhZGRpbmcgXCJuZzItZGF0ZXRpbWUtcGlja2VyXCIgYXMgYW4gYXR0cmlidXRlLlxuICAgICAgPC9wPiBcbiAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDJcIj48L2Rpdj5cbiAgICAgIDxwPjxiPm15RGF0ZTwvYj46ICYxMjM7JjEyMztteURhdGUmMTI1OyYxMjU7PC9wPlxuICAgICAgPGlucHV0IFsobmdNb2RlbCldPVwibXlEYXRlXCIgbmcyLWRhdGV0aW1lLXBpY2tlciAvPlxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7aW5wdXQgWyhuZ01vZGVsKV09XCJteURhdGVcIiBuZzItZGF0ZXRpbWUtcGlja2VyIC8mZ3Q7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuICBteURhdGU6IHN0cmluZztcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDJcIj48L2Rpdj5cbiAgICAgIDxwPjxiPmRhdGUxPC9iPjogJjEyMzsmMTIzO2RhdGUxJjEyNTsmMTI1OzwvcD5cbiAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cImRhdGUxXCIgbmcyLWRhdGV0aW1lLXBpY2tlciBkYXRlLW9ubHk9XCJ0cnVlXCIgLz5cbiAgICAgIDxuZzItdGFiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O2lucHV0IFsobmdNb2RlbCldPVwiZGF0ZTFcIiBuZzItZGF0ZXRpbWUtcGlja2VyXG4gICAgICAgZGF0ZS1vbmx5PVwidHJ1ZVwiIC8mZ3Q7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuICBkYXRlMSA9IG5ldyBEYXRlKFwiMjAxNS0wMS0wMVwiKTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDJcIj48L2Rpdj5cbiAgICAgIDxwPjxiPmRhdGUyPC9iPjogJjEyMzsmMTIzO2RhdGUyJjEyNTsmMTI1OzwvcD5cbiAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cImRhdGUyXCIgbmcyLWRhdGV0aW1lLXBpY2tlciBkYXRlLW9ubHk9XCJ0cnVlXCIgLz5cbiAgICAgIDxuZzItdGFiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O2lucHV0IFsobmdNb2RlbCldPVwiZGF0ZTJcIiBuZzItZGF0ZXRpbWUtcGlja2VyXG4gICAgICAgZGF0ZS1vbmx5PVwidHJ1ZVwiIC8mZ3Q7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuICBkYXRlMiA9IG5ldyBEYXRlKFwiVGh1IEphbiAwMSAyMDE1IDAwOjAwOjAwIEdNVC0wNTAwIChFU1QpXCIpO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgPC9kaXY+XG4gICAgICA8L25nMi10YWI+XG4gICAgICAgIFxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4MlwiPjwvZGl2PlxuICAgICAgPHA+PGI+ZGF0ZTM8L2I+OiAmMTIzOyYxMjM7ZGF0ZTMmMTI1OyYxMjU7PC9wPlxuICAgICAgPGlucHV0IFsobmdNb2RlbCldPVwiZGF0ZTNcIiBuZzItZGF0ZXRpbWUtcGlja2VyIGNsb3NlLW9uLXNlbGVjdD1cImZhbHNlXCIgLz5cbiAgICAgIDxuZzItdGFiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O2lucHV0ICBbKG5nTW9kZWwpXT1cImRhdGUzXCIgbmcyLWRhdGV0aW1lLXBpY2tlclxuICAgICAgIGNsb3NlLW9uLXNlbGVjdD1cImZhbHNlXCIgLyZndDs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KCYxMjM7XG4gIHRlbXBsYXRlVXI6ICdhcHAuaHRtbCdcbiYxMjU7KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCYxMjM7XG4gIGRhdGUzID0gJzIwMTUtMDEtMDFUMDA6MDA6MDAtMDQwMCc7XG4mMTI1OzwvY29kZT48L3ByZT5cbiAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmcyLXRhYj5cbiAgICAgICAgXG4gICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyIHgyXCI+PC9kaXY+XG4gICAgICA8cD48Yj5kYXRlNDwvYj46ICYxMjM7JjEyMztkYXRlNCYxMjU7JjEyNTs8L3A+XG4gICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XCJkYXRlNFwiIG5nMi1kYXRldGltZS1waWNrZXIgaG91cj1cIjIzXCIgbWludXRlPSc1OScvPlxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7aW5wdXQgbmctbW9kZWw9XCJkYXRlNFwiIG5nMi1kYXRldGltZS1waWNrZXJcbiAgICAgICBob3VyPVwiMjNcIlxuICAgICAgIG1pbnV0ZT0nNTknLyZndDsgPC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuICBkYXRlNCA9ICcyMDE1LTAxLTAxJztcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDJcIj48L2Rpdj5cbiAgICAgIDxwPjxiPmdtdERhdGU8L2I+OiAmMTIzOyYxMjM7Z210RGF0ZSYxMjU7JjEyNTs8L3A+XG4gICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XCJnbXREYXRlXCIgbmcyLWRhdGV0aW1lLXBpY2tlciAvPlxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7aW5wdXQgWyhuZ01vZGVsKV09XCJnbXREYXRlXCIgbmcyLWRhdGV0aW1lLXBpY2tlciAvJmd0OyA8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KCYxMjM7XG4gIHRlbXBsYXRlVXI6ICdhcHAuaHRtbCdcbiYxMjU7KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCYxMjM7XG4gIGdtdERhdGUgPSAnMjAxNS0wMS0wMVQwMDowMDowMC4wMDBaJztcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgICAgICBcbiAgICA8L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIERhdGV0aW1lUGlja2VyQ29tcG9uZW50IHtcbiAgZGF0ZTEgPSBuZXcgRGF0ZShcIjIwMTUtMDEtMDFcIik7XG4gIGRhdGUyID0gbmV3IERhdGUoXCJUaHUgSmFuIDAxIDIwMTUgMDA6MDA6MDAgR01ULTA1MDAgKEVTVClcIik7XG4gIGRhdGUzID0gJzIwMTUtMDEtMDFUMDA6MDA6MDAtMDQwMCc7XG4gIGRhdGU0ID0gJzIwMTUtMDEtMDEnO1xuICBnbXREYXRlID0gJzIwMTUtMDEtMDFUMDA6MDA6MDAuMDAwWic7XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHdpbmRvdy5zY3JvbGwoMCwwKTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9uZzItdWktY29tcG9uZW50cy9kYXRldGltZS1waWNrZXIuY29tcG9uZW50LnRzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 366:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar GoogleMapComponent = (function () {\n    function GoogleMapComponent() {\n        this.positions = [];\n        this.tab1 = 1;\n        this.tab2 = 1;\n        this.tab3 = 1;\n        this.tab4 = 1;\n    }\n    GoogleMapComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    GoogleMapComponent.prototype.clicked = function (marker) {\n        marker.map.mapComponent.openInfoWindow('iw', marker, {\n            lat: marker.getPosition().lat(), lng: marker.getPosition().lng()\n        });\n    };\n    GoogleMapComponent.prototype.showRandomMarkers = function () {\n        var randomLat, randomLng;\n        this.positions = [];\n        for (var i = 0; i < 9; i++) {\n            randomLat = Math.random() * (43.7399 - 43.7300) + 43.7300;\n            randomLng = Math.random() * (-79.7600 - -79.7699) + -79.7699;\n            this.positions.push([randomLat, randomLng]);\n        }\n    };\n    GoogleMapComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\" xmlns=\\\"http://www.w3.org/1999/html\\\">\\n      <h1>Google Map</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n    \\n      <div class=\\\"spacer x3\\\"></div>\\n      <h2>Markers with *ngFor</h2>\\n        <ng2-map zoom=\\\"13\\\" center=\\\"Brampton, Canada\\\" scrollwheel=\\\"false\\\">\\n          <marker *ngFor=\\\"let pos of positions\\\" [position]=\\\"pos\\\"></marker>\\n        </ng2-map>\\n        <button (click)=\\\"showRandomMarkers()\\\">Show Random Markers</button>\\n      <div>\\n        <div class=\\\"tabs\\\">\\n          <div class=\\\"tab\\\" (click)=\\\"tab3=1\\\" [class.selected]=\\\"tab3===1\\\">html</div>\\n          <div class=\\\"tab\\\" (click)=\\\"tab3=2\\\" [class.selected]=\\\"tab3===2\\\">javascript</div>\\n        </div>\\n        <div class=\\\"tab-contents\\\">\\n          <div *ngIf=\\\"tab3===1\\\">\\n            <pre><code class=\\\"language-markup\\\"\\n>&lt;ng2-map zoom=\\\"13\\\" center=\\\"Brampton, Canada\\\" scrollwheel=\\\"false\\\">\\n  &lt;marker *ngFor=\\\"let pos of positions\\\" [position]=\\\"pos\\\">&lt;/marker>\\n&lt;/ng2-map>\\n&lt;button (click)=\\\"showRandomMarkers()\\\">Show Random Markers&lt;/button></code></pre>\\n          </div>\\n          <div *ngIf=\\\"tab3===2\\\">\\n            <pre><code class=\\\"language-markup\\\"\\n            >import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  template: require('./app.html')\\n&125;)\\nclass AppCompoment &123;\\n  public positions=[];\\n  \\n  showRandomMarkers() &123;\\n    let randomLat: number, randomLng: number;\\n\\n    this.positions = [];\\n    for (let i=0; i<9; i++) &123;\\n      randomLat = Math.random() * (43.7399 - 43.7300) + 43.7300;\\n      randomLng = Math.random() * (-79.7600 - -79.7699) + -79.7699;\\n      this.positions.push([randomLat, randomLng]);\\n    &125;\\n  &125;\\n&125;</code></pre>\\n          </div>\\n        </div>\\n      </div>\\n      \\n      <div class=\\\"spacer x3\\\"></div>\\n      <h2>Simple Map</h2>\\n      <div>\\n        <div class=\\\"tabs\\\">\\n          <div class=\\\"tab\\\" (click)=\\\"tab4=1\\\" [class.selected]=\\\"tab4===1\\\">html</div>\\n          <div class=\\\"tab\\\" (click)=\\\"tab4=2\\\" [class.selected]=\\\"tab4===2\\\">javascript</div>\\n        </div>\\n        <div class=\\\"tab-contents\\\">\\n          <div *ngIf=\\\"tab4===1\\\">\\n            <pre><code class=\\\"language-markup\\\"\\n            >&lt;ng2-map center=\\\"Brampton, Canada\\\" scrollwheel=\\\"false\\\">&lt;/ng2-map></code></pre>\\n          </div>\\n          <div *ngIf=\\\"tab4===2\\\">\\n            <pre><code class=\\\"language-markup\\\"\\n            >import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  template: require('./app.html')\\n&125;)\\nclass AppCompoment &123;&125;</code></pre>\\n          </div>\\n        </div>\\n      </div>\\n          \\n      <div class=\\\"spacer x3\\\"></div>\\n      <h2>Simple Marker</h2>\\n      <div>\\n        <div class=\\\"tabs\\\">\\n          <div class=\\\"tab\\\" (click)=\\\"tab1=1\\\" [class.selected]=\\\"tab1===1\\\">html</div>\\n          <div class=\\\"tab\\\" (click)=\\\"tab1=2\\\" [class.selected]=\\\"tab1===2\\\">javascript</div>\\n        </div>\\n        <div class=\\\"tab-contents\\\">\\n          <div *ngIf=\\\"tab1===1\\\">\\n            <pre><code class=\\\"language-markup\\\">&lt;ng2-map center=\\\"Brampton, Canada\\\" >\\n&lt;marker position=\\\"Brampton, Canada\\\"\\n  (markerDragstart)=\\\"log($event, 'dragstart')\\\"\\n  (markerDragend)=\\\"log($event, 'dragend')\\\"\\n  draggable=\\\"true\\\">&lt;/marker>\\n&lt;/ng2-map></code></pre>\\n          </div>\\n          <div *ngIf=\\\"tab1===2\\\">\\n            <pre><code class=\\\"language-markup\\\"\\n            >import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  template: require('./app.html')\\n&125;)\\nclass AppCompoment &123;\\n  log(marker, str) &123;\\n    console.log('event .... >', marker, str);\\n  &125;\\n&125;</code></pre>\\n          </div>\\n        </div>\\n      </div>\\n      \\n      <div class=\\\"spacer x3\\\"></div>\\n      <h2>Simple InfoWindow</h2>\\n      <div>\\n        <div class=\\\"tabs\\\">\\n          <div class=\\\"tab\\\" (click)=\\\"tab2=1\\\" [class.selected]=\\\"tab2===1\\\">html</div>\\n          <div class=\\\"tab\\\" (click)=\\\"tab2=2\\\" [class.selected]=\\\"tab2===2\\\">javascript</div>\\n        </div>\\n        <div class=\\\"tab-contents\\\">\\n          <div id=\\\"html\\\" *ngIf=\\\"tab2===1\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;ng2-map center=\\\"Brampton, Canada\\\">\\n  &lt;marker position=\\\"Brampton, Canada\\\" draggable=\\\"true\\\" (markerClick)=\\\"clicked($event)\\\">&lt;/marker>\\n  &lt;info-window id=\\\"iw\\\">\\n    lat: [[lat]], lng: [[lng]]\\n  &lt;/info-window>\\n&lt;/ng2-map></code></pre>\\n          </div>\\n          <div id=\\\"javascript\\\" *ngIf=\\\"tab2===2\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  template: require('./app.html')\\n&125;)\\nclass AppCompoment &123;\\n  clicked(marker) &123;\\n    marker.map.mapComponent.openInfoWindow('iw', marker, &123;\\n      lat: marker.getPosition().lat(), lng: marker.getPosition().lng()\\n    &125;)\\n  &125;\\n&125;</code></pre>\\n          </div>\\n        </div>\\n      </div>\\n     \\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], GoogleMapComponent);\n    return GoogleMapComponent;\n}());\nexports.GoogleMapComponent = GoogleMapComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvZ29vZ2xlLW1hcC5jb21wb25lbnQudHM/MjRlZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUNBQTBCLENBQWUsQ0FBQztBQWtKMUM7SUFBQTtRQUNFLGNBQVMsR0FBUyxFQUFFLENBQUM7UUFDckIsU0FBSSxHQUFXLENBQUMsQ0FBQztRQUNqQixTQUFJLEdBQVcsQ0FBQyxDQUFDO1FBQ2pCLFNBQUksR0FBVyxDQUFDLENBQUM7UUFDakIsU0FBSSxHQUFXLENBQUMsQ0FBQztJQW9CbkIsQ0FBQztJQW5CQyw0Q0FBZSxHQUFmO1FBQ0UsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUNELG9DQUFPLEdBQVAsVUFBUSxNQUFXO1FBQ2pCLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFO1lBQ25ELEdBQUcsRUFBRSxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxHQUFHLEVBQUU7U0FDakUsQ0FBQztJQUNKLENBQUM7SUFFRCw4Q0FBaUIsR0FBakI7UUFDRSxJQUFJLFNBQWlCLEVBQUUsU0FBaUIsQ0FBQztRQUV6QyxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUNwQixHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQ3ZCLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDO1lBQzFELFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO1lBQzdELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDOUMsQ0FBQztJQUNILENBQUM7SUF4S0g7UUFBQyxnQkFBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLHM2SkE2SUQ7U0FDVixDQUFDOzswQkFBQTtJQTBCRix5QkFBQztBQUFELENBQUM7QUF6QlksMEJBQWtCLHFCQXlCOUIiLCJmaWxlIjoiMzY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgcGFnZS10aXRsZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS9odG1sXCI+XG4gICAgICA8aDE+R29vZ2xlIE1hcDwvaDE+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgIFxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4M1wiPjwvZGl2PlxuICAgICAgPGgyPk1hcmtlcnMgd2l0aCAqbmdGb3I8L2gyPlxuICAgICAgICA8bmcyLW1hcCB6b29tPVwiMTNcIiBjZW50ZXI9XCJCcmFtcHRvbiwgQ2FuYWRhXCIgc2Nyb2xsd2hlZWw9XCJmYWxzZVwiPlxuICAgICAgICAgIDxtYXJrZXIgKm5nRm9yPVwibGV0IHBvcyBvZiBwb3NpdGlvbnNcIiBbcG9zaXRpb25dPVwicG9zXCI+PC9tYXJrZXI+XG4gICAgICAgIDwvbmcyLW1hcD5cbiAgICAgICAgPGJ1dHRvbiAoY2xpY2spPVwic2hvd1JhbmRvbU1hcmtlcnMoKVwiPlNob3cgUmFuZG9tIE1hcmtlcnM8L2J1dHRvbj5cbiAgICAgIDxkaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRhYlwiIChjbGljayk9XCJ0YWIzPTFcIiBbY2xhc3Muc2VsZWN0ZWRdPVwidGFiMz09PTFcIj5odG1sPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRhYlwiIChjbGljayk9XCJ0YWIzPTJcIiBbY2xhc3Muc2VsZWN0ZWRdPVwidGFiMz09PTJcIj5qYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgPGRpdiAqbmdJZj1cInRhYjM9PT0xXCI+XG4gICAgICAgICAgICA8cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7bmcyLW1hcCB6b29tPVwiMTNcIiBjZW50ZXI9XCJCcmFtcHRvbiwgQ2FuYWRhXCIgc2Nyb2xsd2hlZWw9XCJmYWxzZVwiPlxuICAmbHQ7bWFya2VyICpuZ0Zvcj1cImxldCBwb3Mgb2YgcG9zaXRpb25zXCIgW3Bvc2l0aW9uXT1cInBvc1wiPiZsdDsvbWFya2VyPlxuJmx0Oy9uZzItbWFwPlxuJmx0O2J1dHRvbiAoY2xpY2spPVwic2hvd1JhbmRvbU1hcmtlcnMoKVwiPlNob3cgUmFuZG9tIE1hcmtlcnMmbHQ7L2J1dHRvbj48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiAqbmdJZj1cInRhYjM9PT0yXCI+XG4gICAgICAgICAgICA8cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbiAgICAgICAgICAgID5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KCYxMjM7XG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL2FwcC5odG1sJylcbiYxMjU7KVxuY2xhc3MgQXBwQ29tcG9tZW50ICYxMjM7XG4gIHB1YmxpYyBwb3NpdGlvbnM9W107XG4gIFxuICBzaG93UmFuZG9tTWFya2VycygpICYxMjM7XG4gICAgbGV0IHJhbmRvbUxhdDogbnVtYmVyLCByYW5kb21Mbmc6IG51bWJlcjtcblxuICAgIHRoaXMucG9zaXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaT0wOyBpPDk7IGkrKykgJjEyMztcbiAgICAgIHJhbmRvbUxhdCA9IE1hdGgucmFuZG9tKCkgKiAoNDMuNzM5OSAtIDQzLjczMDApICsgNDMuNzMwMDtcbiAgICAgIHJhbmRvbUxuZyA9IE1hdGgucmFuZG9tKCkgKiAoLTc5Ljc2MDAgLSAtNzkuNzY5OSkgKyAtNzkuNzY5OTtcbiAgICAgIHRoaXMucG9zaXRpb25zLnB1c2goW3JhbmRvbUxhdCwgcmFuZG9tTG5nXSk7XG4gICAgJjEyNTtcbiAgJjEyNTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgXG4gICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyIHgzXCI+PC9kaXY+XG4gICAgICA8aDI+U2ltcGxlIE1hcDwvaDI+XG4gICAgICA8ZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJcIiAoY2xpY2spPVwidGFiND0xXCIgW2NsYXNzLnNlbGVjdGVkXT1cInRhYjQ9PT0xXCI+aHRtbDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJcIiAoY2xpY2spPVwidGFiND0yXCIgW2NsYXNzLnNlbGVjdGVkXT1cInRhYjQ9PT0yXCI+amF2YXNjcmlwdDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgIDxkaXYgKm5nSWY9XCJ0YWI0PT09MVwiPlxuICAgICAgICAgICAgPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4gICAgICAgICAgICA+Jmx0O25nMi1tYXAgY2VudGVyPVwiQnJhbXB0b24sIENhbmFkYVwiIHNjcm9sbHdoZWVsPVwiZmFsc2VcIj4mbHQ7L25nMi1tYXA+PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgKm5nSWY9XCJ0YWI0PT09MlwiPlxuICAgICAgICAgICAgPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4gICAgICAgICAgICA+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hcHAuaHRtbCcpXG4mMTI1OylcbmNsYXNzIEFwcENvbXBvbWVudCAmMTIzOyYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgICAgIFxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4M1wiPjwvZGl2PlxuICAgICAgPGgyPlNpbXBsZSBNYXJrZXI8L2gyPlxuICAgICAgPGRpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiXCIgKGNsaWNrKT1cInRhYjE9MVwiIFtjbGFzcy5zZWxlY3RlZF09XCJ0YWIxPT09MVwiPmh0bWw8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiXCIgKGNsaWNrKT1cInRhYjE9MlwiIFtjbGFzcy5zZWxlY3RlZF09XCJ0YWIxPT09MlwiPmphdmFzY3JpcHQ8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWItY29udGVudHNcIj5cbiAgICAgICAgICA8ZGl2ICpuZ0lmPVwidGFiMT09PTFcIj5cbiAgICAgICAgICAgIDxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1tYXJrdXBcIj4mbHQ7bmcyLW1hcCBjZW50ZXI9XCJCcmFtcHRvbiwgQ2FuYWRhXCIgPlxuJmx0O21hcmtlciBwb3NpdGlvbj1cIkJyYW1wdG9uLCBDYW5hZGFcIlxuICAobWFya2VyRHJhZ3N0YXJ0KT1cImxvZygkZXZlbnQsICdkcmFnc3RhcnQnKVwiXG4gIChtYXJrZXJEcmFnZW5kKT1cImxvZygkZXZlbnQsICdkcmFnZW5kJylcIlxuICBkcmFnZ2FibGU9XCJ0cnVlXCI+Jmx0Oy9tYXJrZXI+XG4mbHQ7L25nMi1tYXA+PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgKm5nSWY9XCJ0YWIxPT09MlwiPlxuICAgICAgICAgICAgPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4gICAgICAgICAgICA+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9hcHAuaHRtbCcpXG4mMTI1OylcbmNsYXNzIEFwcENvbXBvbWVudCAmMTIzO1xuICBsb2cobWFya2VyLCBzdHIpICYxMjM7XG4gICAgY29uc29sZS5sb2coJ2V2ZW50IC4uLi4gPicsIG1hcmtlciwgc3RyKTtcbiAgJjEyNTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgXG4gICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyIHgzXCI+PC9kaXY+XG4gICAgICA8aDI+U2ltcGxlIEluZm9XaW5kb3c8L2gyPlxuICAgICAgPGRpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiXCIgKGNsaWNrKT1cInRhYjI9MVwiIFtjbGFzcy5zZWxlY3RlZF09XCJ0YWIyPT09MVwiPmh0bWw8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiXCIgKGNsaWNrKT1cInRhYjI9MlwiIFtjbGFzcy5zZWxlY3RlZF09XCJ0YWIyPT09MlwiPmphdmFzY3JpcHQ8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWItY29udGVudHNcIj5cbiAgICAgICAgICA8ZGl2IGlkPVwiaHRtbFwiICpuZ0lmPVwidGFiMj09PTFcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1tYXJrdXBcIlxuPiZsdDtuZzItbWFwIGNlbnRlcj1cIkJyYW1wdG9uLCBDYW5hZGFcIj5cbiAgJmx0O21hcmtlciBwb3NpdGlvbj1cIkJyYW1wdG9uLCBDYW5hZGFcIiBkcmFnZ2FibGU9XCJ0cnVlXCIgKG1hcmtlckNsaWNrKT1cImNsaWNrZWQoJGV2ZW50KVwiPiZsdDsvbWFya2VyPlxuICAmbHQ7aW5mby13aW5kb3cgaWQ9XCJpd1wiPlxuICAgIGxhdDogW1tsYXRdXSwgbG5nOiBbW2xuZ11dXG4gICZsdDsvaW5mby13aW5kb3c+XG4mbHQ7L25nMi1tYXA+PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgaWQ9XCJqYXZhc2NyaXB0XCIgKm5nSWY9XCJ0YWIyPT09MlwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLWphdmFzY3JpcHRcIlxuPmltcG9ydCAmMTIzOyBDb21wb25lbnQgJjEyNTsgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoJjEyMztcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vYXBwLmh0bWwnKVxuJjEyNTspXG5jbGFzcyBBcHBDb21wb21lbnQgJjEyMztcbiAgY2xpY2tlZChtYXJrZXIpICYxMjM7XG4gICAgbWFya2VyLm1hcC5tYXBDb21wb25lbnQub3BlbkluZm9XaW5kb3coJ2l3JywgbWFya2VyLCAmMTIzO1xuICAgICAgbGF0OiBtYXJrZXIuZ2V0UG9zaXRpb24oKS5sYXQoKSwgbG5nOiBtYXJrZXIuZ2V0UG9zaXRpb24oKS5sbmcoKVxuICAgICYxMjU7KVxuICAmMTI1O1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgIFxuICAgIDwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgR29vZ2xlTWFwQ29tcG9uZW50IHtcbiAgcG9zaXRpb25zOiBhbnlbXSA9W107XG4gIHRhYjE6IG51bWJlciA9IDE7XG4gIHRhYjI6IG51bWJlciA9IDE7XG4gIHRhYjM6IG51bWJlciA9IDE7XG4gIHRhYjQ6IG51bWJlciA9IDE7XG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsMCk7XG4gIH1cbiAgY2xpY2tlZChtYXJrZXI6IGFueSk6IHZvaWQge1xuICAgIG1hcmtlci5tYXAubWFwQ29tcG9uZW50Lm9wZW5JbmZvV2luZG93KCdpdycsIG1hcmtlciwge1xuICAgICAgbGF0OiBtYXJrZXIuZ2V0UG9zaXRpb24oKS5sYXQoKSwgbG5nOiBtYXJrZXIuZ2V0UG9zaXRpb24oKS5sbmcoKVxuICAgIH0pXG4gIH1cblxuICBzaG93UmFuZG9tTWFya2VycygpIHtcbiAgICBsZXQgcmFuZG9tTGF0OiBudW1iZXIsIHJhbmRvbUxuZzogbnVtYmVyO1xuXG4gICAgdGhpcy5wb3NpdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8OTsgaSsrKSB7XG4gICAgICByYW5kb21MYXQgPSBNYXRoLnJhbmRvbSgpICogKDQzLjczOTkgLSA0My43MzAwKSArIDQzLjczMDA7XG4gICAgICByYW5kb21MbmcgPSBNYXRoLnJhbmRvbSgpICogKC03OS43NjAwIC0gLTc5Ljc2OTkpICsgLTc5Ljc2OTk7XG4gICAgICB0aGlzLnBvc2l0aW9ucy5wdXNoKFtyYW5kb21MYXQsIHJhbmRvbUxuZ10pO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9uZzItdWktY29tcG9uZW50cy9nb29nbGUtbWFwLmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 367:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar InfiniteListComponent = (function () {\n    function InfiniteListComponent() {\n        this.set1 = {\n            limit: 10, offset: 0, endOfList: false, loadingInProgress: false, list: []\n        };\n        this.set2 = {\n            limit: 10, offset: 0, endOfList: false, loadingInProgress: false, list: []\n        };\n    }\n    InfiniteListComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    InfiniteListComponent.prototype.loadMore = function (data) {\n        if (!data.loadingInProgress) {\n            if (data.offset > 99) {\n                data.endOfList = true;\n            }\n            else {\n                setTimeout(function () { return data.loadingInProgress = true; });\n                setTimeout(function () {\n                    var max = data.offset + data.limit;\n                    for (var i = data.offset; i < max; i++) {\n                        data.list.push(i);\n                    }\n                    data.offset = max;\n                    data.loadingInProgress = false;\n                }, 1000);\n            }\n        }\n    };\n    InfiniteListComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\" xmlns=\\\"http://www.w3.org/1999/html\\\">\\n      <h1>Infinite List</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n    \\n      <h2>Vertically</h2>\\n      <ul ng2-infinite-list  class=\\\"infinite-list\\\"\\n          (endVisible)=\\\"loadMore(set1)\\\">\\n        <li *ngFor=\\\"let item of set1.list\\\">{{item+1}}</li>\\n        <div ng2-infinite-list-end>\\n          <div *ngIf=\\\"set1.loadingInProgress\\\">Loading</div>\\n          <div *ngIf=\\\"set1.endOfList\\\">End Of List</div>\\n        </div>\\n      </ul>\\n      loading in progress : {{set1.loadingInProgress}};\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;ul ng2-infinite-list  class=\\\"infinite-list\\\"\\n          (endVisible)=\\\"loadMore(set1)\\\">\\n        &lt;li *ngFor=\\\"let item of set1.list\\\">&123;&123;item+1&125;&125;&lt;/li>\\n        &lt;div ng2-infinite-list-end>\\n          &lt;div *ngIf=\\\"set1.loadingInProgress\\\">Loading&lt;/div>\\n          &lt;div *ngIf=\\\"set1.endOfList\\\">End Of List&lt;/div>\\n        &lt;/div>\\n      &lt;/ul></code></pre>\\n           </div>\\n           <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templates: 'app.tpl.html'\\n&125;)  \\nexport class AppComponent &123;\\n\\n  set1: any = &123;\\n    limit: 10, offset: 0, endOfList: false, loadingInProgress: false, list: []\\n  &125;;\\n\\n  loadMore(data: any): void &123;\\n    if (!data.loadingInProgress) &123;\\n      if (data.offset > 99) &123;    // detect the end of list\\n        data.endOfList = true;\\n      &125; else &123;\\n        setTimeout(() => data.loadingInProgress = true);\\n        setTimeout(() => &123;      // mimics http call delay\\n          let max = data.offset + data.limit;\\n          for (let i = data.offset; i < max; i++) &123;\\n            data.list.push(i);\\n          &125;\\n          data.offset = max;\\n          data.loadingInProgress = false;\\n        &125;, 1000);\\n      &125;\\n    &125;\\n  &125;\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n    \\n      <div class=\\\"spacer x3\\\"></div>\\n      <h2>Horizontally</h2>\\n      <div ng2-infinite-list horizontal=\\\"true\\\"\\n           class=\\\"infinite-list horizontal\\\"\\n           (endVisible)=\\\"loadMore(set2)\\\">\\n        <div *ngFor=\\\"let item of set2.list\\\">{{item+1}}</div>\\n        <div ng2-infinite-list-end>\\n        &nbsp;\\n        <div *ngIf=\\\"set2.loadingInProgress\\\">Loading</div>\\n        <div *ngIf=\\\"set2.endOfList\\\">End Of List</div>\\n        </div>\\n      </div>\\n      loading in progress : {{set2.loadingInProgress}}      \\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;div ng2-infinite-list horizontal=\\\"true\\\"\\n           class=\\\"infinite-list horizontal\\\"\\n           (endVisible)=\\\"loadMore(set2)\\\">\\n        &lt;div *ngFor=\\\"let item of set2.list\\\">&123;&123;item+1&125;&125;&lt;/div>\\n        &lt;div ng2-infinite-list-end>\\n        &nbsp;\\n        &lt;div *ngIf=\\\"set2.loadingInProgress\\\">Loading&lt;/div>\\n        &lt;div *ngIf=\\\"set2.endOfList\\\">End Of List&lt;/div>\\n        &lt;/div>\\n      &lt;/div>\\n</code></pre>\\n           </div>\\n           <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templates: 'app.tpl.html'\\n&125;)  \\nexport class AppComponent &123;\\n\\n  set2: any = &123;\\n    limit: 10, offset: 0, endOfList: false, loadingInProgress: false, list: []\\n  &125;;\\n\\n  loadMore(data: any): void &123;\\n    if (!data.loadingInProgress) &123;\\n      if (data.offset > 99) &123;    // detect the end of list\\n        data.endOfList = true;\\n      &125; else &123;\\n        setTimeout(() => data.loadingInProgress = true);\\n        setTimeout(() => &123;      // mimics http call delay\\n          let max = data.offset + data.limit;\\n          for (let i = data.offset; i < max; i++) &123;\\n            data.list.push(i);\\n          &125;\\n          data.offset = max;\\n          data.loadingInProgress = false;\\n        &125;, 1000);\\n      &125;\\n    &125;\\n  &125;\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n\",\n            styles: [\"\\n    .infinite-list {\\n      overflow: auto;\\n      border: 5px solid #999;\\n      height: 200px;\\n      position: relative;\\n    }\\n    .infinite-list > * {\\n      min-height: 20px\\n    }\\n\\n    .infinite-list > *:nth-child(odd) {\\n      background-color: #eee\\n    }\\n\\n    .infinite-list.horizontal {\\n      height: 120px;\\n      white-space: nowrap;\\n      overflow-y: hidden;\\n    }\\n    .infinite-list.horizontal > div {\\n      border: 1px solid #666;\\n      width: 50px;\\n      height: 80px;\\n      display: inline-block;\\n      margin: 10px;\\n      vertical-align: top;\\n    }\"]\n        }), \n        __metadata('design:paramtypes', [])\n    ], InfiniteListComponent);\n    return InfiniteListComponent;\n}());\nexports.InfiniteListComponent = InfiniteListComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvaW5maW5pdGUtbGlzdC5jb21wb25lbnQudHM/NWE5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUNBQTBCLENBQWUsQ0FBQztBQXdLMUM7SUFBQTtRQUVFLFNBQUksR0FBUTtZQUNWLEtBQUssRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRTtTQUMzRSxDQUFDO1FBRUYsU0FBSSxHQUFRO1lBQ1YsS0FBSyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsaUJBQWlCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFO1NBQzNFLENBQUM7SUF1QkosQ0FBQztJQXJCQywrQ0FBZSxHQUFmO1FBQ0UsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUVELHdDQUFRLEdBQVIsVUFBUyxJQUFTO1FBQ2hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUM1QixFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1lBQ3hCLENBQUM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFDTixVQUFVLENBQUMsY0FBTSxXQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxFQUE3QixDQUE2QixDQUFDLENBQUM7Z0JBQ2hELFVBQVUsQ0FBQztvQkFDVCxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7b0JBQ25DLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO3dCQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDcEIsQ0FBQztvQkFDRCxJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztvQkFDbEIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQztnQkFDakMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ1gsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDO0lBcE1IO1FBQUMsZ0JBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxpL0lBdUlYO1lBQ0MsTUFBTSxFQUFFLENBQUMsMmtCQTJCTCxDQUFDO1NBQ04sQ0FBQzs7NkJBQUE7SUFnQ0YsNEJBQUM7QUFBRCxDQUFDO0FBL0JZLDZCQUFxQix3QkErQmpDIiwiZmlsZSI6IjM2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHBhZ2UtdGl0bGVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvaHRtbFwiPlxuICAgICAgPGgxPkluZmluaXRlIExpc3Q8L2gxPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICBcbiAgICAgIDxoMj5WZXJ0aWNhbGx5PC9oMj5cbiAgICAgIDx1bCBuZzItaW5maW5pdGUtbGlzdCAgY2xhc3M9XCJpbmZpbml0ZS1saXN0XCJcbiAgICAgICAgICAoZW5kVmlzaWJsZSk9XCJsb2FkTW9yZShzZXQxKVwiPlxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGl0ZW0gb2Ygc2V0MS5saXN0XCI+e3tpdGVtKzF9fTwvbGk+XG4gICAgICAgIDxkaXYgbmcyLWluZmluaXRlLWxpc3QtZW5kPlxuICAgICAgICAgIDxkaXYgKm5nSWY9XCJzZXQxLmxvYWRpbmdJblByb2dyZXNzXCI+TG9hZGluZzwvZGl2PlxuICAgICAgICAgIDxkaXYgKm5nSWY9XCJzZXQxLmVuZE9mTGlzdFwiPkVuZCBPZiBMaXN0PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC91bD5cbiAgICAgIGxvYWRpbmcgaW4gcHJvZ3Jlc3MgOiB7e3NldDEubG9hZGluZ0luUHJvZ3Jlc3N9fTtcbiAgICAgIDxuZzItdGFiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O3VsIG5nMi1pbmZpbml0ZS1saXN0ICBjbGFzcz1cImluZmluaXRlLWxpc3RcIlxuICAgICAgICAgIChlbmRWaXNpYmxlKT1cImxvYWRNb3JlKHNldDEpXCI+XG4gICAgICAgICZsdDtsaSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBzZXQxLmxpc3RcIj4mMTIzOyYxMjM7aXRlbSsxJjEyNTsmMTI1OyZsdDsvbGk+XG4gICAgICAgICZsdDtkaXYgbmcyLWluZmluaXRlLWxpc3QtZW5kPlxuICAgICAgICAgICZsdDtkaXYgKm5nSWY9XCJzZXQxLmxvYWRpbmdJblByb2dyZXNzXCI+TG9hZGluZyZsdDsvZGl2PlxuICAgICAgICAgICZsdDtkaXYgKm5nSWY9XCJzZXQxLmVuZE9mTGlzdFwiPkVuZCBPZiBMaXN0Jmx0Oy9kaXY+XG4gICAgICAgICZsdDsvZGl2PlxuICAgICAgJmx0Oy91bD48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KCYxMjM7XG4gIHRlbXBsYXRlczogJ2FwcC50cGwuaHRtbCdcbiYxMjU7KSAgXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50ICYxMjM7XG5cbiAgc2V0MTogYW55ID0gJjEyMztcbiAgICBsaW1pdDogMTAsIG9mZnNldDogMCwgZW5kT2ZMaXN0OiBmYWxzZSwgbG9hZGluZ0luUHJvZ3Jlc3M6IGZhbHNlLCBsaXN0OiBbXVxuICAmMTI1OztcblxuICBsb2FkTW9yZShkYXRhOiBhbnkpOiB2b2lkICYxMjM7XG4gICAgaWYgKCFkYXRhLmxvYWRpbmdJblByb2dyZXNzKSAmMTIzO1xuICAgICAgaWYgKGRhdGEub2Zmc2V0ID4gOTkpICYxMjM7ICAgIC8vIGRldGVjdCB0aGUgZW5kIG9mIGxpc3RcbiAgICAgICAgZGF0YS5lbmRPZkxpc3QgPSB0cnVlO1xuICAgICAgJjEyNTsgZWxzZSAmMTIzO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGRhdGEubG9hZGluZ0luUHJvZ3Jlc3MgPSB0cnVlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiAmMTIzOyAgICAgIC8vIG1pbWljcyBodHRwIGNhbGwgZGVsYXlcbiAgICAgICAgICBsZXQgbWF4ID0gZGF0YS5vZmZzZXQgKyBkYXRhLmxpbWl0O1xuICAgICAgICAgIGZvciAobGV0IGkgPSBkYXRhLm9mZnNldDsgaSA8IG1heDsgaSsrKSAmMTIzO1xuICAgICAgICAgICAgZGF0YS5saXN0LnB1c2goaSk7XG4gICAgICAgICAgJjEyNTtcbiAgICAgICAgICBkYXRhLm9mZnNldCA9IG1heDtcbiAgICAgICAgICBkYXRhLmxvYWRpbmdJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICYxMjU7LCAxMDAwKTtcbiAgICAgICYxMjU7XG4gICAgJjEyNTtcbiAgJjEyNTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgIFxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4M1wiPjwvZGl2PlxuICAgICAgPGgyPkhvcml6b250YWxseTwvaDI+XG4gICAgICA8ZGl2IG5nMi1pbmZpbml0ZS1saXN0IGhvcml6b250YWw9XCJ0cnVlXCJcbiAgICAgICAgICAgY2xhc3M9XCJpbmZpbml0ZS1saXN0IGhvcml6b250YWxcIlxuICAgICAgICAgICAoZW5kVmlzaWJsZSk9XCJsb2FkTW9yZShzZXQyKVwiPlxuICAgICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIHNldDIubGlzdFwiPnt7aXRlbSsxfX08L2Rpdj5cbiAgICAgICAgPGRpdiBuZzItaW5maW5pdGUtbGlzdC1lbmQ+XG4gICAgICAgICZuYnNwO1xuICAgICAgICA8ZGl2ICpuZ0lmPVwic2V0Mi5sb2FkaW5nSW5Qcm9ncmVzc1wiPkxvYWRpbmc8L2Rpdj5cbiAgICAgICAgPGRpdiAqbmdJZj1cInNldDIuZW5kT2ZMaXN0XCI+RW5kIE9mIExpc3Q8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIGxvYWRpbmcgaW4gcHJvZ3Jlc3MgOiB7e3NldDIubG9hZGluZ0luUHJvZ3Jlc3N9fSAgICAgIFxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7ZGl2IG5nMi1pbmZpbml0ZS1saXN0IGhvcml6b250YWw9XCJ0cnVlXCJcbiAgICAgICAgICAgY2xhc3M9XCJpbmZpbml0ZS1saXN0IGhvcml6b250YWxcIlxuICAgICAgICAgICAoZW5kVmlzaWJsZSk9XCJsb2FkTW9yZShzZXQyKVwiPlxuICAgICAgICAmbHQ7ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIHNldDIubGlzdFwiPiYxMjM7JjEyMztpdGVtKzEmMTI1OyYxMjU7Jmx0Oy9kaXY+XG4gICAgICAgICZsdDtkaXYgbmcyLWluZmluaXRlLWxpc3QtZW5kPlxuICAgICAgICAmbmJzcDtcbiAgICAgICAgJmx0O2RpdiAqbmdJZj1cInNldDIubG9hZGluZ0luUHJvZ3Jlc3NcIj5Mb2FkaW5nJmx0Oy9kaXY+XG4gICAgICAgICZsdDtkaXYgKm5nSWY9XCJzZXQyLmVuZE9mTGlzdFwiPkVuZCBPZiBMaXN0Jmx0Oy9kaXY+XG4gICAgICAgICZsdDsvZGl2PlxuICAgICAgJmx0Oy9kaXY+XG48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KCYxMjM7XG4gIHRlbXBsYXRlczogJ2FwcC50cGwuaHRtbCdcbiYxMjU7KSAgXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50ICYxMjM7XG5cbiAgc2V0MjogYW55ID0gJjEyMztcbiAgICBsaW1pdDogMTAsIG9mZnNldDogMCwgZW5kT2ZMaXN0OiBmYWxzZSwgbG9hZGluZ0luUHJvZ3Jlc3M6IGZhbHNlLCBsaXN0OiBbXVxuICAmMTI1OztcblxuICBsb2FkTW9yZShkYXRhOiBhbnkpOiB2b2lkICYxMjM7XG4gICAgaWYgKCFkYXRhLmxvYWRpbmdJblByb2dyZXNzKSAmMTIzO1xuICAgICAgaWYgKGRhdGEub2Zmc2V0ID4gOTkpICYxMjM7ICAgIC8vIGRldGVjdCB0aGUgZW5kIG9mIGxpc3RcbiAgICAgICAgZGF0YS5lbmRPZkxpc3QgPSB0cnVlO1xuICAgICAgJjEyNTsgZWxzZSAmMTIzO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGRhdGEubG9hZGluZ0luUHJvZ3Jlc3MgPSB0cnVlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiAmMTIzOyAgICAgIC8vIG1pbWljcyBodHRwIGNhbGwgZGVsYXlcbiAgICAgICAgICBsZXQgbWF4ID0gZGF0YS5vZmZzZXQgKyBkYXRhLmxpbWl0O1xuICAgICAgICAgIGZvciAobGV0IGkgPSBkYXRhLm9mZnNldDsgaSA8IG1heDsgaSsrKSAmMTIzO1xuICAgICAgICAgICAgZGF0YS5saXN0LnB1c2goaSk7XG4gICAgICAgICAgJjEyNTtcbiAgICAgICAgICBkYXRhLm9mZnNldCA9IG1heDtcbiAgICAgICAgICBkYXRhLmxvYWRpbmdJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICYxMjU7LCAxMDAwKTtcbiAgICAgICYxMjU7XG4gICAgJjEyNTtcbiAgJjEyNTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuYCxcbiAgc3R5bGVzOiBbYFxuICAgIC5pbmZpbml0ZS1saXN0IHtcbiAgICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgYm9yZGVyOiA1cHggc29saWQgIzk5OTtcbiAgICAgIGhlaWdodDogMjAwcHg7XG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICAgIC5pbmZpbml0ZS1saXN0ID4gKiB7XG4gICAgICBtaW4taGVpZ2h0OiAyMHB4XG4gICAgfVxuXG4gICAgLmluZmluaXRlLWxpc3QgPiAqOm50aC1jaGlsZChvZGQpIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWVcbiAgICB9XG5cbiAgICAuaW5maW5pdGUtbGlzdC5ob3Jpem9udGFsIHtcbiAgICAgIGhlaWdodDogMTIwcHg7XG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgIH1cbiAgICAuaW5maW5pdGUtbGlzdC5ob3Jpem9udGFsID4gZGl2IHtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICM2NjY7XG4gICAgICB3aWR0aDogNTBweDtcbiAgICAgIGhlaWdodDogODBweDtcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIG1hcmdpbjogMTBweDtcbiAgICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XG4gICAgfWBdXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlTGlzdENvbXBvbmVudCB7XG5cbiAgc2V0MTogYW55ID0ge1xuICAgIGxpbWl0OiAxMCwgb2Zmc2V0OiAwLCBlbmRPZkxpc3Q6IGZhbHNlLCBsb2FkaW5nSW5Qcm9ncmVzczogZmFsc2UsIGxpc3Q6IFtdXG4gIH07XG5cbiAgc2V0MjogYW55ID0ge1xuICAgIGxpbWl0OiAxMCwgb2Zmc2V0OiAwLCBlbmRPZkxpc3Q6IGZhbHNlLCBsb2FkaW5nSW5Qcm9ncmVzczogZmFsc2UsIGxpc3Q6IFtdXG4gIH07XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHdpbmRvdy5zY3JvbGwoMCwwKTtcbiAgfVxuXG4gIGxvYWRNb3JlKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIGlmICghZGF0YS5sb2FkaW5nSW5Qcm9ncmVzcykge1xuICAgICAgaWYgKGRhdGEub2Zmc2V0ID4gOTkpIHsgICAgLy8gZGV0ZWN0IHRoZSBlbmQgb2YgbGlzdFxuICAgICAgICBkYXRhLmVuZE9mTGlzdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGRhdGEubG9hZGluZ0luUHJvZ3Jlc3MgPSB0cnVlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7ICAgICAgLy8gbWltaWNzIGh0dHAgY2FsbCBkZWxheVxuICAgICAgICAgIGxldCBtYXggPSBkYXRhLm9mZnNldCArIGRhdGEubGltaXQ7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGRhdGEub2Zmc2V0OyBpIDwgbWF4OyBpKyspIHtcbiAgICAgICAgICAgIGRhdGEubGlzdC5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLm9mZnNldCA9IG1heDtcbiAgICAgICAgICBkYXRhLmxvYWRpbmdJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9uZzItdWktY29tcG9uZW50cy9pbmZpbml0ZS1saXN0LmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 368:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar ng2_ui_1 = __webpack_require__(58);\nvar OverlayComponent = (function () {\n    function OverlayComponent(overlayManager) {\n        this.overlayManager = overlayManager;\n    }\n    OverlayComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    OverlayComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Overlay</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n      <p class=\\\"page-title-description\\\">\\n        Overlay is an on-the-top layer over DOM elements. Commonly this is used to have some feature to show on the top \\n        of html or an element and to disappear when action is taken.\\n      </p>\\n      \\n      For example\\n      <ol>\\n        <li>Loading Sign</li>\\n        <li>Tooltip</li>\\n        <li>Hover Effect</li>\\n        <li>Etc</li>\\n      </ol>\\n      \\n      <h2>Window Overlay - Modal</h2>\\n      <div id=\\\"window-loading\\\" ng2-overlay-of=\\\"window\\\">\\n        <div style=\\\"color:#fff\\\">Loading</div>\\n        <button (click)=\\\"overlayManager.close('window-loading')\\\">Close</button>\\n      </div>\\n      <button (click)=\\\"overlayManager.open('window-loading')\\\">Show Loading For Window</button>\\n      \\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [ng2_ui_1.OverlayManager])\n    ], OverlayComponent);\n    return OverlayComponent;\n}());\nexports.OverlayComponent = OverlayComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvb3ZlcmxheS5jb21wb25lbnQudHM/NjNjNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUNBQTBCLENBQWUsQ0FBQztBQUMxQyxtQ0FBZ0MsRUFBUSxDQUFDO0FBOEJ6QztJQUNFLDBCQUFtQixjQUE4QjtRQUE5QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7SUFBRyxDQUFDO0lBRXJELDBDQUFlLEdBQWY7UUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBakNIO1FBQUMsZ0JBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSw2M0JBeUJEO1NBQ1YsQ0FBQzs7d0JBQUE7SUFPRix1QkFBQztBQUFELENBQUM7QUFOWSx3QkFBZ0IsbUJBTTVCIiwiZmlsZSI6IjM2OC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgIE92ZXJsYXlNYW5hZ2VyIH0gZnJvbSAnbmcyLXVpJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBwYWdlLXRpdGxlXCI+XG4gICAgICA8aDE+T3ZlcmxheTwvaDE+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgPHAgY2xhc3M9XCJwYWdlLXRpdGxlLWRlc2NyaXB0aW9uXCI+XG4gICAgICAgIE92ZXJsYXkgaXMgYW4gb24tdGhlLXRvcCBsYXllciBvdmVyIERPTSBlbGVtZW50cy4gQ29tbW9ubHkgdGhpcyBpcyB1c2VkIHRvIGhhdmUgc29tZSBmZWF0dXJlIHRvIHNob3cgb24gdGhlIHRvcCBcbiAgICAgICAgb2YgaHRtbCBvciBhbiBlbGVtZW50IGFuZCB0byBkaXNhcHBlYXIgd2hlbiBhY3Rpb24gaXMgdGFrZW4uXG4gICAgICA8L3A+XG4gICAgICBcbiAgICAgIEZvciBleGFtcGxlXG4gICAgICA8b2w+XG4gICAgICAgIDxsaT5Mb2FkaW5nIFNpZ248L2xpPlxuICAgICAgICA8bGk+VG9vbHRpcDwvbGk+XG4gICAgICAgIDxsaT5Ib3ZlciBFZmZlY3Q8L2xpPlxuICAgICAgICA8bGk+RXRjPC9saT5cbiAgICAgIDwvb2w+XG4gICAgICBcbiAgICAgIDxoMj5XaW5kb3cgT3ZlcmxheSAtIE1vZGFsPC9oMj5cbiAgICAgIDxkaXYgaWQ9XCJ3aW5kb3ctbG9hZGluZ1wiIG5nMi1vdmVybGF5LW9mPVwid2luZG93XCI+XG4gICAgICAgIDxkaXYgc3R5bGU9XCJjb2xvcjojZmZmXCI+TG9hZGluZzwvZGl2PlxuICAgICAgICA8YnV0dG9uIChjbGljayk9XCJvdmVybGF5TWFuYWdlci5jbG9zZSgnd2luZG93LWxvYWRpbmcnKVwiPkNsb3NlPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxidXR0b24gKGNsaWNrKT1cIm92ZXJsYXlNYW5hZ2VyLm9wZW4oJ3dpbmRvdy1sb2FkaW5nJylcIj5TaG93IExvYWRpbmcgRm9yIFdpbmRvdzwvYnV0dG9uPlxuICAgICAgXG4gICAgPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBPdmVybGF5Q29tcG9uZW50e1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgb3ZlcmxheU1hbmFnZXI6IE92ZXJsYXlNYW5hZ2VyKSB7fVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsMCk7XG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9uZzItdWktY29tcG9uZW50cy9vdmVybGF5LmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 369:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar ParallaxScrollComponent = (function () {\n    function ParallaxScrollComponent() {\n    }\n    ParallaxScrollComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    ParallaxScrollComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Parallax Scroll</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n      <div style=\\\"height: 400px\\\"> \\n        <p>\\n          <b>Parallax scrolling</b> is a scrolling technique used computer graphics\\n          in which background images move more slowly than images in the foreground, \\n          creating the illusion of depth and immersion.\\n        </p>\\n        <p>\\n          scroll up/down and see how image changes.\\n          To see the proper parallax effect, the container window\\n          should be smaller than the image behind.\\n        </p>\\n      </div>\\n      <div ng2-parallax style=\\\"height: 400px\\\">\\n        <img src=\\\"http://materializecss.com/images/parallax1.jpg\\\" />\\n      </div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;div ng2-parallax style=\\\"height: 400px\\\">\\n  &lt;img src=\\\"http://materializecss.com/images/parallax1.jpg\\\" />\\n&lt;/div>\\n</code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n         </div>\\n      </ng2-tab>\\n      <br/>\\n      <br/>\\n      <div ng2-parallax style=\\\"height: 400px\\\">\\n        <img src=\\\"http://materializecss.com/images/parallax2.jpg\\\" />\\n      </div>\\n      <div style=\\\"height: 400px\\\">\\n         This space is intentionally added for scrolling\\n      </div>\\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], ParallaxScrollComponent);\n    return ParallaxScrollComponent;\n}());\nexports.ParallaxScrollComponent = ParallaxScrollComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvcGFyYWxsYXgtc2Nyb2xsLmNvbXBvbmVudC50cz83NDkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBMEIsQ0FBZSxDQUFDO0FBMEQxQztJQUFBO0lBSUEsQ0FBQztJQUhDLGlEQUFlLEdBQWY7UUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBM0RIO1FBQUMsZ0JBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxpdURBcUREO1NBQ1YsQ0FBQzs7K0JBQUE7SUFLRiw4QkFBQztBQUFELENBQUM7QUFKWSwrQkFBdUIsMEJBSW5DIiwiZmlsZSI6IjM2OS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHBhZ2UtdGl0bGVcIj5cbiAgICAgIDxoMT5QYXJhbGxheCBTY3JvbGw8L2gxPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICAgIDxkaXYgc3R5bGU9XCJoZWlnaHQ6IDQwMHB4XCI+IFxuICAgICAgICA8cD5cbiAgICAgICAgICA8Yj5QYXJhbGxheCBzY3JvbGxpbmc8L2I+IGlzIGEgc2Nyb2xsaW5nIHRlY2huaXF1ZSB1c2VkIGNvbXB1dGVyIGdyYXBoaWNzXG4gICAgICAgICAgaW4gd2hpY2ggYmFja2dyb3VuZCBpbWFnZXMgbW92ZSBtb3JlIHNsb3dseSB0aGFuIGltYWdlcyBpbiB0aGUgZm9yZWdyb3VuZCwgXG4gICAgICAgICAgY3JlYXRpbmcgdGhlIGlsbHVzaW9uIG9mIGRlcHRoIGFuZCBpbW1lcnNpb24uXG4gICAgICAgIDwvcD5cbiAgICAgICAgPHA+XG4gICAgICAgICAgc2Nyb2xsIHVwL2Rvd24gYW5kIHNlZSBob3cgaW1hZ2UgY2hhbmdlcy5cbiAgICAgICAgICBUbyBzZWUgdGhlIHByb3BlciBwYXJhbGxheCBlZmZlY3QsIHRoZSBjb250YWluZXIgd2luZG93XG4gICAgICAgICAgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiB0aGUgaW1hZ2UgYmVoaW5kLlxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgbmcyLXBhcmFsbGF4IHN0eWxlPVwiaGVpZ2h0OiA0MDBweFwiPlxuICAgICAgICA8aW1nIHNyYz1cImh0dHA6Ly9tYXRlcmlhbGl6ZWNzcy5jb20vaW1hZ2VzL3BhcmFsbGF4MS5qcGdcIiAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8bmcyLXRhYj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImh0bWxcIj5IVE1MPC9kaXY+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJqc1wiPkphdmFzY3JpcHQ8L2Rpdj5cbiAgICAgICAgIDwvZGl2PiBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWItY29udGVudHNcIj5cbiAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImh0bWxcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1tYXJrdXBcIlxuPiZsdDtkaXYgbmcyLXBhcmFsbGF4IHN0eWxlPVwiaGVpZ2h0OiA0MDBweFwiPlxuICAmbHQ7aW1nIHNyYz1cImh0dHA6Ly9tYXRlcmlhbGl6ZWNzcy5jb20vaW1hZ2VzL3BhcmFsbGF4MS5qcGdcIiAvPlxuJmx0Oy9kaXY+XG48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmcyLXRhYj5cbiAgICAgIDxici8+XG4gICAgICA8YnIvPlxuICAgICAgPGRpdiBuZzItcGFyYWxsYXggc3R5bGU9XCJoZWlnaHQ6IDQwMHB4XCI+XG4gICAgICAgIDxpbWcgc3JjPVwiaHR0cDovL21hdGVyaWFsaXplY3NzLmNvbS9pbWFnZXMvcGFyYWxsYXgyLmpwZ1wiIC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgc3R5bGU9XCJoZWlnaHQ6IDQwMHB4XCI+XG4gICAgICAgICBUaGlzIHNwYWNlIGlzIGludGVudGlvbmFsbHkgYWRkZWQgZm9yIHNjcm9sbGluZ1xuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBQYXJhbGxheFNjcm9sbENvbXBvbmVudCB7XG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsMCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvcGFyYWxsYXgtc2Nyb2xsLmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 370:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar ng2_ui_1 = __webpack_require__(58);\nvar CustomPopupComponent = (function () {\n    function CustomPopupComponent() {\n        this.number = 0;\n    }\n    CustomPopupComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <p>This is custom popup</p>\\n    {{number}} <button (click)=\\\"number = number+1\\\">increase number</button><br/>\\n    <button (click)=\\\"popup.close()\\\">close</button>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], CustomPopupComponent);\n    return CustomPopupComponent;\n}());\nvar PopupComponent = (function () {\n    function PopupComponent() {\n    }\n    PopupComponent.prototype.ngafterviewinit = function () {\n        window.scroll(0, 0);\n    };\n    PopupComponent.prototype.openPopup = function (size, title) {\n        var _this = this;\n        this.popup.open(ng2_ui_1.Ng2MessagePopupComponent, {\n            classNames: size,\n            title: title,\n            message: \"This is message given using popup.open()\",\n            buttons: {\n                OK: function () {\n                    _this.message = \"Ok button is pressed\";\n                },\n                CANCEL: function () {\n                    _this.message = \"Cancel button is pressed\";\n                    _this.popup.close();\n                }\n            }\n        });\n    };\n    PopupComponent.prototype.openCustomPopup = function () {\n        this.popup.open(CustomPopupComponent, {\n            classNames: 'custom',\n            closeButton: false,\n        });\n    };\n    __decorate([\n        core_1.ViewChild(ng2_ui_1.Ng2PopupComponent), \n        __metadata('design:type', ng2_ui_1.Ng2PopupComponent)\n    ], PopupComponent.prototype, \"popup\", void 0);\n    PopupComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Popup</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n    \\n      <ng2-popup #popup></ng2-popup>\\n      <br/>\\n      {{message}}\\n      <br/>\\n      \\n      <button (click)=\\\"openPopup('small', 'Hello Small Popup')\\\">open small message popup</button>\\n      <br/>\\n      <button (click)=\\\"openPopup('medium', 'Hello Medium Popup')\\\">open medium message popup</button>\\n      <br/>\\n      <div class=\\\"spacer\\\"></div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;button (click)=\\\"openPopup('small', 'Hello Small Popup')\\\">open small message popup&lt;/button>\\n&lt;br/>\\n&lt;button (click)=\\\"openPopup('medium', 'Hello Medium Popup')\\\">open medium message popup&lt;/button>\\n&lt;br/>\\n&lt;ng2-popup #popup>&lt;/ng2-popup></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123;Component, ViewChild&125; from '@angular/core';\\nimport &123; Ng2PopupComponent, Ng2MessagePopupComponent &125; from 'ng2-ui';\\n\\nexport class popupcomponent &123;\\n  @ViewChild(Ng2PopupComponent) popup: Ng2PopupComponent;\\n  message: string;\\n\\n  openPopup(size, title) &123;\\n    this.popup.open(Ng2MessagePopupComponent, &123;\\n      classNames: size,\\n      title: title,\\n      message: \\\"This is message given using popup.open()\\\",\\n      buttons: &123;\\n        OK: () => &123;\\n          this.message = \\\"Ok button is pressed\\\";\\n        &125;,\\n        CANCEL: () => &123;\\n          this.message = \\\"Cancel button is pressed\\\";\\n          this.popup.close();\\n        &125;\\n      &125;\\n    &125;);\\n  &125;\\n&125;</code></pre>\\n          </div>\\n         </div>\\n      </ng2-tab>\\n      \\n      <div class=\\\"spacer\\\"></div>\\n      <button (click)=\\\"openCustomPopup()\\\">open custom popup</button>\\n      <br/>\\n      <div class=\\\"spacer\\\"></div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;button (click)=\\\"openCustomPopup()\\\">open custom popup&lt;/button>\\n&lt;br/>\\n&lt;ng2-popup #popup>&lt;/ng2-popup></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123;Component, ViewChild&125; from '@angular/core';\\nimport &123; Ng2PopupComponent &125; from 'ng2-ui';\\n\\n@Component(&123;\\n  template: `\\n  &lt;p>This is custom popup&lt;/p>\\n  \\\\&123;\\\\&123;number\\\\&125;\\\\&125; &lt;button (click)=\\\"number = number+1\\\">increase number&lt;/button>&lt;br/>\\n  &lt;button (click)=\\\"popup.close()\\\">close&lt;/button>\\n  `\\n&125;)\\nclass CustomPopupComponent &123;\\n  number: number = 0;\\n&125;\\n\\nexport class popupcomponent &123;\\n  @ViewChild(Ng2PopupComponent) popup: Ng2PopupComponent;\\n  message: string;\\n\\n  openCustomPopup() &123;\\n    this.popup.open(CustomPopupComponent, &123;\\n      classNames: 'custom',\\n      closeButton: false\\n    &125;);\\n  &125;\\n&125;</code></pre>\\n          </div>\\n         </div>\\n      </ng2-tab>\\n      \\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], PopupComponent);\n    return PopupComponent;\n}());\nexports.PopupComponent = PopupComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvcG9wdXAuY29tcG9uZW50LnRzPzRkZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGlDQUFtQyxDQUFlLENBQUM7QUFDbkQsbUNBQTRELEVBQVEsQ0FBQztBQVFyRTtJQUFBO1FBQ0UsV0FBTSxHQUFXLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBUkQ7UUFBQyxnQkFBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLDZLQUd1QztTQUNsRCxDQUFDOzs0QkFBQTtJQUdGLDJCQUFDO0FBQUQsQ0FBQztBQWdIRDtJQUFBO0lBK0JBLENBQUM7SUEzQkMsd0NBQWUsR0FBZjtRQUNFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxrQ0FBUyxHQUFULFVBQVUsSUFBWSxFQUFFLEtBQWE7UUFBckMsaUJBZUM7UUFkQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxpQ0FBd0IsRUFBRTtZQUN4QyxVQUFVLEVBQUUsSUFBSTtZQUNoQixLQUFLLEVBQUUsS0FBSztZQUNaLE9BQU8sRUFBRSwwQ0FBMEM7WUFDbkQsT0FBTyxFQUFFO2dCQUNQLEVBQUUsRUFBRTtvQkFDRixLQUFJLENBQUMsT0FBTyxHQUFHLHNCQUFzQixDQUFDO2dCQUN4QyxDQUFDO2dCQUNELE1BQU0sRUFBRTtvQkFDTixLQUFJLENBQUMsT0FBTyxHQUFHLDBCQUEwQixDQUFDO29CQUMxQyxLQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUNyQixDQUFDO2FBQ0Y7U0FDRixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsd0NBQWUsR0FBZjtRQUNFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFO1lBQ3BDLFVBQVUsRUFBRSxRQUFRO1lBQ3BCLFdBQVcsRUFBRSxLQUFLO1NBQ25CLENBQUMsQ0FBQztJQUNMLENBQUM7SUE3QkQ7UUFBQyxnQkFBUyxDQUFDLDBCQUFpQixDQUFDOztpREFBQTtJQS9HL0I7UUFBQyxnQkFBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLGt6R0EyR0Q7U0FDVixDQUFDOztzQkFBQTtJQWdDRixxQkFBQztBQUFELENBQUM7QUEvQlksc0JBQWMsaUJBK0IxQiIsImZpbGUiOiIzNzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudCwgVmlld0NoaWxkfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nMlBvcHVwQ29tcG9uZW50LCBOZzJNZXNzYWdlUG9wdXBDb21wb25lbnQgfSBmcm9tICduZzItdWknO1xuXG5AQ29tcG9uZW50KHtcbiAgdGVtcGxhdGU6IGBcbiAgICA8cD5UaGlzIGlzIGN1c3RvbSBwb3B1cDwvcD5cbiAgICB7e251bWJlcn19IDxidXR0b24gKGNsaWNrKT1cIm51bWJlciA9IG51bWJlcisxXCI+aW5jcmVhc2UgbnVtYmVyPC9idXR0b24+PGJyLz5cbiAgICA8YnV0dG9uIChjbGljayk9XCJwb3B1cC5jbG9zZSgpXCI+Y2xvc2U8L2J1dHRvbj5gXG59KVxuY2xhc3MgQ3VzdG9tUG9wdXBDb21wb25lbnQge1xuICBudW1iZXI6IG51bWJlciA9IDA7XG59XG5cbkBDb21wb25lbnQoe1xuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgcGFnZS10aXRsZVwiPlxuICAgICAgPGgxPlBvcHVwPC9oMT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgXG4gICAgICA8bmcyLXBvcHVwICNwb3B1cD48L25nMi1wb3B1cD5cbiAgICAgIDxici8+XG4gICAgICB7e21lc3NhZ2V9fVxuICAgICAgPGJyLz5cbiAgICAgIFxuICAgICAgPGJ1dHRvbiAoY2xpY2spPVwib3BlblBvcHVwKCdzbWFsbCcsICdIZWxsbyBTbWFsbCBQb3B1cCcpXCI+b3BlbiBzbWFsbCBtZXNzYWdlIHBvcHVwPC9idXR0b24+XG4gICAgICA8YnIvPlxuICAgICAgPGJ1dHRvbiAoY2xpY2spPVwib3BlblBvcHVwKCdtZWRpdW0nLCAnSGVsbG8gTWVkaXVtIFBvcHVwJylcIj5vcGVuIG1lZGl1bSBtZXNzYWdlIHBvcHVwPC9idXR0b24+XG4gICAgICA8YnIvPlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7YnV0dG9uIChjbGljayk9XCJvcGVuUG9wdXAoJ3NtYWxsJywgJ0hlbGxvIFNtYWxsIFBvcHVwJylcIj5vcGVuIHNtYWxsIG1lc3NhZ2UgcG9wdXAmbHQ7L2J1dHRvbj5cbiZsdDtici8+XG4mbHQ7YnV0dG9uIChjbGljayk9XCJvcGVuUG9wdXAoJ21lZGl1bScsICdIZWxsbyBNZWRpdW0gUG9wdXAnKVwiPm9wZW4gbWVkaXVtIG1lc3NhZ2UgcG9wdXAmbHQ7L2J1dHRvbj5cbiZsdDtici8+XG4mbHQ7bmcyLXBvcHVwICNwb3B1cD4mbHQ7L25nMi1wb3B1cD48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7Q29tcG9uZW50LCBWaWV3Q2hpbGQmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAmMTIzOyBOZzJQb3B1cENvbXBvbmVudCwgTmcyTWVzc2FnZVBvcHVwQ29tcG9uZW50ICYxMjU7IGZyb20gJ25nMi11aSc7XG5cbmV4cG9ydCBjbGFzcyBwb3B1cGNvbXBvbmVudCAmMTIzO1xuICBAVmlld0NoaWxkKE5nMlBvcHVwQ29tcG9uZW50KSBwb3B1cDogTmcyUG9wdXBDb21wb25lbnQ7XG4gIG1lc3NhZ2U6IHN0cmluZztcblxuICBvcGVuUG9wdXAoc2l6ZSwgdGl0bGUpICYxMjM7XG4gICAgdGhpcy5wb3B1cC5vcGVuKE5nMk1lc3NhZ2VQb3B1cENvbXBvbmVudCwgJjEyMztcbiAgICAgIGNsYXNzTmFtZXM6IHNpemUsXG4gICAgICB0aXRsZTogdGl0bGUsXG4gICAgICBtZXNzYWdlOiBcIlRoaXMgaXMgbWVzc2FnZSBnaXZlbiB1c2luZyBwb3B1cC5vcGVuKClcIixcbiAgICAgIGJ1dHRvbnM6ICYxMjM7XG4gICAgICAgIE9LOiAoKSA9PiAmMTIzO1xuICAgICAgICAgIHRoaXMubWVzc2FnZSA9IFwiT2sgYnV0dG9uIGlzIHByZXNzZWRcIjtcbiAgICAgICAgJjEyNTssXG4gICAgICAgIENBTkNFTDogKCkgPT4gJjEyMztcbiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkNhbmNlbCBidXR0b24gaXMgcHJlc3NlZFwiO1xuICAgICAgICAgIHRoaXMucG9wdXAuY2xvc2UoKTtcbiAgICAgICAgJjEyNTtcbiAgICAgICYxMjU7XG4gICAgJjEyNTspO1xuICAmMTI1O1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmcyLXRhYj5cbiAgICAgIFxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgPGJ1dHRvbiAoY2xpY2spPVwib3BlbkN1c3RvbVBvcHVwKClcIj5vcGVuIGN1c3RvbSBwb3B1cDwvYnV0dG9uPlxuICAgICAgPGJyLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgIDxuZzItdGFiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O2J1dHRvbiAoY2xpY2spPVwib3BlbkN1c3RvbVBvcHVwKClcIj5vcGVuIGN1c3RvbSBwb3B1cCZsdDsvYnV0dG9uPlxuJmx0O2JyLz5cbiZsdDtuZzItcG9wdXAgI3BvcHVwPiZsdDsvbmcyLXBvcHVwPjwvY29kZT48L3ByZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMztDb21wb25lbnQsIFZpZXdDaGlsZCYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICYxMjM7IE5nMlBvcHVwQ29tcG9uZW50ICYxMjU7IGZyb20gJ25nMi11aSc7XG5cbkBDb21wb25lbnQoJjEyMztcbiAgdGVtcGxhdGU6IFxcYFxuICAmbHQ7cD5UaGlzIGlzIGN1c3RvbSBwb3B1cCZsdDsvcD5cbiAgXFxcXCYxMjM7XFxcXCYxMjM7bnVtYmVyXFxcXCYxMjU7XFxcXCYxMjU7ICZsdDtidXR0b24gKGNsaWNrKT1cIm51bWJlciA9IG51bWJlcisxXCI+aW5jcmVhc2UgbnVtYmVyJmx0Oy9idXR0b24+Jmx0O2JyLz5cbiAgJmx0O2J1dHRvbiAoY2xpY2spPVwicG9wdXAuY2xvc2UoKVwiPmNsb3NlJmx0Oy9idXR0b24+XG4gIFxcYFxuJjEyNTspXG5jbGFzcyBDdXN0b21Qb3B1cENvbXBvbmVudCAmMTIzO1xuICBudW1iZXI6IG51bWJlciA9IDA7XG4mMTI1O1xuXG5leHBvcnQgY2xhc3MgcG9wdXBjb21wb25lbnQgJjEyMztcbiAgQFZpZXdDaGlsZChOZzJQb3B1cENvbXBvbmVudCkgcG9wdXA6IE5nMlBvcHVwQ29tcG9uZW50O1xuICBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgb3BlbkN1c3RvbVBvcHVwKCkgJjEyMztcbiAgICB0aGlzLnBvcHVwLm9wZW4oQ3VzdG9tUG9wdXBDb21wb25lbnQsICYxMjM7XG4gICAgICBjbGFzc05hbWVzOiAnY3VzdG9tJyxcbiAgICAgIGNsb3NlQnV0dG9uOiBmYWxzZVxuICAgICYxMjU7KTtcbiAgJjEyNTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgPC9kaXY+XG4gICAgICA8L25nMi10YWI+XG4gICAgICBcbiAgICA8L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIFBvcHVwQ29tcG9uZW50IHtcbiAgQFZpZXdDaGlsZChOZzJQb3B1cENvbXBvbmVudCkgcG9wdXA6IE5nMlBvcHVwQ29tcG9uZW50O1xuICBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgbmdhZnRlcnZpZXdpbml0KCk6IHZvaWQge1xuICAgIHdpbmRvdy5zY3JvbGwoMCwwKTtcbiAgfVxuXG4gIG9wZW5Qb3B1cChzaXplOiBzdHJpbmcsIHRpdGxlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnBvcHVwLm9wZW4oTmcyTWVzc2FnZVBvcHVwQ29tcG9uZW50LCB7XG4gICAgICBjbGFzc05hbWVzOiBzaXplLFxuICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgbWVzc2FnZTogXCJUaGlzIGlzIG1lc3NhZ2UgZ2l2ZW4gdXNpbmcgcG9wdXAub3BlbigpXCIsXG4gICAgICBidXR0b25zOiB7XG4gICAgICAgIE9LOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5tZXNzYWdlID0gXCJPayBidXR0b24gaXMgcHJlc3NlZFwiO1xuICAgICAgICB9LFxuICAgICAgICBDQU5DRUw6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBcIkNhbmNlbCBidXR0b24gaXMgcHJlc3NlZFwiO1xuICAgICAgICAgIHRoaXMucG9wdXAuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgb3BlbkN1c3RvbVBvcHVwKCkge1xuICAgIHRoaXMucG9wdXAub3BlbihDdXN0b21Qb3B1cENvbXBvbmVudCwge1xuICAgICAgY2xhc3NOYW1lczogJ2N1c3RvbScsXG4gICAgICBjbG9zZUJ1dHRvbjogZmFsc2UsXG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvcG9wdXAuY29tcG9uZW50LnRzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 371:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar ng2_ui_1 = __webpack_require__(58);\nvar ScrollableComponent = (function () {\n    function ScrollableComponent() {\n        this.id = 's1';\n        this.hid = 'h1';\n        this.wid = 'w1';\n    }\n    ScrollableComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    ScrollableComponent.prototype.scrollTo = function (selector, parentSelector, horizontal) {\n        ng2_ui_1.Ng2ScrollableDirective.scrollTo(selector, // scroll to this\n        parentSelector, // scroll within (null if window scrolling)\n        horizontal, // is it horizontal scrolling\n        10 // distance from top or left\n        );\n    };\n    ScrollableComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Scrollable</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n      <h2>Scroll Within a Section Vertically</h2>\\n      <ul>\\n        <li *ngFor=\\\"let num of [1,2,3,4,5,6,7,8,9,10]\\\"\\n            [class.current]=\\\"id == 's'+ num \\\"\\n            (click)=\\\"scrollTo('#s'+num, '#v-scrollable')\\\">{{num}}\\n      </ul>\\n\\n      scrolled to: {{id}}\\n      <div id=\\\"v-scrollable\\\" class=\\\"scrollable section\\\"\\n           ng2-scrollable (elementVisible)=\\\"id = $event.id\\\">\\n        <div id=\\\"s1\\\">Section 1  (scroll to here)</div>\\n        <div id=\\\"s2\\\">Section 2  (scroll to here)</div>\\n        <div id=\\\"s3\\\">Section 3  (scroll to here)</div>\\n        <div id=\\\"s4\\\">Section 4  (scroll to here)</div>\\n        <div id=\\\"s5\\\">Section 5  (scroll to here)</div>\\n        <div id=\\\"s6\\\">Section 6  (scroll to here)</div>\\n        <div id=\\\"s7\\\">Section 7  (scroll to here)</div>\\n        <div id=\\\"s8\\\">Section 8  (scroll to here)</div>\\n        <div id=\\\"s9\\\">Section 9  (scroll to here)</div>\\n        <div id=\\\"s10\\\">Section 10  (scroll to here)</div>\\n      </div>\\n      <div class=\\\"spacer\\\"></div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;ul>\\n  &lt;li *ngFor=\\\"let num of [1,2,3,4,5,6,7,8,9,10]\\\"\\n      [class.current]=\\\"id == 's'+ num \\\"\\n      (click)=\\\"scrollTo('#s'+num, '#v-scrollable')\\\">&123;&123;num&125;&125;\\n&lt;/ul>\\n\\nscrolled to: &123;&123;id&125;&125;\\n&lt;div id=\\\"v-scrollable\\\" class=\\\"scrollable section\\\"\\n     ng2-scrollable (elementVisible)=\\\"id = $event.id\\\">\\n  &lt;div id=\\\"s1\\\">Section 1  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s2\\\">Section 2  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s3\\\">Section 3  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s4\\\">Section 4  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s5\\\">Section 5  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s6\\\">Section 6  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s7\\\">Section 7  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s8\\\">Section 8  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s9\\\">Section 9  (scroll to here)&lt;/div>\\n  &lt;div id=\\\"s10\\\">Section 10  (scroll to here)&lt;/div>\\n&lt;/div>\\n</code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\nimport &123; Ng2ScrollableDirective &125; from 'ng2-ui';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  id: string = 's1';\\n  scrollTo(selector, parentSelector, horizontal) &123;\\n    Ng2ScrollableDirective.scrollTo(\\n      selector,       // scroll to this\\n      parentSelector, // scroll within (null if window scrolling)\\n      horizontal,     // is it horizontal scrolling\\n      10              // distance from top or left\\n    );\\n  &125;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\"\\n>ul &123;list-style: none&125;\\nul li &123;display: inline-block; border: 1px solid #999; padding: 10px; cursor: pointer;&125;\\nul li.current &123; background: #333; color: #fff&125;\\n.scrollable &123; height: 200px; border: 1px solid #999; position: relative;&125;\\n.scrollable.window &123; height: auto;&125;\\n.scrollable > div &123;height: 110px&125;\\n.scrollable > div:nth-child(odd) &123; background-color: #ccc&125;\\n.scrollable.section &123;overflow:auto;&125;\\n</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n      \\n      <div class=\\\"spacer\\\"></div>\\n      <h2>Scroll Within a Section Horizontally</h2>\\n      <ul>\\n        <br/>\\n        <li *ngFor=\\\"let num of [1,2,3,4,5,6,7,8,9,10]\\\"\\n            [class.current]=\\\"hid == 'h'+ num \\\"\\n            (click)=\\\"scrollTo('#h'+num, '#h-scrollable', true)\\\">{{num}}\\n      </ul>\\n\\n      scrolled to: {{hid}}\\n      <div id=\\\"h-scrollable\\\" class=\\\"scrollable section horizontal\\\"\\n           ng2-scrollable\\n           [horizontal]=\\\"true\\\"\\n           (elementVisible)=\\\"hid = $event.id\\\">\\n        <div id=\\\"h1\\\">Section 1</div>\\n        <div id=\\\"h2\\\">Section 2</div>\\n        <div id=\\\"h3\\\">Section 3</div>\\n        <div id=\\\"h4\\\">Section 4</div>\\n        <div id=\\\"h5\\\">Section 5</div>\\n        <div id=\\\"h6\\\">Section 6</div>\\n        <div id=\\\"h7\\\">Section 7</div>\\n        <div id=\\\"h8\\\">Section 8</div>\\n        <div id=\\\"h9\\\">Section 9</div>\\n        <div id=\\\"h10\\\">Section 10</div>\\n      </div>\\n      <div class=\\\"spacer\\\"></div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;h2>Scroll Within a Section Horizontally&lt;/h2>\\n&lt;ul>\\n  &lt;br/>\\n  &lt;li *ngFor=\\\"let num of [1,2,3,4,5,6,7,8,9,10]\\\"\\n      [class.current]=\\\"hid == 'h'+ num \\\"\\n      (click)=\\\"scrollTo('#h'+num, '#h-scrollable', true)\\\">&123;&123;num&125;&125;\\n&lt;/ul>\\n\\nscrolled to: &123;&123;hid&125;&125;\\n&lt;div id=\\\"h-scrollable\\\" class=\\\"scrollable section horizontal\\\"\\n     ng2-scrollable\\n     [horizontal]=\\\"true\\\"\\n     (elementVisible)=\\\"hid = $event.id\\\">\\n  &lt;div id=\\\"h1\\\">Section 1&lt;/div>\\n  &lt;div id=\\\"h2\\\">Section 2&lt;/div>\\n  &lt;div id=\\\"h3\\\">Section 3&lt;/div>\\n  &lt;div id=\\\"h4\\\">Section 4&lt;/div>\\n  &lt;div id=\\\"h5\\\">Section 5&lt;/div>\\n  &lt;div id=\\\"h6\\\">Section 6&lt;/div>\\n  &lt;div id=\\\"h7\\\">Section 7&lt;/div>\\n  &lt;div id=\\\"h8\\\">Section 8&lt;/div>\\n  &lt;div id=\\\"h9\\\">Section 9&lt;/div>\\n  &lt;div id=\\\"h10\\\">Section 10&lt;/div>\\n&lt;/div></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\nimport &123; Ng2ScrollableDirective &125; from 'ng2-ui';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  hid: string = 'h1';\\n  scrollTo(selector, parentSelector, horizontal) &123;\\n    Ng2ScrollableDirective.scrollTo(\\n      selector,       // scroll to this\\n      parentSelector, // scroll within (null if window scrolling)\\n      horizontal,     // is it horizontal scrolling\\n      10              // distance from top or left\\n    );\\n  &125;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\"\\n>ul &123;list-style: none&125;\\nul li &123;display: inline-block; border: 1px solid #999; padding: 10px; cursor: pointer;&125;\\nul li.current &123; background: #333; color: #fff&125;\\n.scrollable &123; height: 200px; border: 1px solid #999; position: relative;&125;\\n.scrollable > div &123;height: 110px&125;\\n.scrollable > div:nth-child(odd) &123; background-color: #ccc&125;\\n.scrollable.section &123;overflow:auto;&125;\\n\\n.horizontal &123;\\n  height: 100px;\\n  width: 100%;\\n  max-width: 450px;\\n  white-space: nowrap;\\n  overflow-y: hidden !important;\\n&125;\\n.horizontal > div &123;\\n  border: 1px solid #666;\\n  width: 200px;\\n  height: 80px;\\n  display: inline-block;\\n  text-align: center;\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n      \\n      <div class=\\\"spacer\\\"></div>\\n      <h2>Scroll Within Window</h2>\\n      <div class=\\\"scrollable window\\\"\\n           (elementVisible)=\\\"wid = $event.id\\\"\\n           (elementHidden)=\\\"whid = $event.id\\\"\\n           ng2-scrollable>\\n        <div id=\\\"w1\\\">One</div>\\n        <div id=\\\"w2\\\">Two</div>\\n        <div id=\\\"w3\\\">Three</div>\\n        <div id=\\\"w4\\\">Four</div>\\n        <div id=\\\"w5\\\">Five</div>\\n        <div id=\\\"w6\\\">Six</div>\\n        <div id=\\\"w7\\\">Seven</div>\\n        <div id=\\\"w8\\\">Eight</div>\\n        <div id=\\\"w9\\\">Nine</div>\\n        <div id=\\\"w10\\\">Ten</div>\\n      </div>\\n\\n      <ul style=\\\"position: fixed; bottom: 0; z-index: 1; background-color: #999\\\">\\n        id: {{wid}}\\n        <li *ngFor=\\\"let num of [1,2,3,4,5,6,7,8,9,10]\\\"\\n            [class.current]=\\\"wid == 'w'+ num \\\"\\n            (click)=\\\"scrollTo('#w'+num)\\\">{{num}}</li>\\n      </ul> \\n      <div class=\\\"spacer x4\\\"></div>\\n    </div>\",\n            styles: [\"\\n    ul {list-style: none}\\n    ul li {display: inline-block; border: 1px solid #999; padding: 10px; cursor: pointer;}\\n    ul li.current { background: #333; color: #fff}\\n    .scrollable { height: 200px; border: 1px solid #999; position: relative;}\\n    .scrollable.window { height: auto;}\\n    .scrollable > div {height: 110px}\\n    .scrollable > div:nth-child(odd) { background-color: #ccc}\\n\\n    ul.window {position: fixed; top: 0; left: 0; background: yellow; z-index: 1;}\\n    ul.window li {display: block; }\\n    .scrollable.section {overflow:auto;}\\n    \\n    .horizontal {\\n      height: 100px;\\n      width: 100%;\\n      max-width: 450px;\\n      white-space: nowrap;\\n      overflow-y: hidden !important;\\n    }\\n    .horizontal > div {\\n      border: 1px solid #666;\\n      width: 200px;\\n      height: 80px;\\n      display: inline-block;\\n      text-align: center;\\n    }\\n  \"]\n        }), \n        __metadata('design:paramtypes', [])\n    ], ScrollableComponent);\n    return ScrollableComponent;\n}());\nexports.ScrollableComponent = ScrollableComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvc2Nyb2xsYWJsZS5jb21wb25lbnQudHM/NzdlNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUNBQTBCLENBQWUsQ0FBQztBQUMxQyxtQ0FBdUMsRUFBUSxDQUFDO0FBbVFoRDtJQUFBO1FBS0UsT0FBRSxHQUFXLElBQUksQ0FBQztRQUNsQixRQUFHLEdBQVcsSUFBSSxDQUFDO1FBQ25CLFFBQUcsR0FBVyxJQUFJLENBQUM7SUFTckIsQ0FBQztJQWZDLDZDQUFlLEdBQWY7UUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBS0Qsc0NBQVEsR0FBUixVQUFTLFFBQWdCLEVBQUUsY0FBc0IsRUFBRSxVQUFtQjtRQUNwRSwrQkFBc0IsQ0FBQyxRQUFRLENBQzdCLFFBQVEsRUFBUSxpQkFBaUI7UUFDakMsY0FBYyxFQUFFLDJDQUEyQztRQUMzRCxVQUFVLEVBQU0sNkJBQTZCO1FBQzdDLEVBQUUsQ0FBYyw0QkFBNEI7U0FDN0MsQ0FBQztJQUNKLENBQUM7SUFoUkg7UUFBQyxnQkFBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLG9zUUFrT0Q7WUFDVCxNQUFNLEVBQUUsQ0FBQywyM0JBMkJSLENBQUM7U0FDSCxDQUFDOzsyQkFBQTtJQWlCRiwwQkFBQztBQUFELENBQUM7QUFoQlksMkJBQW1CLHNCQWdCL0IiLCJmaWxlIjoiMzcxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZzJTY3JvbGxhYmxlRGlyZWN0aXZlIH0gZnJvbSAnbmcyLXVpJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBwYWdlLXRpdGxlXCI+XG4gICAgICA8aDE+U2Nyb2xsYWJsZTwvaDE+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgPGgyPlNjcm9sbCBXaXRoaW4gYSBTZWN0aW9uIFZlcnRpY2FsbHk8L2gyPlxuICAgICAgPHVsPlxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IG51bSBvZiBbMSwyLDMsNCw1LDYsNyw4LDksMTBdXCJcbiAgICAgICAgICAgIFtjbGFzcy5jdXJyZW50XT1cImlkID09ICdzJysgbnVtIFwiXG4gICAgICAgICAgICAoY2xpY2spPVwic2Nyb2xsVG8oJyNzJytudW0sICcjdi1zY3JvbGxhYmxlJylcIj57e251bX19XG4gICAgICA8L3VsPlxuXG4gICAgICBzY3JvbGxlZCB0bzoge3tpZH19XG4gICAgICA8ZGl2IGlkPVwidi1zY3JvbGxhYmxlXCIgY2xhc3M9XCJzY3JvbGxhYmxlIHNlY3Rpb25cIlxuICAgICAgICAgICBuZzItc2Nyb2xsYWJsZSAoZWxlbWVudFZpc2libGUpPVwiaWQgPSAkZXZlbnQuaWRcIj5cbiAgICAgICAgPGRpdiBpZD1cInMxXCI+U2VjdGlvbiAxICAoc2Nyb2xsIHRvIGhlcmUpPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJzMlwiPlNlY3Rpb24gMiAgKHNjcm9sbCB0byBoZXJlKTwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiczNcIj5TZWN0aW9uIDMgIChzY3JvbGwgdG8gaGVyZSk8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cInM0XCI+U2VjdGlvbiA0ICAoc2Nyb2xsIHRvIGhlcmUpPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJzNVwiPlNlY3Rpb24gNSAgKHNjcm9sbCB0byBoZXJlKTwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiczZcIj5TZWN0aW9uIDYgIChzY3JvbGwgdG8gaGVyZSk8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cInM3XCI+U2VjdGlvbiA3ICAoc2Nyb2xsIHRvIGhlcmUpPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJzOFwiPlNlY3Rpb24gOCAgKHNjcm9sbCB0byBoZXJlKTwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiczlcIj5TZWN0aW9uIDkgIChzY3JvbGwgdG8gaGVyZSk8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cInMxMFwiPlNlY3Rpb24gMTAgIChzY3JvbGwgdG8gaGVyZSk8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJjc3NcIj5TdHlsZXNoZWV0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7dWw+XG4gICZsdDtsaSAqbmdGb3I9XCJsZXQgbnVtIG9mIFsxLDIsMyw0LDUsNiw3LDgsOSwxMF1cIlxuICAgICAgW2NsYXNzLmN1cnJlbnRdPVwiaWQgPT0gJ3MnKyBudW0gXCJcbiAgICAgIChjbGljayk9XCJzY3JvbGxUbygnI3MnK251bSwgJyN2LXNjcm9sbGFibGUnKVwiPiYxMjM7JjEyMztudW0mMTI1OyYxMjU7XG4mbHQ7L3VsPlxuXG5zY3JvbGxlZCB0bzogJjEyMzsmMTIzO2lkJjEyNTsmMTI1O1xuJmx0O2RpdiBpZD1cInYtc2Nyb2xsYWJsZVwiIGNsYXNzPVwic2Nyb2xsYWJsZSBzZWN0aW9uXCJcbiAgICAgbmcyLXNjcm9sbGFibGUgKGVsZW1lbnRWaXNpYmxlKT1cImlkID0gJGV2ZW50LmlkXCI+XG4gICZsdDtkaXYgaWQ9XCJzMVwiPlNlY3Rpb24gMSAgKHNjcm9sbCB0byBoZXJlKSZsdDsvZGl2PlxuICAmbHQ7ZGl2IGlkPVwiczJcIj5TZWN0aW9uIDIgIChzY3JvbGwgdG8gaGVyZSkmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBpZD1cInMzXCI+U2VjdGlvbiAzICAoc2Nyb2xsIHRvIGhlcmUpJmx0Oy9kaXY+XG4gICZsdDtkaXYgaWQ9XCJzNFwiPlNlY3Rpb24gNCAgKHNjcm9sbCB0byBoZXJlKSZsdDsvZGl2PlxuICAmbHQ7ZGl2IGlkPVwiczVcIj5TZWN0aW9uIDUgIChzY3JvbGwgdG8gaGVyZSkmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBpZD1cInM2XCI+U2VjdGlvbiA2ICAoc2Nyb2xsIHRvIGhlcmUpJmx0Oy9kaXY+XG4gICZsdDtkaXYgaWQ9XCJzN1wiPlNlY3Rpb24gNyAgKHNjcm9sbCB0byBoZXJlKSZsdDsvZGl2PlxuICAmbHQ7ZGl2IGlkPVwiczhcIj5TZWN0aW9uIDggIChzY3JvbGwgdG8gaGVyZSkmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBpZD1cInM5XCI+U2VjdGlvbiA5ICAoc2Nyb2xsIHRvIGhlcmUpJmx0Oy9kaXY+XG4gICZsdDtkaXYgaWQ9XCJzMTBcIj5TZWN0aW9uIDEwICAoc2Nyb2xsIHRvIGhlcmUpJmx0Oy9kaXY+XG4mbHQ7L2Rpdj5cbjwvY29kZT48L3ByZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICYxMjM7IE5nMlNjcm9sbGFibGVEaXJlY3RpdmUgJjEyNTsgZnJvbSAnbmcyLXVpJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuICBpZDogc3RyaW5nID0gJ3MxJztcbiAgc2Nyb2xsVG8oc2VsZWN0b3IsIHBhcmVudFNlbGVjdG9yLCBob3Jpem9udGFsKSAmMTIzO1xuICAgIE5nMlNjcm9sbGFibGVEaXJlY3RpdmUuc2Nyb2xsVG8oXG4gICAgICBzZWxlY3RvciwgICAgICAgLy8gc2Nyb2xsIHRvIHRoaXNcbiAgICAgIHBhcmVudFNlbGVjdG9yLCAvLyBzY3JvbGwgd2l0aGluIChudWxsIGlmIHdpbmRvdyBzY3JvbGxpbmcpXG4gICAgICBob3Jpem9udGFsLCAgICAgLy8gaXMgaXQgaG9yaXpvbnRhbCBzY3JvbGxpbmdcbiAgICAgIDEwICAgICAgICAgICAgICAvLyBkaXN0YW5jZSBmcm9tIHRvcCBvciBsZWZ0XG4gICAgKTtcbiAgJjEyNTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY29udGVudHM9XCJjc3NcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1zdHlsZXNoZWV0XCJcbj51bCAmMTIzO2xpc3Qtc3R5bGU6IG5vbmUmMTI1O1xudWwgbGkgJjEyMztkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IGJvcmRlcjogMXB4IHNvbGlkICM5OTk7IHBhZGRpbmc6IDEwcHg7IGN1cnNvcjogcG9pbnRlcjsmMTI1O1xudWwgbGkuY3VycmVudCAmMTIzOyBiYWNrZ3JvdW5kOiAjMzMzOyBjb2xvcjogI2ZmZiYxMjU7XG4uc2Nyb2xsYWJsZSAmMTIzOyBoZWlnaHQ6IDIwMHB4OyBib3JkZXI6IDFweCBzb2xpZCAjOTk5OyBwb3NpdGlvbjogcmVsYXRpdmU7JjEyNTtcbi5zY3JvbGxhYmxlLndpbmRvdyAmMTIzOyBoZWlnaHQ6IGF1dG87JjEyNTtcbi5zY3JvbGxhYmxlID4gZGl2ICYxMjM7aGVpZ2h0OiAxMTBweCYxMjU7XG4uc2Nyb2xsYWJsZSA+IGRpdjpudGgtY2hpbGQob2RkKSAmMTIzOyBiYWNrZ3JvdW5kLWNvbG9yOiAjY2NjJjEyNTtcbi5zY3JvbGxhYmxlLnNlY3Rpb24gJjEyMztvdmVyZmxvdzphdXRvOyYxMjU7XG48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgPC9kaXY+XG4gICAgICA8L25nMi10YWI+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgIDxoMj5TY3JvbGwgV2l0aGluIGEgU2VjdGlvbiBIb3Jpem9udGFsbHk8L2gyPlxuICAgICAgPHVsPlxuICAgICAgICA8YnIvPlxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IG51bSBvZiBbMSwyLDMsNCw1LDYsNyw4LDksMTBdXCJcbiAgICAgICAgICAgIFtjbGFzcy5jdXJyZW50XT1cImhpZCA9PSAnaCcrIG51bSBcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInNjcm9sbFRvKCcjaCcrbnVtLCAnI2gtc2Nyb2xsYWJsZScsIHRydWUpXCI+e3tudW19fVxuICAgICAgPC91bD5cblxuICAgICAgc2Nyb2xsZWQgdG86IHt7aGlkfX1cbiAgICAgIDxkaXYgaWQ9XCJoLXNjcm9sbGFibGVcIiBjbGFzcz1cInNjcm9sbGFibGUgc2VjdGlvbiBob3Jpem9udGFsXCJcbiAgICAgICAgICAgbmcyLXNjcm9sbGFibGVcbiAgICAgICAgICAgW2hvcml6b250YWxdPVwidHJ1ZVwiXG4gICAgICAgICAgIChlbGVtZW50VmlzaWJsZSk9XCJoaWQgPSAkZXZlbnQuaWRcIj5cbiAgICAgICAgPGRpdiBpZD1cImgxXCI+U2VjdGlvbiAxPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJoMlwiPlNlY3Rpb24gMjwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiaDNcIj5TZWN0aW9uIDM8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cImg0XCI+U2VjdGlvbiA0PC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJoNVwiPlNlY3Rpb24gNTwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiaDZcIj5TZWN0aW9uIDY8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cImg3XCI+U2VjdGlvbiA3PC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJoOFwiPlNlY3Rpb24gODwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwiaDlcIj5TZWN0aW9uIDk8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cImgxMFwiPlNlY3Rpb24gMTA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJjc3NcIj5TdHlsZXNoZWV0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7aDI+U2Nyb2xsIFdpdGhpbiBhIFNlY3Rpb24gSG9yaXpvbnRhbGx5Jmx0Oy9oMj5cbiZsdDt1bD5cbiAgJmx0O2JyLz5cbiAgJmx0O2xpICpuZ0Zvcj1cImxldCBudW0gb2YgWzEsMiwzLDQsNSw2LDcsOCw5LDEwXVwiXG4gICAgICBbY2xhc3MuY3VycmVudF09XCJoaWQgPT0gJ2gnKyBudW0gXCJcbiAgICAgIChjbGljayk9XCJzY3JvbGxUbygnI2gnK251bSwgJyNoLXNjcm9sbGFibGUnLCB0cnVlKVwiPiYxMjM7JjEyMztudW0mMTI1OyYxMjU7XG4mbHQ7L3VsPlxuXG5zY3JvbGxlZCB0bzogJjEyMzsmMTIzO2hpZCYxMjU7JjEyNTtcbiZsdDtkaXYgaWQ9XCJoLXNjcm9sbGFibGVcIiBjbGFzcz1cInNjcm9sbGFibGUgc2VjdGlvbiBob3Jpem9udGFsXCJcbiAgICAgbmcyLXNjcm9sbGFibGVcbiAgICAgW2hvcml6b250YWxdPVwidHJ1ZVwiXG4gICAgIChlbGVtZW50VmlzaWJsZSk9XCJoaWQgPSAkZXZlbnQuaWRcIj5cbiAgJmx0O2RpdiBpZD1cImgxXCI+U2VjdGlvbiAxJmx0Oy9kaXY+XG4gICZsdDtkaXYgaWQ9XCJoMlwiPlNlY3Rpb24gMiZsdDsvZGl2PlxuICAmbHQ7ZGl2IGlkPVwiaDNcIj5TZWN0aW9uIDMmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBpZD1cImg0XCI+U2VjdGlvbiA0Jmx0Oy9kaXY+XG4gICZsdDtkaXYgaWQ9XCJoNVwiPlNlY3Rpb24gNSZsdDsvZGl2PlxuICAmbHQ7ZGl2IGlkPVwiaDZcIj5TZWN0aW9uIDYmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBpZD1cImg3XCI+U2VjdGlvbiA3Jmx0Oy9kaXY+XG4gICZsdDtkaXYgaWQ9XCJoOFwiPlNlY3Rpb24gOCZsdDsvZGl2PlxuICAmbHQ7ZGl2IGlkPVwiaDlcIj5TZWN0aW9uIDkmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBpZD1cImgxMFwiPlNlY3Rpb24gMTAmbHQ7L2Rpdj5cbiZsdDsvZGl2PjwvY29kZT48L3ByZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICYxMjM7IE5nMlNjcm9sbGFibGVEaXJlY3RpdmUgJjEyNTsgZnJvbSAnbmcyLXVpJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuICBoaWQ6IHN0cmluZyA9ICdoMSc7XG4gIHNjcm9sbFRvKHNlbGVjdG9yLCBwYXJlbnRTZWxlY3RvciwgaG9yaXpvbnRhbCkgJjEyMztcbiAgICBOZzJTY3JvbGxhYmxlRGlyZWN0aXZlLnNjcm9sbFRvKFxuICAgICAgc2VsZWN0b3IsICAgICAgIC8vIHNjcm9sbCB0byB0aGlzXG4gICAgICBwYXJlbnRTZWxlY3RvciwgLy8gc2Nyb2xsIHdpdGhpbiAobnVsbCBpZiB3aW5kb3cgc2Nyb2xsaW5nKVxuICAgICAgaG9yaXpvbnRhbCwgICAgIC8vIGlzIGl0IGhvcml6b250YWwgc2Nyb2xsaW5nXG4gICAgICAxMCAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgZnJvbSB0b3Agb3IgbGVmdFxuICAgICk7XG4gICYxMjU7XG4mMTI1OzwvY29kZT48L3ByZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiY3NzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2Utc3R5bGVzaGVldFwiXG4+dWwgJjEyMztsaXN0LXN0eWxlOiBub25lJjEyNTtcbnVsIGxpICYxMjM7ZGlzcGxheTogaW5saW5lLWJsb2NrOyBib3JkZXI6IDFweCBzb2xpZCAjOTk5OyBwYWRkaW5nOiAxMHB4OyBjdXJzb3I6IHBvaW50ZXI7JjEyNTtcbnVsIGxpLmN1cnJlbnQgJjEyMzsgYmFja2dyb3VuZDogIzMzMzsgY29sb3I6ICNmZmYmMTI1O1xuLnNjcm9sbGFibGUgJjEyMzsgaGVpZ2h0OiAyMDBweDsgYm9yZGVyOiAxcHggc29saWQgIzk5OTsgcG9zaXRpb246IHJlbGF0aXZlOyYxMjU7XG4uc2Nyb2xsYWJsZSA+IGRpdiAmMTIzO2hlaWdodDogMTEwcHgmMTI1O1xuLnNjcm9sbGFibGUgPiBkaXY6bnRoLWNoaWxkKG9kZCkgJjEyMzsgYmFja2dyb3VuZC1jb2xvcjogI2NjYyYxMjU7XG4uc2Nyb2xsYWJsZS5zZWN0aW9uICYxMjM7b3ZlcmZsb3c6YXV0bzsmMTI1O1xuXG4uaG9yaXpvbnRhbCAmMTIzO1xuICBoZWlnaHQ6IDEwMHB4O1xuICB3aWR0aDogMTAwJTtcbiAgbWF4LXdpZHRoOiA0NTBweDtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgb3ZlcmZsb3cteTogaGlkZGVuICFpbXBvcnRhbnQ7XG4mMTI1O1xuLmhvcml6b250YWwgPiBkaXYgJjEyMztcbiAgYm9yZGVyOiAxcHggc29saWQgIzY2NjtcbiAgd2lkdGg6IDIwMHB4O1xuICBoZWlnaHQ6IDgwcHg7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgPC9kaXY+XG4gICAgICA8L25nMi10YWI+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgIDxoMj5TY3JvbGwgV2l0aGluIFdpbmRvdzwvaDI+XG4gICAgICA8ZGl2IGNsYXNzPVwic2Nyb2xsYWJsZSB3aW5kb3dcIlxuICAgICAgICAgICAoZWxlbWVudFZpc2libGUpPVwid2lkID0gJGV2ZW50LmlkXCJcbiAgICAgICAgICAgKGVsZW1lbnRIaWRkZW4pPVwid2hpZCA9ICRldmVudC5pZFwiXG4gICAgICAgICAgIG5nMi1zY3JvbGxhYmxlPlxuICAgICAgICA8ZGl2IGlkPVwidzFcIj5PbmU8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cIncyXCI+VHdvPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJ3M1wiPlRocmVlPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJ3NFwiPkZvdXI8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cInc1XCI+Rml2ZTwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwidzZcIj5TaXg8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cInc3XCI+U2V2ZW48L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cInc4XCI+RWlnaHQ8L2Rpdj5cbiAgICAgICAgPGRpdiBpZD1cInc5XCI+TmluZTwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwidzEwXCI+VGVuPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPHVsIHN0eWxlPVwicG9zaXRpb246IGZpeGVkOyBib3R0b206IDA7IHotaW5kZXg6IDE7IGJhY2tncm91bmQtY29sb3I6ICM5OTlcIj5cbiAgICAgICAgaWQ6IHt7d2lkfX1cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBudW0gb2YgWzEsMiwzLDQsNSw2LDcsOCw5LDEwXVwiXG4gICAgICAgICAgICBbY2xhc3MuY3VycmVudF09XCJ3aWQgPT0gJ3cnKyBudW0gXCJcbiAgICAgICAgICAgIChjbGljayk9XCJzY3JvbGxUbygnI3cnK251bSlcIj57e251bX19PC9saT5cbiAgICAgIDwvdWw+IFxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4NFwiPjwvZGl2PlxuICAgIDwvZGl2PmAsXG4gIHN0eWxlczogW2BcbiAgICB1bCB7bGlzdC1zdHlsZTogbm9uZX1cbiAgICB1bCBsaSB7ZGlzcGxheTogaW5saW5lLWJsb2NrOyBib3JkZXI6IDFweCBzb2xpZCAjOTk5OyBwYWRkaW5nOiAxMHB4OyBjdXJzb3I6IHBvaW50ZXI7fVxuICAgIHVsIGxpLmN1cnJlbnQgeyBiYWNrZ3JvdW5kOiAjMzMzOyBjb2xvcjogI2ZmZn1cbiAgICAuc2Nyb2xsYWJsZSB7IGhlaWdodDogMjAwcHg7IGJvcmRlcjogMXB4IHNvbGlkICM5OTk7IHBvc2l0aW9uOiByZWxhdGl2ZTt9XG4gICAgLnNjcm9sbGFibGUud2luZG93IHsgaGVpZ2h0OiBhdXRvO31cbiAgICAuc2Nyb2xsYWJsZSA+IGRpdiB7aGVpZ2h0OiAxMTBweH1cbiAgICAuc2Nyb2xsYWJsZSA+IGRpdjpudGgtY2hpbGQob2RkKSB7IGJhY2tncm91bmQtY29sb3I6ICNjY2N9XG5cbiAgICB1bC53aW5kb3cge3Bvc2l0aW9uOiBmaXhlZDsgdG9wOiAwOyBsZWZ0OiAwOyBiYWNrZ3JvdW5kOiB5ZWxsb3c7IHotaW5kZXg6IDE7fVxuICAgIHVsLndpbmRvdyBsaSB7ZGlzcGxheTogYmxvY2s7IH1cbiAgICAuc2Nyb2xsYWJsZS5zZWN0aW9uIHtvdmVyZmxvdzphdXRvO31cbiAgICBcbiAgICAuaG9yaXpvbnRhbCB7XG4gICAgICBoZWlnaHQ6IDEwMHB4O1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBtYXgtd2lkdGg6IDQ1MHB4O1xuICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgIG92ZXJmbG93LXk6IGhpZGRlbiAhaW1wb3J0YW50O1xuICAgIH1cbiAgICAuaG9yaXpvbnRhbCA+IGRpdiB7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjNjY2O1xuICAgICAgd2lkdGg6IDIwMHB4O1xuICAgICAgaGVpZ2h0OiA4MHB4O1xuICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIH1cbiAgYF1cbn0pXG5leHBvcnQgY2xhc3MgU2Nyb2xsYWJsZUNvbXBvbmVudCB7XG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsMCk7XG4gIH1cblxuICBpZDogc3RyaW5nID0gJ3MxJztcbiAgaGlkOiBzdHJpbmcgPSAnaDEnO1xuICB3aWQ6IHN0cmluZyA9ICd3MSc7XG4gIHNjcm9sbFRvKHNlbGVjdG9yOiBzdHJpbmcsIHBhcmVudFNlbGVjdG9yOiBzdHJpbmcsIGhvcml6b250YWw6IGJvb2xlYW4pIHtcbiAgICBOZzJTY3JvbGxhYmxlRGlyZWN0aXZlLnNjcm9sbFRvKFxuICAgICAgc2VsZWN0b3IsICAgICAgIC8vIHNjcm9sbCB0byB0aGlzXG4gICAgICBwYXJlbnRTZWxlY3RvciwgLy8gc2Nyb2xsIHdpdGhpbiAobnVsbCBpZiB3aW5kb3cgc2Nyb2xsaW5nKVxuICAgICAgaG9yaXpvbnRhbCwgICAgIC8vIGlzIGl0IGhvcml6b250YWwgc2Nyb2xsaW5nXG4gICAgICAxMCAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgZnJvbSB0b3Agb3IgbGVmdFxuICAgICk7XG4gIH1cbn1cblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9uZzItdWktY29tcG9uZW50cy9zY3JvbGxhYmxlLmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 372:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar StickyComponent = (function () {\n    function StickyComponent() {\n    }\n    StickyComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    StickyComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Sticky</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n    \\n      <div class=\\\"sticky-container\\\">\\n        <div class=\\\"sticky-float-right\\\">\\n          <div ng2-sticky style=\\\"float: right\\\"> float: right </div>\\n        </div>\\n      </div>\\n      <div class=\\\"spacer\\\"></div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;div class=\\\"sticky-container\\\">\\n  &lt;div class=\\\"float-right\\\">\\n    &lt;div ng2-sticky style=\\\"float: right\\\"> float: right &lt;/div>\\n  &lt;/div>\\n&lt;/div>\\n</code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\"\\n>.sticky-container > div &123;\\n  border: 1px solid #333;\\n  background-image: linear-gradient(rgba(255, 255, 255, 1) 50%, transparent 50%, transparent);\\n  background-size: 50px 50px;\\n  height: 300px;\\n&125;\\n.sticky-float-right &123;\\n  background-color: rgba(0,255,0, .2);\\n&125;\\ndiv[ng2-sticky] &123;\\n  min-width: 400px;\\n  text-align: center;\\n  background: #333;\\n  color: #fff;\\n  border: 1px solid #333;\\n  padding: 10px;\\n&125;</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n      <div class=\\\"spacer\\\"></div>\\n      <div class=\\\"sticky-container\\\">\\n        <div class=\\\"sticky-float-left\\\">\\n          <div ng2-sticky style=\\\"float: left\\\"> float: left </div>\\n        </div>\\n      </div>\\n      <div class=\\\"spacer\\\"></div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;div class=\\\"sticky-container\\\">\\n  &lt;div class=\\\"float-left\\\">\\n    &lt;div ng2-sticky style=\\\"float: left\\\"> float: left &lt;/div>\\n  &lt;/div>\\n&lt;/div>\\n</code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\"\\n>.sticky-container > div &123;\\n  border: 1px solid #333;\\n  background-image: linear-gradient(rgba(255, 255, 255, 1) 50%, transparent 50%, transparent);\\n  background-size: 50px 50px;\\n  height: 300px;\\n&125;\\n.sticky-float-left &123;\\n  background-color: rgba(255,0,0, .2);\\n&125;\\ndiv[ng2-sticky] &123;\\n  min-width: 400px;\\n  text-align: center;\\n  background: #333;\\n  color: #fff;\\n  border: 1px solid #333;\\n  padding: 10px;\\n&125;\\n</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n      <div class=\\\"spacer\\\"></div>\\n        \\n      <div class=\\\"sticky-container\\\">\\n        <div class=\\\"div-middle\\\">\\n          <div>One</div> <div>After</div> <div>Another</div>\\n          <div ng2-sticky> &lt;div> tag in the middle </div>\\n          <div>One</div> <div>After</div> <div>Another</div>\\n        </div>\\n      </div>\\n      <div class=\\\"spacer\\\"></div>\\n      \\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;div class=\\\"sticky-container\\\">\\n  &lt;div class=\\\"div-middle\\\">\\n    &lt;div>One&lt;/div> &lt;div>After&lt;/div> &lt;div>Another&lt;/div>\\n    &lt;div ng2-sticky> &lt;div> tag in the middle &lt;/div>\\n    &lt;div>One&lt;/div> &lt;div>After&lt;/div> &lt;div>Another&lt;/div>\\n  &lt;/div>\\n&lt;/div></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\"\\n>.sticky-container > div &123;\\n  border: 1px solid #333;\\n  background-image: linear-gradient(rgba(255, 255, 255, 1) 50%, transparent 50%, transparent);\\n  background-size: 50px 50px;\\n  height: 300px;\\n&125;\\n.div-middle &123;\\n  background-color: rgba(0,0,255, .2);\\n&125;\\ndiv[ng2-sticky] &123;\\n  min-width: 400px;\\n  text-align: center;\\n  background: #333;\\n  color: #fff;\\n  border: 1px solid #333;\\n  padding: 10px;\\n&125;\\n.div-middle div[ng2-sticky] &123;\\n  margin: 0;\\n&125;\\n</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n      <div class=\\\"spacer\\\"></div>\\n      <div style=\\\"height:300px\\\">\\n        This space is left-blank intentionally to see scroll effect\\n      </div>\\n      \\n    </div>\",\n            styles: [\"\\n    .sticky-container > div {\\n      /*margin: 20px;*/\\n      border: 1px solid #333;\\n      background-image: linear-gradient(rgba(255, 255, 255, 1) 50%, transparent 50%, transparent);\\n      background-size: 50px 50px;\\n      height: 300px;\\n    }\\n    .sticky-float-left {\\n      background-color: rgba(255,0,0, .2);\\n    }\\n    .sticky-float-right {\\n      background-color: rgba(0,255,0, .2);\\n    }\\n    .div-middle {\\n      background-color: rgba(0,0,255, .2);\\n    }\\n    div[ng2-sticky] {\\n      /*margin: 30px 10px 10px 10px;*/\\n      min-width: 400px;\\n      text-align: center;\\n      background: #333;\\n      color: #fff;\\n      border: 1px solid #333;\\n      padding: 10px;\\n    }\\n    .div-middle div[ng2-sticky] {\\n      margin: 0;\\n    }\\n  \"]\n        }), \n        __metadata('design:paramtypes', [])\n    ], StickyComponent);\n    return StickyComponent;\n}());\nexports.StickyComponent = StickyComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvc3RpY2t5LmNvbXBvbmVudC50cz80MjQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBMEIsQ0FBZSxDQUFDO0FBNE4xQztJQUFBO0lBSUEsQ0FBQztJQUhDLHlDQUFlLEdBQWY7UUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBN05IO1FBQUMsZ0JBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSw0d0tBeUxEO1lBQ1QsTUFBTSxFQUFFLENBQUMsMHZCQTZCUixDQUFDO1NBQ0gsQ0FBQzs7dUJBQUE7SUFLRixzQkFBQztBQUFELENBQUM7QUFKWSx1QkFBZSxrQkFJM0IiLCJmaWxlIjoiMzcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgcGFnZS10aXRsZVwiPlxuICAgICAgPGgxPlN0aWNreTwvaDE+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgIFxuICAgICAgPGRpdiBjbGFzcz1cInN0aWNreS1jb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN0aWNreS1mbG9hdC1yaWdodFwiPlxuICAgICAgICAgIDxkaXYgbmcyLXN0aWNreSBzdHlsZT1cImZsb2F0OiByaWdodFwiPiBmbG9hdDogcmlnaHQgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG4gICAgICA8bmcyLXRhYj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImh0bWxcIj5IVE1MPC9kaXY+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJqc1wiPkphdmFzY3JpcHQ8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImNzc1wiPlN0eWxlc2hlZXQ8L2Rpdj5cbiAgICAgICAgIDwvZGl2PiBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWItY29udGVudHNcIj5cbiAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImh0bWxcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1tYXJrdXBcIlxuPiZsdDtkaXYgY2xhc3M9XCJzdGlja3ktY29udGFpbmVyXCI+XG4gICZsdDtkaXYgY2xhc3M9XCJmbG9hdC1yaWdodFwiPlxuICAgICZsdDtkaXYgbmcyLXN0aWNreSBzdHlsZT1cImZsb2F0OiByaWdodFwiPiBmbG9hdDogcmlnaHQgJmx0Oy9kaXY+XG4gICZsdDsvZGl2PlxuJmx0Oy9kaXY+XG48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImNzc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLXN0eWxlc2hlZXRcIlxuPi5zdGlja3ktY29udGFpbmVyID4gZGl2ICYxMjM7XG4gIGJvcmRlcjogMXB4IHNvbGlkICMzMzM7XG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpIDUwJSwgdHJhbnNwYXJlbnQgNTAlLCB0cmFuc3BhcmVudCk7XG4gIGJhY2tncm91bmQtc2l6ZTogNTBweCA1MHB4O1xuICBoZWlnaHQ6IDMwMHB4O1xuJjEyNTtcbi5zdGlja3ktZmxvYXQtcmlnaHQgJjEyMztcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDI1NSwwLCAuMik7XG4mMTI1O1xuZGl2W25nMi1zdGlja3ldICYxMjM7XG4gIG1pbi13aWR0aDogNDAwcHg7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgYmFja2dyb3VuZDogIzMzMztcbiAgY29sb3I6ICNmZmY7XG4gIGJvcmRlcjogMXB4IHNvbGlkICMzMzM7XG4gIHBhZGRpbmc6IDEwcHg7XG4mMTI1OzwvY29kZT48L3ByZT5cbiAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmcyLXRhYj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzdGlja3ktY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzdGlja3ktZmxvYXQtbGVmdFwiPlxuICAgICAgICAgIDxkaXYgbmcyLXN0aWNreSBzdHlsZT1cImZsb2F0OiBsZWZ0XCI+IGZsb2F0OiBsZWZ0IDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJjc3NcIj5TdHlsZXNoZWV0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7ZGl2IGNsYXNzPVwic3RpY2t5LWNvbnRhaW5lclwiPlxuICAmbHQ7ZGl2IGNsYXNzPVwiZmxvYXQtbGVmdFwiPlxuICAgICZsdDtkaXYgbmcyLXN0aWNreSBzdHlsZT1cImZsb2F0OiBsZWZ0XCI+IGZsb2F0OiBsZWZ0ICZsdDsvZGl2PlxuICAmbHQ7L2Rpdj5cbiZsdDsvZGl2PlxuPC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY29udGVudHM9XCJqc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLWphdmFzY3JpcHRcIlxuPmltcG9ydCAmMTIzOyBDb21wb25lbnQgJjEyNTsgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoJjEyMztcbiAgdGVtcGxhdGVVcjogJ2FwcC5odG1sJ1xuJjEyNTspXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50JjEyMztcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY29udGVudHM9XCJjc3NcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1zdHlsZXNoZWV0XCJcbj4uc3RpY2t5LWNvbnRhaW5lciA+IGRpdiAmMTIzO1xuICBib3JkZXI6IDFweCBzb2xpZCAjMzMzO1xuICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQocmdiYSgyNTUsIDI1NSwgMjU1LCAxKSA1MCUsIHRyYW5zcGFyZW50IDUwJSwgdHJhbnNwYXJlbnQpO1xuICBiYWNrZ3JvdW5kLXNpemU6IDUwcHggNTBweDtcbiAgaGVpZ2h0OiAzMDBweDtcbiYxMjU7XG4uc3RpY2t5LWZsb2F0LWxlZnQgJjEyMztcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsMCwwLCAuMik7XG4mMTI1O1xuZGl2W25nMi1zdGlja3ldICYxMjM7XG4gIG1pbi13aWR0aDogNDAwcHg7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgYmFja2dyb3VuZDogIzMzMztcbiAgY29sb3I6ICNmZmY7XG4gIGJvcmRlcjogMXB4IHNvbGlkICMzMzM7XG4gIHBhZGRpbmc6IDEwcHg7XG4mMTI1O1xuPC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzdGlja3ktY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkaXYtbWlkZGxlXCI+XG4gICAgICAgICAgPGRpdj5PbmU8L2Rpdj4gPGRpdj5BZnRlcjwvZGl2PiA8ZGl2PkFub3RoZXI8L2Rpdj5cbiAgICAgICAgICA8ZGl2IG5nMi1zdGlja3k+ICZsdDtkaXY+IHRhZyBpbiB0aGUgbWlkZGxlIDwvZGl2PlxuICAgICAgICAgIDxkaXY+T25lPC9kaXY+IDxkaXY+QWZ0ZXI8L2Rpdj4gPGRpdj5Bbm90aGVyPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyXCI+PC9kaXY+XG4gICAgICBcbiAgICAgIDxuZzItdGFiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiY3NzXCI+U3R5bGVzaGVldDwvZGl2PlxuICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O2RpdiBjbGFzcz1cInN0aWNreS1jb250YWluZXJcIj5cbiAgJmx0O2RpdiBjbGFzcz1cImRpdi1taWRkbGVcIj5cbiAgICAmbHQ7ZGl2Pk9uZSZsdDsvZGl2PiAmbHQ7ZGl2PkFmdGVyJmx0Oy9kaXY+ICZsdDtkaXY+QW5vdGhlciZsdDsvZGl2PlxuICAgICZsdDtkaXYgbmcyLXN0aWNreT4gJmx0O2Rpdj4gdGFnIGluIHRoZSBtaWRkbGUgJmx0Oy9kaXY+XG4gICAgJmx0O2Rpdj5PbmUmbHQ7L2Rpdj4gJmx0O2Rpdj5BZnRlciZsdDsvZGl2PiAmbHQ7ZGl2PkFub3RoZXImbHQ7L2Rpdj5cbiAgJmx0Oy9kaXY+XG4mbHQ7L2Rpdj48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImNzc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLXN0eWxlc2hlZXRcIlxuPi5zdGlja3ktY29udGFpbmVyID4gZGl2ICYxMjM7XG4gIGJvcmRlcjogMXB4IHNvbGlkICMzMzM7XG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSwgMjU1LCAyNTUsIDEpIDUwJSwgdHJhbnNwYXJlbnQgNTAlLCB0cmFuc3BhcmVudCk7XG4gIGJhY2tncm91bmQtc2l6ZTogNTBweCA1MHB4O1xuICBoZWlnaHQ6IDMwMHB4O1xuJjEyNTtcbi5kaXYtbWlkZGxlICYxMjM7XG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDI1NSwgLjIpO1xuJjEyNTtcbmRpdltuZzItc3RpY2t5XSAmMTIzO1xuICBtaW4td2lkdGg6IDQwMHB4O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGJhY2tncm91bmQ6ICMzMzM7XG4gIGNvbG9yOiAjZmZmO1xuICBib3JkZXI6IDFweCBzb2xpZCAjMzMzO1xuICBwYWRkaW5nOiAxMHB4O1xuJjEyNTtcbi5kaXYtbWlkZGxlIGRpdltuZzItc3RpY2t5XSAmMTIzO1xuICBtYXJnaW46IDA7XG4mMTI1O1xuPC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlclwiPjwvZGl2PlxuICAgICAgPGRpdiBzdHlsZT1cImhlaWdodDozMDBweFwiPlxuICAgICAgICBUaGlzIHNwYWNlIGlzIGxlZnQtYmxhbmsgaW50ZW50aW9uYWxseSB0byBzZWUgc2Nyb2xsIGVmZmVjdFxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICA8L2Rpdj5gLFxuICBzdHlsZXM6IFtgXG4gICAgLnN0aWNreS1jb250YWluZXIgPiBkaXYge1xuICAgICAgLyptYXJnaW46IDIwcHg7Ki9cbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICMzMzM7XG4gICAgICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQocmdiYSgyNTUsIDI1NSwgMjU1LCAxKSA1MCUsIHRyYW5zcGFyZW50IDUwJSwgdHJhbnNwYXJlbnQpO1xuICAgICAgYmFja2dyb3VuZC1zaXplOiA1MHB4IDUwcHg7XG4gICAgICBoZWlnaHQ6IDMwMHB4O1xuICAgIH1cbiAgICAuc3RpY2t5LWZsb2F0LWxlZnQge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsMCwwLCAuMik7XG4gICAgfVxuICAgIC5zdGlja3ktZmxvYXQtcmlnaHQge1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLDI1NSwwLCAuMik7XG4gICAgfVxuICAgIC5kaXYtbWlkZGxlIHtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwwLDI1NSwgLjIpO1xuICAgIH1cbiAgICBkaXZbbmcyLXN0aWNreV0ge1xuICAgICAgLyptYXJnaW46IDMwcHggMTBweCAxMHB4IDEwcHg7Ki9cbiAgICAgIG1pbi13aWR0aDogNDAwcHg7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBiYWNrZ3JvdW5kOiAjMzMzO1xuICAgICAgY29sb3I6ICNmZmY7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjMzMzO1xuICAgICAgcGFkZGluZzogMTBweDtcbiAgICB9XG4gICAgLmRpdi1taWRkbGUgZGl2W25nMi1zdGlja3ldIHtcbiAgICAgIG1hcmdpbjogMDtcbiAgICB9XG4gIGBdXG59KVxuZXhwb3J0IGNsYXNzIFN0aWNreUNvbXBvbmVudCB7XG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsMCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvc3RpY2t5LmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 373:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar TabComponent = (function () {\n    function TabComponent() {\n    }\n    TabComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    TabComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Tab</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n     <h2> Simple Tab </h2>\\n     <div ng2-tab>\\n       <div class=\\\"tabs\\\">\\n          <div index=\\\"html\\\">HTML</div>\\n          <div index=\\\"js\\\">Javascript</div>\\n        </div>\\n        <div class=\\\"tab-contents\\\">\\n          <div contents=\\\"html\\\">\\n<pre><code class=\\\"langage-markup\\\"\\n>&lt;div ng2-tab> \\n &lt;div class=\\\"tabs\\\">\\n    &lt;div index=\\\"html\\\">HTML&lt;/div>\\n    &lt;div index=\\\"js\\\">Javascript&lt;/div>\\n  &lt;/div>\\n  &lt;div class=\\\"tab-contents\\\">\\n    &lt;div contents=\\\"html\\\">HTML  &lt;/div>\\n    &lt;div contents=\\\"js\\\">Javascript  &lt;/div>\\n  &lt;/div>\\n&lt;/div></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"langage-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n        </div>\\n      </div>\\n      \\n      <br/><br/>\\n      <h2> Tab with animation </h2>\\n      <ng2-tab\\n        selected=\\\"js\\\"\\n        selected-index-class=\\\"selected\\\"\\n        selected-contents-class=\\\"fadeIn animated\\\">\\n        <div class=\\\"tabs\\\">\\n          <div index=\\\"html\\\">HTML</div>\\n          <div index=\\\"js\\\">Javascript</div>\\n        </div>\\n        <div class=\\\"tab-contents\\\">\\n          <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;ng2-tab selected=\\\"js\\\" \\n  selected-contents-class=\\\"fadeIn animated\\\" \\n  selected-index-class=\\\"selected\\\">\\n  &lt;div class=\\\"tabs\\\">\\n    &lt;div index=\\\"html\\\">HTML&lt;/div>\\n    &lt;div index=\\\"js\\\">Javascript&lt;/div>\\n  &lt;/div>\\n  &lt;div class=\\\"tab-contents\\\">\\n    &lt;div contents=\\\"html\\\">HTML&lt;/div>\\n    &lt;div contents=\\\"js\\\">Javascript&lt;/div>\\n  &lt;/div>\\n&lt;/ng2-tab></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"langage-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n        </div>\\n        </div>\\n      </ng2-tab> \\n      NOTE: There is a default css given by component, but a user can override the tab style.\\n    </div>\\n\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], TabComponent);\n    return TabComponent;\n}());\nexports.TabComponent = TabComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvdGFiLmNvbXBvbmVudC50cz8wOTQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBMEIsQ0FBZSxDQUFDO0FBbUYxQztJQUFBO0lBSUEsQ0FBQztJQUhDLHNDQUFlLEdBQWY7UUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBcEZIO1FBQUMsZ0JBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSw4dUVBOEVYO1NBQ0EsQ0FBQzs7b0JBQUE7SUFLRixtQkFBQztBQUFELENBQUM7QUFKWSxvQkFBWSxlQUl4QiIsImZpbGUiOiIzNzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBwYWdlLXRpdGxlXCI+XG4gICAgICA8aDE+VGFiPC9oMT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgIDxoMj4gU2ltcGxlIFRhYiA8L2gyPlxuICAgICA8ZGl2IG5nMi10YWI+XG4gICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImh0bWxcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5nYWdlLW1hcmt1cFwiXG4+Jmx0O2RpdiBuZzItdGFiPiBcbiAmbHQ7ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICZsdDtkaXYgaW5kZXg9XCJodG1sXCI+SFRNTCZsdDsvZGl2PlxuICAgICZsdDtkaXYgaW5kZXg9XCJqc1wiPkphdmFzY3JpcHQmbHQ7L2Rpdj5cbiAgJmx0Oy9kaXY+XG4gICZsdDtkaXYgY2xhc3M9XCJ0YWItY29udGVudHNcIj5cbiAgICAmbHQ7ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPkhUTUwgICZsdDsvZGl2PlxuICAgICZsdDtkaXYgY29udGVudHM9XCJqc1wiPkphdmFzY3JpcHQgICZsdDsvZGl2PlxuICAmbHQ7L2Rpdj5cbiZsdDsvZGl2PjwvY29kZT48L3ByZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5nYWdlLWphdmFzY3JpcHRcIlxuPmltcG9ydCAmMTIzOyBDb21wb25lbnQgJjEyNTsgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoJjEyMztcbiAgdGVtcGxhdGVVcjogJ2FwcC5odG1sJ1xuJjEyNTspXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50JjEyMztcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgXG4gICAgICA8YnIvPjxici8+XG4gICAgICA8aDI+IFRhYiB3aXRoIGFuaW1hdGlvbiA8L2gyPlxuICAgICAgPG5nMi10YWJcbiAgICAgICAgc2VsZWN0ZWQ9XCJqc1wiXG4gICAgICAgIHNlbGVjdGVkLWluZGV4LWNsYXNzPVwic2VsZWN0ZWRcIlxuICAgICAgICBzZWxlY3RlZC1jb250ZW50cy1jbGFzcz1cImZhZGVJbiBhbmltYXRlZFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgIDxkaXYgaW5kZXg9XCJqc1wiPkphdmFzY3JpcHQ8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWItY29udGVudHNcIj5cbiAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O25nMi10YWIgc2VsZWN0ZWQ9XCJqc1wiIFxuICBzZWxlY3RlZC1jb250ZW50cy1jbGFzcz1cImZhZGVJbiBhbmltYXRlZFwiIFxuICBzZWxlY3RlZC1pbmRleC1jbGFzcz1cInNlbGVjdGVkXCI+XG4gICZsdDtkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgJmx0O2RpdiBpbmRleD1cImh0bWxcIj5IVE1MJmx0Oy9kaXY+XG4gICAgJmx0O2RpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdCZsdDsvZGl2PlxuICAmbHQ7L2Rpdj5cbiAgJmx0O2RpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICZsdDtkaXYgY29udGVudHM9XCJodG1sXCI+SFRNTCZsdDsvZGl2PlxuICAgICZsdDtkaXYgY29udGVudHM9XCJqc1wiPkphdmFzY3JpcHQmbHQ7L2Rpdj5cbiAgJmx0Oy9kaXY+XG4mbHQ7L25nMi10YWI+PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY29udGVudHM9XCJqc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmdhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmcyLXRhYj4gXG4gICAgICBOT1RFOiBUaGVyZSBpcyBhIGRlZmF1bHQgY3NzIGdpdmVuIGJ5IGNvbXBvbmVudCwgYnV0IGEgdXNlciBjYW4gb3ZlcnJpZGUgdGhlIHRhYiBzdHlsZS5cbiAgICA8L2Rpdj5cbmBcbn0pXG5leHBvcnQgY2xhc3MgVGFiQ29tcG9uZW50IHtcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHdpbmRvdy5zY3JvbGwoMCwwKTtcbiAgfVxufVxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL2FwcC9uZzItdWktY29tcG9uZW50cy90YWIuY29tcG9uZW50LnRzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 374:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar TooltipComponent = (function () {\n    function TooltipComponent() {\n    }\n    TooltipComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    TooltipComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Tooltip</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n      \\n      <div ng2-tooltip=\\\"This is my tooltip\\\">\\n        tooltip 1\\n        <div ng2-tooltip=\\\"this is also tootip\\\">\\n          tooltip 2 \\n          <div ng2-tooltip=\\\"this is too tootip\\\">\\n            tooltip 3\\n          </div>\\n        </div>\\n      </div>\\n      \\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n          <div index=\\\"html\\\">HTML</div>\\n          <div index=\\\"js\\\">Javascript</div>\\n          <div index=\\\"css\\\">Stylesheet</div>\\n        </div> \\n        <div class=\\\"tab-contents\\\">\\n          <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;div ng2-tooltip=\\\"This is my tooltip\\\">\\n  tooltip 1\\n  &lt;div ng2-tooltip=\\\"this is also tootip\\\">\\n    tooltip 2 \\n    &lt;div ng2-tooltip=\\\"this is too tootip\\\">\\n      tooltip 3\\n    &lt;/div>\\n  &lt;/div>\\n&lt;/div></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-css\\\"\\n>[ng2-tooltip] &123;margin: 40px; border: 1px solid #ccc &125;\\n\\n[ng2-tooltip] .tooltip-contents &123;\\n  border: 1px solid #ccc; padding: 5px\\n&125;\\n[ng2-tooltip] .tooltip-down-arrow &123;\\n  height: 10px;\\n&125;\\n[ng2-tooltip] .tooltip-down-arrow:before &123;\\n  content: '';\\n  display: block;\\n  position: absolute;\\n  width: 10px;\\n  height: 10px;\\n  left: 45%;\\n  bottom: 5px;\\n  background: #FFFFFF;\\n  border-left:1px solid #ccc;\\n  border-bottom:1px solid #ccc;\\n  transform:rotate(-45deg);\\n&125;</code></pre>\\n          </div>\\n        </div>\\n      </ng2-tab>\\n      \\n      Plunker Example: https://plnkr.co/edit/keOHIe?p=preview\\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], TooltipComponent);\n    return TooltipComponent;\n}());\nexports.TooltipComponent = TooltipComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvdG9vbHRpcC5jb21wb25lbnQudHM/NTQ0NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUNBQTBCLENBQWUsQ0FBQztBQThFMUM7SUFBQTtJQUlBLENBQUM7SUFIQywwQ0FBZSxHQUFmO1FBQ0UsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQS9FSDtRQUFDLGdCQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsazVEQXlFRDtTQUNWLENBQUM7O3dCQUFBO0lBS0YsdUJBQUM7QUFBRCxDQUFDO0FBSlksd0JBQWdCLG1CQUk1QiIsImZpbGUiOiIzNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciBwYWdlLXRpdGxlXCI+XG4gICAgICA8aDE+VG9vbHRpcDwvaDE+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgXG4gICAgICA8ZGl2IG5nMi10b29sdGlwPVwiVGhpcyBpcyBteSB0b29sdGlwXCI+XG4gICAgICAgIHRvb2x0aXAgMVxuICAgICAgICA8ZGl2IG5nMi10b29sdGlwPVwidGhpcyBpcyBhbHNvIHRvb3RpcFwiPlxuICAgICAgICAgIHRvb2x0aXAgMiBcbiAgICAgICAgICA8ZGl2IG5nMi10b29sdGlwPVwidGhpcyBpcyB0b28gdG9vdGlwXCI+XG4gICAgICAgICAgICB0b29sdGlwIDNcbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIFxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgPGRpdiBpbmRleD1cImh0bWxcIj5IVE1MPC9kaXY+XG4gICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgIDxkaXYgaW5kZXg9XCJjc3NcIj5TdHlsZXNoZWV0PC9kaXY+XG4gICAgICAgIDwvZGl2PiBcbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7ZGl2IG5nMi10b29sdGlwPVwiVGhpcyBpcyBteSB0b29sdGlwXCI+XG4gIHRvb2x0aXAgMVxuICAmbHQ7ZGl2IG5nMi10b29sdGlwPVwidGhpcyBpcyBhbHNvIHRvb3RpcFwiPlxuICAgIHRvb2x0aXAgMiBcbiAgICAmbHQ7ZGl2IG5nMi10b29sdGlwPVwidGhpcyBpcyB0b28gdG9vdGlwXCI+XG4gICAgICB0b29sdGlwIDNcbiAgICAmbHQ7L2Rpdj5cbiAgJmx0Oy9kaXY+XG4mbHQ7L2Rpdj48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImNzc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLWNzc1wiXG4+W25nMi10b29sdGlwXSAmMTIzO21hcmdpbjogNDBweDsgYm9yZGVyOiAxcHggc29saWQgI2NjYyAmMTI1O1xuXG5bbmcyLXRvb2x0aXBdIC50b29sdGlwLWNvbnRlbnRzICYxMjM7XG4gIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7IHBhZGRpbmc6IDVweFxuJjEyNTtcbltuZzItdG9vbHRpcF0gLnRvb2x0aXAtZG93bi1hcnJvdyAmMTIzO1xuICBoZWlnaHQ6IDEwcHg7XG4mMTI1O1xuW25nMi10b29sdGlwXSAudG9vbHRpcC1kb3duLWFycm93OmJlZm9yZSAmMTIzO1xuICBjb250ZW50OiAnJztcbiAgZGlzcGxheTogYmxvY2s7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgd2lkdGg6IDEwcHg7XG4gIGhlaWdodDogMTBweDtcbiAgbGVmdDogNDUlO1xuICBib3R0b206IDVweDtcbiAgYmFja2dyb3VuZDogI0ZGRkZGRjtcbiAgYm9yZGVyLWxlZnQ6MXB4IHNvbGlkICNjY2M7XG4gIGJvcmRlci1ib3R0b206MXB4IHNvbGlkICNjY2M7XG4gIHRyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmcyLXRhYj5cbiAgICAgIFxuICAgICAgUGx1bmtlciBFeGFtcGxlOiBodHRwczovL3BsbmtyLmNvL2VkaXQva2VPSEllP3A9cHJldmlld1xuICAgIDwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgVG9vbHRpcENvbXBvbmVudCB7XG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsMCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvdG9vbHRpcC5jb21wb25lbnQudHNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 375:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar AutoCompleteComponent = (function () {\n    function AutoCompleteComponent() {\n        this.arrayOfStrings = [\"this\", \"is\", \"array\", \"of\", \"text\"];\n        this.arrayOfKeyValues = [{ id: 1, value: 'One' }, { id: 2, value: 'Two' }, { id: 3, value: 'Three' }, { id: 4, value: 'Four' }];\n        this.arrayOfKeyValues2 = [{ key: 1, name: 'Key One' }, { key: 2, name: 'Key Two' }, { key: 3, name: 'Key Three' }, { key: 4, name: 'Key Four' }];\n        this.googleGeoCode = \"https://maps.googleapis.com/maps/api/geocode/json?address=:keyword\";\n    }\n    AutoCompleteComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    AutoCompleteComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Auto Complete</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n      <h2> Autocomplete From Local Source </h2>\\n      <div class=\\\"spacer x3\\\"></div>\\n      <div class=\\\"container round-border\\\">\\n        <div class=\\\"title\\\">Simple string of array as source</div>\\n        <p><input ng2-auto-complete\\n          [(ngModel)]=\\\"model1\\\"\\n          [source]=\\\"arrayOfStrings\\\"\\n          placeholder=\\\"enter text\\\"/>\\n        <p><b>model1</b>: &123;&123;model1 | json&125;&125;\\n        <ng2-tab>\\n          <div class=\\\"tabs\\\">\\n             <div index=\\\"html\\\">HTML</div>\\n             <div index=\\\"js\\\">Javascript</div>\\n           </div> \\n           <div class=\\\"tab-contents\\\">\\n             <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input ng2-auto-complete\\n          [(ngModel)]=\\\"model1\\\"\\n          [source]=\\\"arrayOfStrings\\\"\\n          placeholder=\\\"enter text\\\"/></code></pre>\\n             </div>\\n             <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  model1: any;\\n  arrayOfStrings: string[] =\\n    [\\\"this\\\", \\\"is\\\", \\\"array\\\", \\\"of\\\", \\\"text\\\"];\\n&125;</code></pre>\\n             </div>\\n           </div>\\n        </ng2-tab>\\n      </div>\\n      <div class=\\\"spacer x4\\\"></div>\\n      \\n      <div class=\\\"container round-border\\\">\\n        <div class=\\\"title\\\">Simple object of array as source</div>\\n        <p><input ng2-auto-complete\\n          [(ngModel)]=\\\"model2\\\"\\n          [source]=\\\"arrayOfKeyValues\\\" \\n          placeholder=\\\"enter text\\\"/> \\n        <p><b>model2</b>: &123;&123;model2 | json&125;&125;\\n        <ng2-tab>\\n          <div class=\\\"tabs\\\">\\n             <div index=\\\"html\\\">HTML</div>\\n             <div index=\\\"js\\\">Javascript</div>\\n           </div> \\n           <div class=\\\"tab-contents\\\">\\n             <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input ng2-auto-complete\\n        [(ngModel)]=\\\"model2\\\"\\n        [source]=\\\"arrayOfKeyValues\\\" \\n        placeholder=\\\"enter text\\\"/></code></pre>\\n             </div>\\n             <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  model2: any;\\n  arrayOfKeyValues: any[] =\\n    [&123;id:1, value:'One'&125;, &123;id:2, value:'Two'&125;, &123;id:3, value:'Three'&125;, &123;id:4, value:'Four'&125;];\\n&125;</code></pre>\\n             </div>\\n           </div>\\n        </ng2-tab>\\n      </div>\\n      <div class=\\\"spacer x4\\\"></div>\\n      \\n      <div class=\\\"container round-border\\\">\\n        <div class=\\\"title\\\">Custom object of array as source</div>\\n        <p><input ng2-auto-complete \\n          [source]=\\\"arrayOfKeyValues2\\\"\\n          [(ngModel)]=\\\"model3\\\"\\n          placeholder=\\\"enter text\\\"\\n          value-property-name=\\\"key\\\"\\n          display-property-name=\\\"name\\\"/></p>\\n        <p><b>model3:</b> &123;&123;model3 | json&125;&125;<br/></p>\\n        <ng2-tab>\\n          <div class=\\\"tabs\\\">\\n             <div index=\\\"html\\\">HTML</div>\\n             <div index=\\\"js\\\">Javascript</div>\\n           </div> \\n           <div class=\\\"tab-contents\\\">\\n             <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input ng2-auto-complete \\n          [source]=\\\"arrayOfKeyValues2\\\"\\n          [(ngModel)]=\\\"model3\\\"\\n          placeholder=\\\"enter text\\\"\\n          value-property-name=\\\"key\\\"\\n          display-property-name=\\\"name\\\"/></code></pre>\\n             </div>\\n             <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  model3: any;\\n  arrayOfKeyValues2: any[] =\\n    [&123;key:1, name:'Key One'&125;, &123;key:2, name:'Key Two'&125;, &123;key:3, name:'Key Three'&125;, &123;key:4, name:'Key Four'&125;];\\n&125;</code></pre>\\n             </div>\\n           </div>\\n        </ng2-tab>\\n      </div>\\n        \\n      <h2> Autocomplete From Remote Source </h2>\\n      \\n      <div class=\\\"spacer x3\\\"></div>\\n      <div class=\\\"container round-border\\\">\\n        <div class=\\\"title\\\">Google geocode API as source</div>\\n        <p><b>source:</b> &123;&123;googleGeoCode&125;&125;\\n        <p><input ng2-auto-complete\\n          [(ngModel)]=\\\"model4\\\"\\n          placeholder=\\\"Enter Address(min. 2 chars)\\\"\\n          [source]=\\\"googleGeoCode\\\" \\n          display-property-name=\\\"formatted_address\\\"\\n          path-to-data=\\\"results\\\"\\n          min-chars=\\\"2\\\" />\\n        <p><b>model4</b>: &123;&123;model4 | json&125;&125;<br/></p>\\n        <ng2-tab>\\n          <div class=\\\"tabs\\\">\\n             <div index=\\\"html\\\">HTML</div>\\n             <div index=\\\"js\\\">Javascript</div>\\n           </div> \\n           <div class=\\\"tab-contents\\\">\\n             <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;input ng2-auto-complete\\n          [(ngModel)]=\\\"model4\\\"\\n          placeholder=\\\"Enter Address(min. 2 chars)\\\"\\n          [source]=\\\"googleGeoCode\\\" \\n          display-property-name=\\\"formatted_address\\\"\\n          path-to-data=\\\"results\\\"\\n          min-chars=\\\"2\\\" /></code></pre>\\n             </div>\\n             <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html'\\n&125;)\\nexport class AppComponent&123;\\n  model4: any;\\n\\n  googleGeoCode: string = \\\"https://maps.googleapis.com/maps/api/geocode/json?address=:keyword\\\";\\n&125;</code></pre>\\n             </div>\\n           </div>\\n        </ng2-tab>\\n      </div>\\n      <div class=\\\"spacer x4\\\"></div>\\n      <div class=\\\"spacer x4\\\"></div>\\n      \\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], AutoCompleteComponent);\n    return AutoCompleteComponent;\n}());\nexports.AutoCompleteComponent = AutoCompleteComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvYXV0by1jb21wbGV0ZS5jb21wb25lbnQudHM/ZGNjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUNBQTBCLENBQWUsQ0FBQztBQWlMMUM7SUFBQTtRQUNFLG1CQUFjLEdBQ1osQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFeEMscUJBQWdCLEdBQ2QsQ0FBQyxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUUsS0FBSyxFQUFDLEtBQUssRUFBQyxFQUFFLEVBQUMsRUFBRSxFQUFDLENBQUMsRUFBRSxLQUFLLEVBQUMsS0FBSyxFQUFDLEVBQUUsRUFBQyxFQUFFLEVBQUMsQ0FBQyxFQUFFLEtBQUssRUFBQyxPQUFPLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLEVBQUUsS0FBSyxFQUFDLE1BQU0sRUFBQyxDQUFDLENBQUM7UUFFMUYsc0JBQWlCLEdBQ2YsQ0FBQyxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUUsSUFBSSxFQUFDLFNBQVMsRUFBQyxFQUFFLEVBQUMsR0FBRyxFQUFDLENBQUMsRUFBRSxJQUFJLEVBQUMsU0FBUyxFQUFDLEVBQUUsRUFBQyxHQUFHLEVBQUMsQ0FBQyxFQUFFLElBQUksRUFBQyxXQUFXLEVBQUMsRUFBRSxFQUFDLEdBQUcsRUFBQyxDQUFDLEVBQUUsSUFBSSxFQUFDLFVBQVUsRUFBQyxDQUFDLENBQUM7UUFFMUcsa0JBQWEsR0FBVyxvRUFBb0UsQ0FBQztJQVUvRixDQUFDO0lBSEMsK0NBQWUsR0FBZjtRQUNFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFuTUg7UUFBQyxnQkFBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLGsyTEE2S0Q7U0FDVixDQUFDOzs2QkFBQTtJQXFCRiw0QkFBQztBQUFELENBQUM7QUFwQlksNkJBQXFCLHdCQW9CakMiLCJmaWxlIjoiMzc1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5AQ29tcG9uZW50KHtcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHBhZ2UtdGl0bGVcIj5cbiAgICAgIDxoMT5BdXRvIENvbXBsZXRlPC9oMT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgICA8aDI+IEF1dG9jb21wbGV0ZSBGcm9tIExvY2FsIFNvdXJjZSA8L2gyPlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4M1wiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lciByb3VuZC1ib3JkZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+U2ltcGxlIHN0cmluZyBvZiBhcnJheSBhcyBzb3VyY2U8L2Rpdj5cbiAgICAgICAgPHA+PGlucHV0IG5nMi1hdXRvLWNvbXBsZXRlXG4gICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbDFcIlxuICAgICAgICAgIFtzb3VyY2VdPVwiYXJyYXlPZlN0cmluZ3NcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiZW50ZXIgdGV4dFwiLz5cbiAgICAgICAgPHA+PGI+bW9kZWwxPC9iPjogJjEyMzsmMTIzO21vZGVsMSB8IGpzb24mMTI1OyYxMjU7XG4gICAgICAgIDxuZzItdGFiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgICAgPGRpdiBpbmRleD1cImh0bWxcIj5IVE1MPC9kaXY+XG4gICAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgICA8L2Rpdj4gXG4gICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWItY29udGVudHNcIj5cbiAgICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O2lucHV0IG5nMi1hdXRvLWNvbXBsZXRlXG4gICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbDFcIlxuICAgICAgICAgIFtzb3VyY2VdPVwiYXJyYXlPZlN0cmluZ3NcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiZW50ZXIgdGV4dFwiLz48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuICBtb2RlbDE6IGFueTtcbiAgYXJyYXlPZlN0cmluZ3M6IHN0cmluZ1tdID1cbiAgICBbXCJ0aGlzXCIsIFwiaXNcIiwgXCJhcnJheVwiLCBcIm9mXCIsIFwidGV4dFwiXTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZzItdGFiPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic3BhY2VyIHg0XCI+PC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgcm91bmQtYm9yZGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPlNpbXBsZSBvYmplY3Qgb2YgYXJyYXkgYXMgc291cmNlPC9kaXY+XG4gICAgICAgIDxwPjxpbnB1dCBuZzItYXV0by1jb21wbGV0ZVxuICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWwyXCJcbiAgICAgICAgICBbc291cmNlXT1cImFycmF5T2ZLZXlWYWx1ZXNcIiBcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cImVudGVyIHRleHRcIi8+IFxuICAgICAgICA8cD48Yj5tb2RlbDI8L2I+OiAmMTIzOyYxMjM7bW9kZWwyIHwganNvbiYxMjU7JjEyNTtcbiAgICAgICAgPG5nMi10YWI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICAgIDwvZGl2PiBcbiAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7aW5wdXQgbmcyLWF1dG8tY29tcGxldGVcbiAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbDJcIlxuICAgICAgICBbc291cmNlXT1cImFycmF5T2ZLZXlWYWx1ZXNcIiBcbiAgICAgICAgcGxhY2Vob2xkZXI9XCJlbnRlciB0ZXh0XCIvPjwvY29kZT48L3ByZT5cbiAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KCYxMjM7XG4gIHRlbXBsYXRlVXI6ICdhcHAuaHRtbCdcbiYxMjU7KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCYxMjM7XG4gIG1vZGVsMjogYW55O1xuICBhcnJheU9mS2V5VmFsdWVzOiBhbnlbXSA9XG4gICAgWyYxMjM7aWQ6MSwgdmFsdWU6J09uZScmMTI1OywgJjEyMztpZDoyLCB2YWx1ZTonVHdvJyYxMjU7LCAmMTIzO2lkOjMsIHZhbHVlOidUaHJlZScmMTI1OywgJjEyMztpZDo0LCB2YWx1ZTonRm91cicmMTI1O107XG4mMTI1OzwvY29kZT48L3ByZT5cbiAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmcyLXRhYj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4NFwiPjwvZGl2PlxuICAgICAgXG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHJvdW5kLWJvcmRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGl0bGVcIj5DdXN0b20gb2JqZWN0IG9mIGFycmF5IGFzIHNvdXJjZTwvZGl2PlxuICAgICAgICA8cD48aW5wdXQgbmcyLWF1dG8tY29tcGxldGUgXG4gICAgICAgICAgW3NvdXJjZV09XCJhcnJheU9mS2V5VmFsdWVzMlwiXG4gICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbDNcIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiZW50ZXIgdGV4dFwiXG4gICAgICAgICAgdmFsdWUtcHJvcGVydHktbmFtZT1cImtleVwiXG4gICAgICAgICAgZGlzcGxheS1wcm9wZXJ0eS1uYW1lPVwibmFtZVwiLz48L3A+XG4gICAgICAgIDxwPjxiPm1vZGVsMzo8L2I+ICYxMjM7JjEyMzttb2RlbDMgfCBqc29uJjEyNTsmMTI1Ozxici8+PC9wPlxuICAgICAgICA8bmcyLXRhYj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICAgIDxkaXYgaW5kZXg9XCJqc1wiPkphdmFzY3JpcHQ8L2Rpdj5cbiAgICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImh0bWxcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1tYXJrdXBcIlxuPiZsdDtpbnB1dCBuZzItYXV0by1jb21wbGV0ZSBcbiAgICAgICAgICBbc291cmNlXT1cImFycmF5T2ZLZXlWYWx1ZXMyXCJcbiAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsM1wiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJlbnRlciB0ZXh0XCJcbiAgICAgICAgICB2YWx1ZS1wcm9wZXJ0eS1uYW1lPVwia2V5XCJcbiAgICAgICAgICBkaXNwbGF5LXByb3BlcnR5LW5hbWU9XCJuYW1lXCIvPjwvY29kZT48L3ByZT5cbiAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwianNcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCJcbj5pbXBvcnQgJjEyMzsgQ29tcG9uZW50ICYxMjU7IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KCYxMjM7XG4gIHRlbXBsYXRlVXI6ICdhcHAuaHRtbCdcbiYxMjU7KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCYxMjM7XG4gIG1vZGVsMzogYW55O1xuICBhcnJheU9mS2V5VmFsdWVzMjogYW55W10gPVxuICAgIFsmMTIzO2tleToxLCBuYW1lOidLZXkgT25lJyYxMjU7LCAmMTIzO2tleToyLCBuYW1lOidLZXkgVHdvJyYxMjU7LCAmMTIzO2tleTozLCBuYW1lOidLZXkgVGhyZWUnJjEyNTssICYxMjM7a2V5OjQsIG5hbWU6J0tleSBGb3VyJyYxMjU7XTtcbiYxMjU7PC9jb2RlPjwvcHJlPlxuICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZzItdGFiPlxuICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgPGgyPiBBdXRvY29tcGxldGUgRnJvbSBSZW1vdGUgU291cmNlIDwvaDI+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDNcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXIgcm91bmQtYm9yZGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0aXRsZVwiPkdvb2dsZSBnZW9jb2RlIEFQSSBhcyBzb3VyY2U8L2Rpdj5cbiAgICAgICAgPHA+PGI+c291cmNlOjwvYj4gJjEyMzsmMTIzO2dvb2dsZUdlb0NvZGUmMTI1OyYxMjU7XG4gICAgICAgIDxwPjxpbnB1dCBuZzItYXV0by1jb21wbGV0ZVxuICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWw0XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIEFkZHJlc3MobWluLiAyIGNoYXJzKVwiXG4gICAgICAgICAgW3NvdXJjZV09XCJnb29nbGVHZW9Db2RlXCIgXG4gICAgICAgICAgZGlzcGxheS1wcm9wZXJ0eS1uYW1lPVwiZm9ybWF0dGVkX2FkZHJlc3NcIlxuICAgICAgICAgIHBhdGgtdG8tZGF0YT1cInJlc3VsdHNcIlxuICAgICAgICAgIG1pbi1jaGFycz1cIjJcIiAvPlxuICAgICAgICA8cD48Yj5tb2RlbDQ8L2I+OiAmMTIzOyYxMjM7bW9kZWw0IHwganNvbiYxMjU7JjEyNTs8YnIvPjwvcD5cbiAgICAgICAgPG5nMi10YWI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICAgIDwvZGl2PiBcbiAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7aW5wdXQgbmcyLWF1dG8tY29tcGxldGVcbiAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsNFwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciBBZGRyZXNzKG1pbi4gMiBjaGFycylcIlxuICAgICAgICAgIFtzb3VyY2VdPVwiZ29vZ2xlR2VvQ29kZVwiIFxuICAgICAgICAgIGRpc3BsYXktcHJvcGVydHktbmFtZT1cImZvcm1hdHRlZF9hZGRyZXNzXCJcbiAgICAgICAgICBwYXRoLXRvLWRhdGE9XCJyZXN1bHRzXCJcbiAgICAgICAgICBtaW4tY2hhcnM9XCIyXCIgLz48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuICBtb2RlbDQ6IGFueTtcblxuICBnb29nbGVHZW9Db2RlOiBzdHJpbmcgPSBcImh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9nZW9jb2RlL2pzb24/YWRkcmVzcz06a2V5d29yZFwiO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nMi10YWI+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDRcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDRcIj48L2Rpdj5cbiAgICAgIFxuICAgIDwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgQXV0b0NvbXBsZXRlQ29tcG9uZW50IHtcbiAgYXJyYXlPZlN0cmluZ3M6IHN0cmluZ1tdID1cbiAgICBbXCJ0aGlzXCIsIFwiaXNcIiwgXCJhcnJheVwiLCBcIm9mXCIsIFwidGV4dFwiXTtcblxuICBhcnJheU9mS2V5VmFsdWVzOiBhbnlbXSA9XG4gICAgW3tpZDoxLCB2YWx1ZTonT25lJ30sIHtpZDoyLCB2YWx1ZTonVHdvJ30sIHtpZDozLCB2YWx1ZTonVGhyZWUnfSwge2lkOjQsIHZhbHVlOidGb3VyJ31dO1xuXG4gIGFycmF5T2ZLZXlWYWx1ZXMyOiBhbnlbXSA9XG4gICAgW3trZXk6MSwgbmFtZTonS2V5IE9uZSd9LCB7a2V5OjIsIG5hbWU6J0tleSBUd28nfSwge2tleTozLCBuYW1lOidLZXkgVGhyZWUnfSwge2tleTo0LCBuYW1lOidLZXkgRm91cid9XTtcblxuICBnb29nbGVHZW9Db2RlOiBzdHJpbmcgPSBcImh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9nZW9jb2RlL2pzb24/YWRkcmVzcz06a2V5d29yZFwiO1xuXG4gIG1vZGVsMTogYW55O1xuICBtb2RlbDI6IGFueTtcbiAgbW9kZWwzOiBhbnk7XG4gIG1vZGVsNDogYW55O1xuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB3aW5kb3cuc2Nyb2xsKDAsMCk7XG4gIH1cbn1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvYXV0by1jb21wbGV0ZS5jb21wb25lbnQudHNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 376:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar MenuComponent = (function () {\n    function MenuComponent() {\n    }\n    MenuComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    MenuComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div class=\\\"container page-title\\\">\\n      <h1>Menu</h1>\\n    </div>\\n    <div class=\\\"container\\\">\\n    \\n      <h2>Dropdown Menu</h2>\\n      <div>\\n        <ul class=\\\"horizontal-menu\\\">\\n          <li> Item 1\\n            <ul ng2-menu=\\\"bottom\\\">\\n              <li> Menu Item 1-1 </li>\\n              <li> Menu Item 1-2 </li>\\n              <li> Menu Item 1-3 </li>\\n            </ul>\\n          </li>\\n          \\n          <li> Item 2\\n            <ul ng2-menu=\\\"bottom\\\">\\n              <li> Menu Item 2-1 </li>\\n              <li> Item 2-2 \\n                <ul ng2-menu=\\\"right\\\">\\n                  <li> Menu Item 2-2-1 </li> \\n                  <li> Menu Item 2-2-2 </li>\\n                  <li> Menu Item 2-2-3 </li>\\n                </ul>\\n              </li>\\n              <li> Menu Item 2-3 </li>\\n            </ul>\\n          </li>\\n          <li>Menu Item 3</li>\\n        </ul>\\n      </div>\\n      \\n      <div class=\\\"spacer x8\\\"></div>\\n      <div class=\\\"spacer x8\\\"></div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;ul class=\\\"horizontal-menu\\\">\\n  &lt;li> Menu Item 1\\n    &lt;ul ng2-menu=\\\"top\\\">\\n      &lt;li> Menu Item 1-1\\n      &lt;li> Menu Item 1-2 \\n      &lt;li> Menu Item 1-3\\n    &lt;/ul>\\n  &lt;li> Menu Item 2\\n    &lt;ul ng2-menu=\\\"top\\\">\\n      &lt;li> Menu Item 2-1 \\n      &lt;li> Menu Item 2-2\\n      &lt;li> Menu Item 2-3\\n    &lt;/ul>\\n  &lt;li> Menu Item 3\\n    &lt;ul ng2-menu=\\\"top\\\">\\n      &lt;li> Menu Item 3-1\\n      &lt;li> Menu Item 3-2\\n      &lt;li> Menu Item 3-3\\n    &lt;/ul>\\n&lt;/ul></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html',\\n  styles: [require('./app.css')]\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\"\\n>ul.horizontal-menu,\\n.has-ng2-menu ul[ng2-menu]\\n&123;\\n  background: #3db2e1;\\n  background: -moz-linear-gradient(top, #69c4e8, #21a1d4);\\n  background: -ms-linear-gradient(top, #69c4e8, #21a1d4);\\n  background: -o-linear-gradient(top, #69c4e8, #21a1d4);\\n  background: -webkit-linear-gradient(top, #69c4e8, #21a1d4);\\n  background: linear-gradient(to bottom, #69c4e8, #21a1d4);\\n  border-radius: 2px;\\n  box-shadow: inset 0 -3px 0 #1f97c7, inset 0 -3px 3px #1f9acc, inset 0 2px 2px #9ad7ef, inset 1px 0 2px #22a4d9, inset -1px 0 2px #22a4d9, 0 1px 1px rgba(0, 0, 0, 0.1), 0 2px 2px rgba(0, 0, 0, 0.06), 0 3px 3px rgba(0, 0, 0, 0.17), 2px 1px 2px rgba(0, 0, 0, 0.05), -2px 1px 2px rgba(0, 0, 0, 0.05);\\n  display: inline-block;\\n  font-family: 'Open Sans', Helvetica, sans-serif;\\n  width: auto;\\n&125;\\nul.horizontal-menu > li &123;\\n  -moz-transition: color .2s ease;\\n  -ms-transition: color .2s ease;\\n  -o-transition: color .2s ease;\\n  -webkit-transition: color .2s ease;\\n  color: #ffffff;\\n  display: inline-block !important;\\n  font-size: 13px;\\n  font-weight: 700;\\n  letter-spacing: 1px;\\n  padding: 20px 25px;\\n  text-decoration: none;\\n  text-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);\\n  text-transform: uppercase;\\n  transition: color .2s ease;\\n&125;\\nul.horizontal-menu > li:hover,\\n.has-ng2-menu li:hover &123;\\n  color: #ccc;\\n&125;\\nul.horizontal-menu > li:hover ul,\\n.has-ng2-menu li:hover ul &123;\\n  color: #fff;\\n&125;\\n\\n.dropdown-menu, .right-side-menu, .bottom-menu &123;\\n  display: inline-block;\\n&125;\\n\\n.has-ng2-menu.active &123;\\n  color: #fff;\\n&125;\\n.has-ng2-menu::after &123;\\n  content: '25bc';\\n  display: inline-block;\\n  padding: 6px 12px;\\n  text-align: center;\\n  float: right;\\n  font-size: 8px;\\n  line-height: 13px;\\n&125;\\n.has-ng2-menu.active::after &123;\\n  color: #333;\\n&125;\\n\\n.has-ng2-menu ul[ng2-menu] &123;\\n  background-color: #fff;\\n  display: none;\\n  list-style: none;\\n  margin: 0;\\n  padding: 0\\n&125;\\n.has-ng2-menu.active > ul[ng2-menu] &123;\\n  display: inline-block;\\n&125;\\n.has-ng2-menu > ul[ng2-menu] > li &123;\\n  display: block;\\n  margin: 0;\\n  padding: 10px;\\n  white-space: nowrap;\\n&125;\\n\\n</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n     \\n    \\n      <h2>Right-Side Menu</h2>\\n      \\n      <div class=\\\"right-side-menu\\\">\\n        Menu\\n        <ul ng2-menu=\\\"right\\\">\\n          <li> Menu Item 1 \\n            <ul ng2-menu=\\\"right\\\">\\n              <li> Menu Item 1-1\\n              <li> Menu Item 1-2 \\n              <li> Menu Item 1-3\\n            </ul>\\n          <li> Menu Item 2\\n            <ul ng2-menu=\\\"right\\\">\\n              <li> Menu Item 2-1 &nbsp; &nbsp; &nbsp;\\n              <li> Menu Item 2-2 \\n                <ul ng2-menu=\\\"right\\\">\\n                  <li> Menu Item 2-2-1 \\n                  <li> Menu Item 2-2-2 \\n                  <li> Menu Item 2-2-3 \\n                </ul>\\n              \\n              <li> Menu Item 2-3 \\n            </ul>\\n          <li>Menu Item 3 &nbsp; &nbsp; &nbsp;\\n        </ul>\\n      </div>\\n      \\n      <div class=\\\"spacer x8\\\"></div>\\n      <div class=\\\"spacer x8\\\"></div>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;ul ng2-menu=\\\"right\\\">\\n  &lt;li> Menu Item 1 \\n    &lt;ul ng2-menu=\\\"right\\\">\\n      &lt;li> Menu Item 1-1\\n      &lt;li> Menu Item 1-2 \\n      &lt;li> Menu Item 1-3\\n    &lt;/ul>\\n  &lt;li> Menu Item 2\\n    &lt;ul ng2-menu=\\\"right\\\">\\n      &lt;li> Menu Item 2-1 &nbsp; &nbsp; &nbsp;\\n      &lt;li> Menu Item 2-2 \\n        &lt;ul ng2-menu=\\\"right\\\">\\n          &lt;li> Menu Item 2-2-1 \\n          &lt;li> Menu Item 2-2-2 \\n          &lt;li> Menu Item 2-2-3 \\n        &lt;/ul>\\n      \\n      &lt;li> Menu Item 2-3 \\n    &lt;/ul>\\n  &lt;li>Menu Item 3 &nbsp; &nbsp; &nbsp;\\n&lt;/ul></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html',\\n  styles: [require('./app.css')]\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\">\\nThe same as the above. .... Omitted Intentionally\\n</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n      \\n      \\n      <h2>Bottom-Side Menu</h2>\\n      \\n      <div class=\\\"spacer x8\\\"></div>\\n      <div class=\\\"bottom-menu\\\">\\n        <ul class=\\\"horizontal-menu\\\">\\n          <li> Menu Item 1\\n            <ul ng2-menu=\\\"top\\\">\\n              <li> Menu Item 1-1\\n              <li> Menu Item 1-2 \\n              <li> Menu Item 1-3\\n            </ul>\\n          <li> Menu Item 2\\n            <ul ng2-menu=\\\"top\\\">\\n              <li> Menu Item 2-1 \\n              <li> Menu Item 2-2\\n              <li> Menu Item 2-3\\n            </ul>\\n          <li> Menu Item 3\\n            <ul ng2-menu=\\\"top\\\">\\n              <li> Menu Item 3-1\\n              <li> Menu Item 3-2\\n              <li> Menu Item 3-3\\n            </ul>\\n        </ul>\\n      </div>\\n      \\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n          <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\"\\n>&lt;ul class=\\\"horizontal-menu\\\">\\n  &lt;li> Menu Item 1\\n    &lt;ul ng2-menu=\\\"top\\\">\\n      &lt;li> Menu Item 1-1\\n      &lt;li> Menu Item 1-2 \\n      &lt;li> Menu Item 1-3\\n    &lt;/ul>\\n  &lt;li> Menu Item 2\\n    &lt;ul ng2-menu=\\\"top\\\">\\n      &lt;li> Menu Item 2-1 \\n      &lt;li> Menu Item 2-2\\n      &lt;li> Menu Item 2-3\\n    &lt;/ul>\\n  &lt;li> Menu Item 3\\n    &lt;ul ng2-menu=\\\"top\\\">\\n      &lt;li> Menu Item 3-1\\n      &lt;li> Menu Item 3-2\\n      &lt;li> Menu Item 3-3\\n    &lt;/ul>\\n&lt;/ul></code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\"\\n>import &123; Component &125; from '@angular/core';\\n\\n@Component(&123;\\n  templateUr: 'app.html',\\n  styles: [require('./app.css')]\\n&125;)\\nexport class AppComponent&123;\\n&125;</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\">\\nThe same as the above. .... Omitted Intentionally\\n</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n      \\n      \\n      Plunker Example: https://plnkr.co/edit/wTu6EB?p=preview\\n    </div>\"\n        }), \n        __metadata('design:paramtypes', [])\n    ], MenuComponent);\n    return MenuComponent;\n}());\nexports.MenuComponent = MenuComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvbWVudS5jb21wb25lbnQudHM/ZGZjZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsaUNBQTBCLENBQWUsQ0FBQztBQW9VMUM7SUFBQTtJQUlBLENBQUM7SUFIQyx1Q0FBZSxHQUFmO1FBQ0UsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQXJVSDtRQUFDLGdCQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsMHdSQStURDtTQUNWLENBQUM7O3FCQUFBO0lBS0Ysb0JBQUM7QUFBRCxDQUFDO0FBSlkscUJBQWEsZ0JBSXpCIiwiZmlsZSI6IjM3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHBhZ2UtdGl0bGVcIj5cbiAgICAgIDxoMT5NZW51PC9oMT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gICAgXG4gICAgICA8aDI+RHJvcGRvd24gTWVudTwvaDI+XG4gICAgICA8ZGl2PlxuICAgICAgICA8dWwgY2xhc3M9XCJob3Jpem9udGFsLW1lbnVcIj5cbiAgICAgICAgICA8bGk+IEl0ZW0gMVxuICAgICAgICAgICAgPHVsIG5nMi1tZW51PVwiYm90dG9tXCI+XG4gICAgICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDEtMSA8L2xpPlxuICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAxLTIgPC9saT5cbiAgICAgICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMS0zIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgXG4gICAgICAgICAgPGxpPiBJdGVtIDJcbiAgICAgICAgICAgIDx1bCBuZzItbWVudT1cImJvdHRvbVwiPlxuICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAyLTEgPC9saT5cbiAgICAgICAgICAgICAgPGxpPiBJdGVtIDItMiBcbiAgICAgICAgICAgICAgICA8dWwgbmcyLW1lbnU9XCJyaWdodFwiPlxuICAgICAgICAgICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMi0yLTEgPC9saT4gXG4gICAgICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAyLTItMiA8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMi0yLTMgPC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAyLTMgPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPC9saT5cbiAgICAgICAgICA8bGk+TWVudSBJdGVtIDM8L2xpPlxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDhcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDhcIj48L2Rpdj5cbiAgICAgIDxuZzItdGFiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiY3NzXCI+U3R5bGVzaGVldDwvZGl2PlxuICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiaHRtbFwiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiXG4+Jmx0O3VsIGNsYXNzPVwiaG9yaXpvbnRhbC1tZW51XCI+XG4gICZsdDtsaT4gTWVudSBJdGVtIDFcbiAgICAmbHQ7dWwgbmcyLW1lbnU9XCJ0b3BcIj5cbiAgICAgICZsdDtsaT4gTWVudSBJdGVtIDEtMVxuICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMS0yIFxuICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMS0zXG4gICAgJmx0Oy91bD5cbiAgJmx0O2xpPiBNZW51IEl0ZW0gMlxuICAgICZsdDt1bCBuZzItbWVudT1cInRvcFwiPlxuICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMi0xIFxuICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMi0yXG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAyLTNcbiAgICAmbHQ7L3VsPlxuICAmbHQ7bGk+IE1lbnUgSXRlbSAzXG4gICAgJmx0O3VsIG5nMi1tZW51PVwidG9wXCI+XG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAzLTFcbiAgICAgICZsdDtsaT4gTWVudSBJdGVtIDMtMlxuICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMy0zXG4gICAgJmx0Oy91bD5cbiZsdDsvdWw+PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY29udGVudHM9XCJqc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLWphdmFzY3JpcHRcIlxuPmltcG9ydCAmMTIzOyBDb21wb25lbnQgJjEyNTsgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoJjEyMztcbiAgdGVtcGxhdGVVcjogJ2FwcC5odG1sJyxcbiAgc3R5bGVzOiBbcmVxdWlyZSgnLi9hcHAuY3NzJyldXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImNzc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLXN0eWxlc2hlZXRcIlxuPnVsLmhvcml6b250YWwtbWVudSxcbi5oYXMtbmcyLW1lbnUgdWxbbmcyLW1lbnVdXG4mMTIzO1xuICBiYWNrZ3JvdW5kOiAjM2RiMmUxO1xuICBiYWNrZ3JvdW5kOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICM2OWM0ZTgsICMyMWExZDQpO1xuICBiYWNrZ3JvdW5kOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgIzY5YzRlOCwgIzIxYTFkNCk7XG4gIGJhY2tncm91bmQ6IC1vLWxpbmVhci1ncmFkaWVudCh0b3AsICM2OWM0ZTgsICMyMWExZDQpO1xuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICM2OWM0ZTgsICMyMWExZDQpO1xuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCAjNjljNGU4LCAjMjFhMWQ0KTtcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xuICBib3gtc2hhZG93OiBpbnNldCAwIC0zcHggMCAjMWY5N2M3LCBpbnNldCAwIC0zcHggM3B4ICMxZjlhY2MsIGluc2V0IDAgMnB4IDJweCAjOWFkN2VmLCBpbnNldCAxcHggMCAycHggIzIyYTRkOSwgaW5zZXQgLTFweCAwIDJweCAjMjJhNGQ5LCAwIDFweCAxcHggcmdiYSgwLCAwLCAwLCAwLjEpLCAwIDJweCAycHggcmdiYSgwLCAwLCAwLCAwLjA2KSwgMCAzcHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNyksIDJweCAxcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4wNSksIC0ycHggMXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMDUpO1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJywgSGVsdmV0aWNhLCBzYW5zLXNlcmlmO1xuICB3aWR0aDogYXV0bztcbiYxMjU7XG51bC5ob3Jpem9udGFsLW1lbnUgPiBsaSAmMTIzO1xuICAtbW96LXRyYW5zaXRpb246IGNvbG9yIC4ycyBlYXNlO1xuICAtbXMtdHJhbnNpdGlvbjogY29sb3IgLjJzIGVhc2U7XG4gIC1vLXRyYW5zaXRpb246IGNvbG9yIC4ycyBlYXNlO1xuICAtd2Via2l0LXRyYW5zaXRpb246IGNvbG9yIC4ycyBlYXNlO1xuICBjb2xvcjogI2ZmZmZmZjtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrICFpbXBvcnRhbnQ7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgbGV0dGVyLXNwYWNpbmc6IDFweDtcbiAgcGFkZGluZzogMjBweCAyNXB4O1xuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gIHRleHQtc2hhZG93OiAwIDFweCAwIHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gIHRyYW5zaXRpb246IGNvbG9yIC4ycyBlYXNlO1xuJjEyNTtcbnVsLmhvcml6b250YWwtbWVudSA+IGxpOmhvdmVyLFxuLmhhcy1uZzItbWVudSBsaTpob3ZlciAmMTIzO1xuICBjb2xvcjogI2NjYztcbiYxMjU7XG51bC5ob3Jpem9udGFsLW1lbnUgPiBsaTpob3ZlciB1bCxcbi5oYXMtbmcyLW1lbnUgbGk6aG92ZXIgdWwgJjEyMztcbiAgY29sb3I6ICNmZmY7XG4mMTI1O1xuXG4uZHJvcGRvd24tbWVudSwgLnJpZ2h0LXNpZGUtbWVudSwgLmJvdHRvbS1tZW51ICYxMjM7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiYxMjU7XG5cbi5oYXMtbmcyLW1lbnUuYWN0aXZlICYxMjM7XG4gIGNvbG9yOiAjZmZmO1xuJjEyNTtcbi5oYXMtbmcyLW1lbnU6OmFmdGVyICYxMjM7XG4gIGNvbnRlbnQ6ICdcXDI1YmMnO1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIHBhZGRpbmc6IDZweCAxMnB4O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGZsb2F0OiByaWdodDtcbiAgZm9udC1zaXplOiA4cHg7XG4gIGxpbmUtaGVpZ2h0OiAxM3B4O1xuJjEyNTtcbi5oYXMtbmcyLW1lbnUuYWN0aXZlOjphZnRlciAmMTIzO1xuICBjb2xvcjogIzMzMztcbiYxMjU7XG5cbi5oYXMtbmcyLW1lbnUgdWxbbmcyLW1lbnVdICYxMjM7XG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIGxpc3Qtc3R5bGU6IG5vbmU7XG4gIG1hcmdpbjogMDtcbiAgcGFkZGluZzogMFxuJjEyNTtcbi5oYXMtbmcyLW1lbnUuYWN0aXZlID4gdWxbbmcyLW1lbnVdICYxMjM7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiYxMjU7XG4uaGFzLW5nMi1tZW51ID4gdWxbbmcyLW1lbnVdID4gbGkgJjEyMztcbiAgZGlzcGxheTogYmxvY2s7XG4gIG1hcmdpbjogMDtcbiAgcGFkZGluZzogMTBweDtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiYxMjU7XG5cbjwvY29kZT48L3ByZT5cbiAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmcyLXRhYj5cbiAgICAgXG4gICAgXG4gICAgICA8aDI+UmlnaHQtU2lkZSBNZW51PC9oMj5cbiAgICAgIFxuICAgICAgPGRpdiBjbGFzcz1cInJpZ2h0LXNpZGUtbWVudVwiPlxuICAgICAgICBNZW51XG4gICAgICAgIDx1bCBuZzItbWVudT1cInJpZ2h0XCI+XG4gICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMSBcbiAgICAgICAgICAgIDx1bCBuZzItbWVudT1cInJpZ2h0XCI+XG4gICAgICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDEtMVxuICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAxLTIgXG4gICAgICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDEtM1xuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAyXG4gICAgICAgICAgICA8dWwgbmcyLW1lbnU9XCJyaWdodFwiPlxuICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAyLTEgJm5ic3A7ICZuYnNwOyAmbmJzcDtcbiAgICAgICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMi0yIFxuICAgICAgICAgICAgICAgIDx1bCBuZzItbWVudT1cInJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAyLTItMSBcbiAgICAgICAgICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDItMi0yIFxuICAgICAgICAgICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMi0yLTMgXG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDItMyBcbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPGxpPk1lbnUgSXRlbSAzICZuYnNwOyAmbmJzcDsgJm5ic3A7XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2Rpdj5cbiAgICAgIFxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4OFwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNwYWNlciB4OFwiPjwvZGl2PlxuICAgICAgPG5nMi10YWI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJzXCI+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJodG1sXCI+SFRNTDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwianNcIj5KYXZhc2NyaXB0PC9kaXY+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJjc3NcIj5TdHlsZXNoZWV0PC9kaXY+XG4gICAgICAgICA8L2Rpdj4gXG4gICAgICAgICA8ZGl2IGNsYXNzPVwidGFiLWNvbnRlbnRzXCI+XG4gICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7dWwgbmcyLW1lbnU9XCJyaWdodFwiPlxuICAmbHQ7bGk+IE1lbnUgSXRlbSAxIFxuICAgICZsdDt1bCBuZzItbWVudT1cInJpZ2h0XCI+XG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAxLTFcbiAgICAgICZsdDtsaT4gTWVudSBJdGVtIDEtMiBcbiAgICAgICZsdDtsaT4gTWVudSBJdGVtIDEtM1xuICAgICZsdDsvdWw+XG4gICZsdDtsaT4gTWVudSBJdGVtIDJcbiAgICAmbHQ7dWwgbmcyLW1lbnU9XCJyaWdodFwiPlxuICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMi0xICZuYnNwOyAmbmJzcDsgJm5ic3A7XG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAyLTIgXG4gICAgICAgICZsdDt1bCBuZzItbWVudT1cInJpZ2h0XCI+XG4gICAgICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMi0yLTEgXG4gICAgICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMi0yLTIgXG4gICAgICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMi0yLTMgXG4gICAgICAgICZsdDsvdWw+XG4gICAgICBcbiAgICAgICZsdDtsaT4gTWVudSBJdGVtIDItMyBcbiAgICAmbHQ7L3VsPlxuICAmbHQ7bGk+TWVudSBJdGVtIDMgJm5ic3A7ICZuYnNwOyAmbmJzcDtcbiZsdDsvdWw+PC9jb2RlPjwvcHJlPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY29udGVudHM9XCJqc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLWphdmFzY3JpcHRcIlxuPmltcG9ydCAmMTIzOyBDb21wb25lbnQgJjEyNTsgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoJjEyMztcbiAgdGVtcGxhdGVVcjogJ2FwcC5odG1sJyxcbiAgc3R5bGVzOiBbcmVxdWlyZSgnLi9hcHAuY3NzJyldXG4mMTI1OylcbmV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQmMTIzO1xuJjEyNTs8L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImNzc1wiPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLXN0eWxlc2hlZXRcIj5cblRoZSBzYW1lIGFzIHRoZSBhYm92ZS4gLi4uLiBPbWl0dGVkIEludGVudGlvbmFsbHlcbjwvY29kZT48L3ByZT5cbiAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbmcyLXRhYj5cbiAgICAgIFxuICAgICAgXG4gICAgICA8aDI+Qm90dG9tLVNpZGUgTWVudTwvaDI+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXIgeDhcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJib3R0b20tbWVudVwiPlxuICAgICAgICA8dWwgY2xhc3M9XCJob3Jpem9udGFsLW1lbnVcIj5cbiAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAxXG4gICAgICAgICAgICA8dWwgbmcyLW1lbnU9XCJ0b3BcIj5cbiAgICAgICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMS0xXG4gICAgICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDEtMiBcbiAgICAgICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMS0zXG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDJcbiAgICAgICAgICAgIDx1bCBuZzItbWVudT1cInRvcFwiPlxuICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAyLTEgXG4gICAgICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDItMlxuICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAyLTNcbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgPGxpPiBNZW51IEl0ZW0gM1xuICAgICAgICAgICAgPHVsIG5nMi1tZW51PVwidG9wXCI+XG4gICAgICAgICAgICAgIDxsaT4gTWVudSBJdGVtIDMtMVxuICAgICAgICAgICAgICA8bGk+IE1lbnUgSXRlbSAzLTJcbiAgICAgICAgICAgICAgPGxpPiBNZW51IEl0ZW0gMy0zXG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxuZzItdGFiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFic1wiPlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiaHRtbFwiPkhUTUw8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImpzXCI+SmF2YXNjcmlwdDwvZGl2PlxuICAgICAgICAgICA8ZGl2IGluZGV4PVwiY3NzXCI+U3R5bGVzaGVldDwvZGl2PlxuICAgICAgICAgPC9kaXY+IFxuICAgICAgICAgPGRpdiBjbGFzcz1cInRhYi1jb250ZW50c1wiPlxuICAgICAgICAgIDxkaXYgY29udGVudHM9XCJodG1sXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtbWFya3VwXCJcbj4mbHQ7dWwgY2xhc3M9XCJob3Jpem9udGFsLW1lbnVcIj5cbiAgJmx0O2xpPiBNZW51IEl0ZW0gMVxuICAgICZsdDt1bCBuZzItbWVudT1cInRvcFwiPlxuICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMS0xXG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAxLTIgXG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAxLTNcbiAgICAmbHQ7L3VsPlxuICAmbHQ7bGk+IE1lbnUgSXRlbSAyXG4gICAgJmx0O3VsIG5nMi1tZW51PVwidG9wXCI+XG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAyLTEgXG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAyLTJcbiAgICAgICZsdDtsaT4gTWVudSBJdGVtIDItM1xuICAgICZsdDsvdWw+XG4gICZsdDtsaT4gTWVudSBJdGVtIDNcbiAgICAmbHQ7dWwgbmcyLW1lbnU9XCJ0b3BcIj5cbiAgICAgICZsdDtsaT4gTWVudSBJdGVtIDMtMVxuICAgICAgJmx0O2xpPiBNZW51IEl0ZW0gMy0yXG4gICAgICAmbHQ7bGk+IE1lbnUgSXRlbSAzLTNcbiAgICAmbHQ7L3VsPlxuJmx0Oy91bD48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiXG4+aW1wb3J0ICYxMjM7IENvbXBvbmVudCAmMTI1OyBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCgmMTIzO1xuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnLFxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2FwcC5jc3MnKV1cbiYxMjU7KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCYxMjM7XG4mMTI1OzwvY29kZT48L3ByZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiY3NzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2Utc3R5bGVzaGVldFwiPlxuVGhlIHNhbWUgYXMgdGhlIGFib3ZlLiAuLi4uIE9taXR0ZWQgSW50ZW50aW9uYWxseVxuPC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgICAgXG4gICAgICBcbiAgICAgIFBsdW5rZXIgRXhhbXBsZTogaHR0cHM6Ly9wbG5rci5jby9lZGl0L3dUdTZFQj9wPXByZXZpZXdcbiAgICA8L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVDb21wb25lbnQge1xuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgd2luZG93LnNjcm9sbCgwLDApO1xuICB9XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvbWVudS5jb21wb25lbnQudHNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 377:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar SortableComponent = (function () {\n    function SortableComponent() {\n    }\n    SortableComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    SortableComponent = __decorate([\n        core_1.Component({\n            template: \"\\n    <div>\\n      <div class=\\\"spacer\\\"></div>\\n      <ul ng2-sortable>\\n        <li id=\\\"order\\\">Order</li>\\n        <li id=\\\"me\\\">Me</li>\\n        <li id=\\\"right\\\">Right</li>\\n        <li id=\\\"the\\\">The</li>\\n        <li id=\\\"into\\\">Into</li>\\n        <li id=\\\"put\\\">Put</li>\\n      </ul>\\n      <ng2-tab>\\n        <div class=\\\"tabs\\\">\\n           <div index=\\\"html\\\">HTML</div>\\n           <div index=\\\"js\\\">Javascript</div>\\n           <div index=\\\"css\\\">Stylesheet</div>\\n         </div> \\n         <div class=\\\"tab-contents\\\">\\n           <div contents=\\\"html\\\">\\n<pre><code class=\\\"language-markup\\\">\\n&lt;ul ng2-sortable>\\n  &lt;li id=\\\"order\\\">Order&lt;/li>\\n  &lt;li id=\\\"me\\\">Me&lt;/li>\\n  &lt;li id=\\\"right\\\">Right&lt;/li>\\n  &lt;li id=\\\"the\\\">The&lt;/li>\\n  &lt;li id=\\\"into\\\">Into&lt;/li>\\n  &lt;li id=\\\"put\\\">Put&lt;/li>\\n&lt;/ul>\\n</code></pre>\\n          </div>\\n          <div contents=\\\"js\\\">\\n<pre><code class=\\\"language-javascript\\\">\\nimport {{'{'}} Component {{'}'}} from '@angular/core';\\n\\n@Component({{'{'}}\\n  templateUr: 'app.html'\\n{{'}'}})\\nexport class AppComponent {{'{'}}\\n  order: string[] = [];\\n{{'}'}}</code></pre>\\n          </div>\\n          <div contents=\\\"css\\\">\\n<pre><code class=\\\"language-stylesheet\\\">\\nul[ng2-sortable] {{'}'}}\\n   padding: 10px; \\n   border: 1px solid #ccc;\\n  list-style: none; \\n  display: block\\n{{'}'}}\\nul[ng2-sortable] li {{'{'}}\\n  padding: 10px 5px;\\n  background: #4986e7;\\n  color: #fff; \\n  border: 1px solid #fff;\\n  display: block; \\n  position: relative\\n{{'}'}}\\nul[ng2-sortable] li.drag-enter {{'{'}}\\n  border-top: 2px solid yellow;\\n{{'}'}}\\n</code></pre>\\n           </div>\\n         </div>\\n      </ng2-tab>\\n      \\n    </div>\",\n            styles: [\"\\n    ul[ng2-sortable] {\\n       padding: 10px; \\n       border: 1px solid #ccc;\\n      list-style: none; \\n      display: block\\n    }\\n    ul[ng2-sortable] li {\\n      padding: 10px 5px;\\n      background: #4986e7;\\n      color: #fff; \\n      border: 1px solid #fff;\\n      display: block; \\n      position: relative\\n    }\\n    ul[ng2-sortable] li.drag-enter {\\n      border-top: 2px solid yellow;\\n    }\\n  \"]\n        }), \n        __metadata('design:paramtypes', [])\n    ], SortableComponent);\n    return SortableComponent;\n}());\nexports.SortableComponent = SortableComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbmcyLXVpLWNvbXBvbmVudHMvc29ydGFibGUuY29tcG9uZW50LnRzPzMwNWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLGlDQUEwQixDQUFlLENBQUM7QUF5RjFDO0lBQUE7SUFJQSxDQUFDO0lBSEMsMkNBQWUsR0FBZjtRQUNFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUExRkg7UUFBQyxnQkFBUyxDQUFDO1lBQ1QsUUFBUSxFQUFFLGdyREFpRUQ7WUFDVCxNQUFNLEVBQUUsQ0FBQyw2WkFrQlIsQ0FBQztTQUNILENBQUM7O3lCQUFBO0lBS0Ysd0JBQUM7QUFBRCxDQUFDO0FBSlkseUJBQWlCLG9CQUk3QiIsImZpbGUiOiIzNzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG4gICAgPGRpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cbiAgICAgIDx1bCBuZzItc29ydGFibGU+XG4gICAgICAgIDxsaSBpZD1cIm9yZGVyXCI+T3JkZXI8L2xpPlxuICAgICAgICA8bGkgaWQ9XCJtZVwiPk1lPC9saT5cbiAgICAgICAgPGxpIGlkPVwicmlnaHRcIj5SaWdodDwvbGk+XG4gICAgICAgIDxsaSBpZD1cInRoZVwiPlRoZTwvbGk+XG4gICAgICAgIDxsaSBpZD1cImludG9cIj5JbnRvPC9saT5cbiAgICAgICAgPGxpIGlkPVwicHV0XCI+UHV0PC9saT5cbiAgICAgIDwvdWw+XG4gICAgICA8bmcyLXRhYj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRhYnNcIj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImh0bWxcIj5IVE1MPC9kaXY+XG4gICAgICAgICAgIDxkaXYgaW5kZXg9XCJqc1wiPkphdmFzY3JpcHQ8L2Rpdj5cbiAgICAgICAgICAgPGRpdiBpbmRleD1cImNzc1wiPlN0eWxlc2hlZXQ8L2Rpdj5cbiAgICAgICAgIDwvZGl2PiBcbiAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWItY29udGVudHNcIj5cbiAgICAgICAgICAgPGRpdiBjb250ZW50cz1cImh0bWxcIj5cbjxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1tYXJrdXBcIj5cbiZsdDt1bCBuZzItc29ydGFibGU+XG4gICZsdDtsaSBpZD1cIm9yZGVyXCI+T3JkZXImbHQ7L2xpPlxuICAmbHQ7bGkgaWQ9XCJtZVwiPk1lJmx0Oy9saT5cbiAgJmx0O2xpIGlkPVwicmlnaHRcIj5SaWdodCZsdDsvbGk+XG4gICZsdDtsaSBpZD1cInRoZVwiPlRoZSZsdDsvbGk+XG4gICZsdDtsaSBpZD1cImludG9cIj5JbnRvJmx0Oy9saT5cbiAgJmx0O2xpIGlkPVwicHV0XCI+UHV0Jmx0Oy9saT5cbiZsdDsvdWw+XG48L2NvZGU+PC9wcmU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjb250ZW50cz1cImpzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiPlxuaW1wb3J0IHt7J3snfX0gQ29tcG9uZW50IHt7J30nfX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe3sneyd9fVxuICB0ZW1wbGF0ZVVyOiAnYXBwLmh0bWwnXG57eyd9J319KVxuZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7eyd7J319XG4gIG9yZGVyOiBzdHJpbmdbXSA9IFtdO1xue3snfSd9fTwvY29kZT48L3ByZT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNvbnRlbnRzPVwiY3NzXCI+XG48cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2Utc3R5bGVzaGVldFwiPlxudWxbbmcyLXNvcnRhYmxlXSB7eyd9J319XG4gICBwYWRkaW5nOiAxMHB4OyBcbiAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XG4gIGxpc3Qtc3R5bGU6IG5vbmU7IFxuICBkaXNwbGF5OiBibG9ja1xue3snfSd9fVxudWxbbmcyLXNvcnRhYmxlXSBsaSB7eyd7J319XG4gIHBhZGRpbmc6IDEwcHggNXB4O1xuICBiYWNrZ3JvdW5kOiAjNDk4NmU3O1xuICBjb2xvcjogI2ZmZjsgXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XG4gIGRpc3BsYXk6IGJsb2NrOyBcbiAgcG9zaXRpb246IHJlbGF0aXZlXG57eyd9J319XG51bFtuZzItc29ydGFibGVdIGxpLmRyYWctZW50ZXIge3sneyd9fVxuICBib3JkZXItdG9wOiAycHggc29saWQgeWVsbG93O1xue3snfSd9fVxuPC9jb2RlPjwvcHJlPlxuICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgIDwvZGl2PlxuICAgICAgPC9uZzItdGFiPlxuICAgICAgXG4gICAgPC9kaXY+YCxcbiAgc3R5bGVzOiBbYFxuICAgIHVsW25nMi1zb3J0YWJsZV0ge1xuICAgICAgIHBhZGRpbmc6IDEwcHg7IFxuICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XG4gICAgICBsaXN0LXN0eWxlOiBub25lOyBcbiAgICAgIGRpc3BsYXk6IGJsb2NrXG4gICAgfVxuICAgIHVsW25nMi1zb3J0YWJsZV0gbGkge1xuICAgICAgcGFkZGluZzogMTBweCA1cHg7XG4gICAgICBiYWNrZ3JvdW5kOiAjNDk4NmU3O1xuICAgICAgY29sb3I6ICNmZmY7IFxuICAgICAgYm9yZGVyOiAxcHggc29saWQgI2ZmZjtcbiAgICAgIGRpc3BsYXk6IGJsb2NrOyBcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZVxuICAgIH1cbiAgICB1bFtuZzItc29ydGFibGVdIGxpLmRyYWctZW50ZXIge1xuICAgICAgYm9yZGVyLXRvcDogMnB4IHNvbGlkIHllbGxvdztcbiAgICB9XG4gIGBdXG59KVxuZXhwb3J0IGNsYXNzIFNvcnRhYmxlQ29tcG9uZW50IHtcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHdpbmRvdy5zY3JvbGwoMCwwKTtcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL25nMi11aS1jb21wb25lbnRzL3NvcnRhYmxlLmNvbXBvbmVudC50c1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 378:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(1);\nvar GettingStartedComponent = (function () {\n    function GettingStartedComponent() {\n    }\n    GettingStartedComponent.prototype.ngAfterViewInit = function () {\n        window.scroll(0, 0);\n    };\n    GettingStartedComponent = __decorate([\n        core_1.Component({\n            template: \"\\n<div class=\\\"container page-title\\\">\\n  <h1>Getting Started</h1>\\n</div>\\n<div class=\\\"container\\\">\\n  <p class=\\\"page-title-description\\\">\\n    ng2-ui is a collection of quality Angular2 directives.\\n    To make ng2-ui available to your project, you need to install a npm package and \\n    import NG2_DIRECTIVES.\\n  </p>\\n  \\n  <h2>NPM Install</h2>\\n  <pre><code class=\\\"language-bash\\\">$ npm install ng2-ui --save</code></pre>\\n  \\n  <h2>systemjs.config.js</h2>\\n  <pre><code class=\\\"language-javascript\\\">\\nmap: {{ '{' }}\\n  app: \\\"app\\\",\\n  ...\\n  'ng2-ui': 'https://npmcdn.com/ng2-ui' // <----- this\\n{{ '}' }},\\n\\npackages: {{ '{' }}\\n   app: {{ '{' }}main: './main.js', defaultExtension: 'js'{{ '}' }},\\n   ...\\n   'ng2-ui': {{ '{' }} main: 'dist/index.js', defaultExtension: 'js' {{ '}' }}  // <----- this\\n   {{ '}' }}\\n}</code></pre>\\n      \\n  <h2>Usage</h2>\\n  <p><b>Import and include directives for your application</b>\\n  <p>app.component.ts\\n  <pre><code class=\\\"language-javascript\\\">\\n//our root app component\\nimport {{ '{' }}Component, enableProdMode{{ '}' }} from '@angular/core'\\nenableProdMode();\\n\\n@Component({{ '{' }}\\n  selector: 'my-app',\\n  template: require('./src/app.tpl.html'),\\n{{ '}' }})\\nexport class AppComponent {{ '{' }} ... {{ '}' }}\\n</code></pre>\\n\\n<p><b>src/app.tpl.html</b></p>\\n<pre><code class=\\\"language-markup\\\">\\n&lt;input [(ngModel)]=\\\"date1\\\" ng2-datetime-picker /> \\n\\n&lt;ng2-map center=\\\"Brampton, Canada\\\">&lt;/ng2-map> \\n</code></pre>\\n</div>\\n  \"\n        }), \n        __metadata('design:paramtypes', [])\n    ], GettingStartedComponent);\n    return GettingStartedComponent;\n}());\nexports.GettingStartedComponent = GettingStartedComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvZ2V0dGluZy1zdGFydGVkLmNvbXBvbmVudC50cz8yYWZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBMEIsQ0FBZSxDQUFDO0FBdUQxQztJQUFBO0lBSUEsQ0FBQztJQUhDLGlEQUFlLEdBQWY7UUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBekRIO1FBQUMsZ0JBQVMsQ0FBQztZQUNULFFBQVEsRUFBRSxtK0NBbURUO1NBQ0YsQ0FBQzs7K0JBQUE7SUFLRiw4QkFBQztBQUFELENBQUM7QUFKWSwrQkFBdUIsMEJBSW5DIiwiZmlsZSI6IjM3OC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG48ZGl2IGNsYXNzPVwiY29udGFpbmVyIHBhZ2UtdGl0bGVcIj5cbiAgPGgxPkdldHRpbmcgU3RhcnRlZDwvaDE+XG48L2Rpdj5cbjxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgPHAgY2xhc3M9XCJwYWdlLXRpdGxlLWRlc2NyaXB0aW9uXCI+XG4gICAgbmcyLXVpIGlzIGEgY29sbGVjdGlvbiBvZiBxdWFsaXR5IEFuZ3VsYXIyIGRpcmVjdGl2ZXMuXG4gICAgVG8gbWFrZSBuZzItdWkgYXZhaWxhYmxlIHRvIHlvdXIgcHJvamVjdCwgeW91IG5lZWQgdG8gaW5zdGFsbCBhIG5wbSBwYWNrYWdlIGFuZCBcbiAgICBpbXBvcnQgTkcyX0RJUkVDVElWRVMuXG4gIDwvcD5cbiAgXG4gIDxoMj5OUE0gSW5zdGFsbDwvaDI+XG4gIDxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1iYXNoXCI+JCBucG0gaW5zdGFsbCBuZzItdWkgLS1zYXZlPC9jb2RlPjwvcHJlPlxuICBcbiAgPGgyPnN5c3RlbWpzLmNvbmZpZy5qczwvaDI+XG4gIDxwcmU+PGNvZGUgY2xhc3M9XCJsYW5ndWFnZS1qYXZhc2NyaXB0XCI+XG5tYXA6IHt7ICd7JyB9fVxuICBhcHA6IFwiYXBwXCIsXG4gIC4uLlxuICAnbmcyLXVpJzogJ2h0dHBzOi8vbnBtY2RuLmNvbS9uZzItdWknIC8vIDwtLS0tLSB0aGlzXG57eyAnfScgfX0sXG5cbnBhY2thZ2VzOiB7eyAneycgfX1cbiAgIGFwcDoge3sgJ3snIH19bWFpbjogJy4vbWFpbi5qcycsIGRlZmF1bHRFeHRlbnNpb246ICdqcyd7eyAnfScgfX0sXG4gICAuLi5cbiAgICduZzItdWknOiB7eyAneycgfX0gbWFpbjogJ2Rpc3QvaW5kZXguanMnLCBkZWZhdWx0RXh0ZW5zaW9uOiAnanMnIHt7ICd9JyB9fSAgLy8gPC0tLS0tIHRoaXNcbiAgIHt7ICd9JyB9fVxufTwvY29kZT48L3ByZT5cbiAgICAgIFxuICA8aDI+VXNhZ2U8L2gyPlxuICA8cD48Yj5JbXBvcnQgYW5kIGluY2x1ZGUgZGlyZWN0aXZlcyBmb3IgeW91ciBhcHBsaWNhdGlvbjwvYj5cbiAgPHA+YXBwLmNvbXBvbmVudC50c1xuICA8cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtamF2YXNjcmlwdFwiPlxuLy9vdXIgcm9vdCBhcHAgY29tcG9uZW50XG5pbXBvcnQge3sgJ3snIH19Q29tcG9uZW50LCBlbmFibGVQcm9kTW9kZXt7ICd9JyB9fSBmcm9tICdAYW5ndWxhci9jb3JlJ1xuZW5hYmxlUHJvZE1vZGUoKTtcblxuQENvbXBvbmVudCh7eyAneycgfX1cbiAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zcmMvYXBwLnRwbC5odG1sJyksXG57eyAnfScgfX0pXG5leHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHt7ICd7JyB9fSAuLi4ge3sgJ30nIH19XG48L2NvZGU+PC9wcmU+XG5cbjxwPjxiPnNyYy9hcHAudHBsLmh0bWw8L2I+PC9wPlxuPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLW1hcmt1cFwiPlxuJmx0O2lucHV0IFsobmdNb2RlbCldPVwiZGF0ZTFcIiBuZzItZGF0ZXRpbWUtcGlja2VyIC8+IFxuXG4mbHQ7bmcyLW1hcCBjZW50ZXI9XCJCcmFtcHRvbiwgQ2FuYWRhXCI+Jmx0Oy9uZzItbWFwPiBcbjwvY29kZT48L3ByZT5cbjwvZGl2PlxuICBgXG59KVxuZXhwb3J0IGNsYXNzIEdldHRpbmdTdGFydGVkQ29tcG9uZW50IHtcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHdpbmRvdy5zY3JvbGwoMCwwKTtcbiAgfVxufVxuXG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vYXBwL2dldHRpbmctc3RhcnRlZC5jb21wb25lbnQudHNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ }

});